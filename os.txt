Operating System
Concepts

1

Syllabus
 上課時間: Friday 19:35-22:00
 教室:M 501
 教科書：
Silberschatz, Galvin, and Gagne, “Operating
System Concept,” Seventh Edition, John
Wiley & Sons, Inc., 2006.
 成績評量：(subject to changes.):
期中考(30%), 期末考(30%), 課堂參與(40%)

2
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Contents
1. Introduction
2. Computer-System Structures
3. Operating-System Structures
4. Processes
5. Threads
6. CPU Scheduling
7. Process Synchronization
8. Deadlocks
9. Memory Management
10. Virtual Memory
11. File Systems
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

3

Chapter 1. Introduction

4

Introduction
 What is an Operating System?
 A basis for application programs
 An intermediary between users and
hardware

 Amazing variety
 Mainframe, personal computer (PC),
handheld computer, embedded
computer without any user view
Convenient vs Efficient
5
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Computer System Components
User

User

.................

Application Programs
Operating System
Hardware

User
compilers,
word processors,
spreadsheets,
browsers, etc.
CPU, I/O devices,
memory, etc.

 OS – a government/environment provider
6
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

User View
 The user view of the computer varies by
the interface being used!
 Examples:
 Personal Computer Æ Ease of use
 Mainframe or minicomputer Æ
maximization of resource utilization
 Efficiency and fair share

 Workstations Æ compromise between
individual usability & resource utilization
 Handheld computer Æ individual usability
 Embedded computer without user view Æ
run without user intervention
7
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

System View
 A Resource Allocator
 CPU time, Memory Space, File
Storage, I/O Devices, Shared Code,
Data Structures, and more

 A Control Program
 Control execution of user programs
 Prevent errors and misuse

 OS definitions – US Dept.of Justice
against Microsoft in 1998
 The stuff shipped by vendors as an OS
 Run at all time
8
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

System Goals
 Two Conflicting Goals:
 Convenient for the user!
 Efficient operation of the computer
system!

 We should
 recognize the influences of operating
systems and computer architecture on
each other
 and learn why and how OS’s are by
tracing their evolution and predicting what
they will become!
9
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

UNIX Architecture
User
interface
System call
interface

useruser user
user
user
user
user
Shells, compilers, X, application programs, etc.
CPU scheduling, signal handling,
virtual memory, paging, swapping,
file system, disk drivers, caching/buffering, etc.

Kernel interface
to the hardware

terminal controller, terminals,
physical memory, device controller,
devices such as disks, memory, etc.

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

UNIX

10

Mainframe Systems
 The first used to tackle many
commercial and scientific
applications!
 0th Generation – 1940?s
 A significant amount of set-up time in
the running of a job
 Programmer = operator
 Programmed in binary Æ assembler
Æ (1950) high level languages
11
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Mainframe – Batch Systems
 Batches sorted and submitted by
the operator
 Simple batch systems
 Off-line processing
~ Replace slow input devices with
faster units Æ replace card
readers with disks
 Resident monitor
~ Automatically transfer control from
one job to the next

• loader
• job sequencing
• control card
interpreter

monitor

User Program
Area

12
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Mainframe – Batch Systems
 Spooling (Simultaneous Peripheral Operation OnLine)
~ Replace sequential-access devices with random-access
device
=> Overlap the I/O of one job with the computation of others
e.g. card Æ disk, CPU services, disk Æ printer

 Job Scheduling
disks
card reader

disks
CPU

printer
13

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Mainframe –
Multiprogrammed Systems
 Multiprogramming increases CPU
utilization by organizing jobs so
that the CPU always has one to
execute – Early 1960
 Multiporgrammed batched
systems
 Job scheduling and CPU
scheduling
 Goal : efficient use of scare
resources

monitor CPU
scheduling
job1
job2
job3

disk
14

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Mainframe – Time-Sharing
Systems
 Time sharing (or
multitasking) is a logical
extension of
multiprogramming!
 Started in 1960s and
become common in
1970s.
 An interactive (or handon) computer system
 Multics, IBM OS/360

on-line file system
virtual memory
sophisticated CPU scheduling
job synchronization
protection & security
......
and so on

disk

15
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Desktop Systems
 Personal Computers (PC’s)
 Appeared in the 1970s.
 Goals of operating systems keep
changing
 Less-Powerful Hardware & Isolated
EnvironmentÆ Poor Features
 Benefited from the development of
mainframe OS’s and the dropping of
hardware cost
 Advanced protection features

 User Convenience & Responsiveness
16
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Parallel Systems
 Tightly coupled: have more than one
processor in close communication sharing
computer bus, clock, and sometimes
memory and peripheral devices
 Loosely coupled: otherwise
 Advantages
 Speedup – Throughput
 Lower cost – Economy of Scale
 More reliable – Graceful Degradation Æ
Fail Soft (detection, diagnosis, correction)
• A Tandem fault-tolerance solution
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

17

Parallel Systems
 Symmetric multiprocessing model: each
processor runs an identical copy of the OS
 Asymmetric multiprocessing model: a masterslave relationship
~ Dynamically allocate or pre-allocate tasks
~ Commonly seen in extremely large systems
~ Hardware and software make a difference?

 Trend: the dropping of microporcessor cost
Î OS functions are offloaded to slave
processors (back-ends)
18
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Distributed Systems
 Definition: Loosely-Coupled Systems –
processors do not share memory or a clock
 Heterogeneous vs Homogeneous

 Advantages or Reasons
 Resource sharing: computation power,
peripheral devices, specialized hardware
 Computation speedup: distribute the
computation among various sites – load
sharing
 Reliability: redundancy Æ reliability
 Communication: X-window, email
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

19

Distributed Systems
 Distributed systems depend on
networking for their functionality.
 Networks vary by the protocols used.
 TCP/IP, ATM, etc.

 Types – distance
 Local-area network (LAN)
 Wide-area network (WAN)
 Metropolitan-area network (MAN)
 Small-area network – distance of few feet

 Media – copper wires, fiber strands,
satellite wireless transmission, infrared
communication,etc.
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

20

Distributed Systems
 Client-Server Systems
 Compute-server systems
 File-server systems

 Peer-to-Peer Systems
 Network connectivity is an essential
component.

 Network Operating Systems
 Autonomous computers
 A distributed operating system – a
single OS controlling the network.
21
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Clustered Systems
 Definition: Clustered computers which
share storage and are closely linked via
LAN networking.
 Advantages: high availability, performance
improvement, etc.
 Types
 Asymmetric/symmetric clustering
 Parallel clustering – multiple hosts that
access the same data on the shared
storage.
 Global clusters

 Distributed Lock Manager (DLM)
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

22

Real-Time Systems
 Definition: A real-time system is a
computer system where a timely
response by the computer to external
stimuli is vital!
 Hard real-time system: The system
has failed if a timing constraint, e.g.
deadline, is not met.
 All delays in the system must be
bounded.
 Many advanced features are absent.
23
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Real-Time Systems
 Soft real-time system: Missing a
timing constraint is serious, but does
not necessarily result in a failure
unless it is excessive
 A critical task has a higher priority.
 Supported in most commercial OS.

 Real-time means on-time instead of
fast
24
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Applications for Real-Time Systems!

25
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Real-Time Systems
 Applications
 Virtual reality
 Air traffic control
 Games
 Space shuttle
 User interface
 Navigation
 Vision and speech
 Multimedia systems
 Industrial control systems recognition (approx.
100 ~ 200ms)
 Home appliance
 PDA, telephone
controller
system
 Nuclear power plant
 And more
26
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Handheld Systems
 Handheld Systems
 E.g., Personal Digital Assistant (PDA)

 New Challenges – convenience vs
portability
 Limited Size and Weight
 Small Memory Size
 No Virtual Memory

 Slow Processor
 Battery Power

 Small display screen
 Web-clipping
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

27

Feature Migration
 MULTIplexed Information and
Computing Services (MULTICS)
 1965-1970 at MIT as a utility

 UNIX
 Since 1970 on PDP-11

 Recent OS’s
 MS Windows, IBM OS/2, MacOS X

 OS features being scaled down to fit
PC’s
 Personal Workstations – large PC’s
28
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Computing Environments
 Traditional Computing
 E.g., typical office environment

 Web-Based Computing
 Web Technology
 Portals, network computers, etc.

 Network connectivity
 New categories of devices
 Load balancers

 Embedded Computing
 Car engines, robots, VCR’s, home automation
 Embedded OS’s often have limited features. 29
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Contents
1. Introduction
2. Computer-System Structures
3. Operating-System Structures
4. Processes
5. Threads
6. CPU Scheduling
7. Process Synchronization
8. Deadlocks
9. Memory Management
10. Virtual Memory
11. File Systems
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

30

Chapter 2
Computer-System Structure

31

Computer-System Structure
 Objective: General knowledge of the
structure of a computer system.
tape
drivers

printer
CPU
printer
controller

memory
controller

memory

tape-drive
controller
disk
controller

disks

 Device controllers: synchronize and manage access to devices.
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

32

Booting
 Bootstrap program:
 Initialize all aspects of the system,
e.g., CPU registers, device
controllers, memory, etc.
 Load and run the OS

 Operating system: run init to initialize
system processes, e.g., various
daemons, login processes, after the
kernel has been bootstrapped.
(/etc/rc* & init or /sbin/rc* & init)
33
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Interrupt
 Hardware interrupt, e.g. services
requests of I/O devices
 Software interrupt, e.g. signals,
invalid memory access, division by
zero, system calls, etc – (trap)
process execution

interrupt

handler

return

 Procedures: generic handler or
interrupt vector (MS-DOS,UNIX)
34
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Interrupt Handling Procedure
interrupted process
fixed address
per interrupt
type

system stack

handler

interrupted
address,
registers
......

 Saving of the address of the interrupted
instruction: fixed locations or stacks
 Interrupt disabling or enabling issues: lost
interrupt?!
prioritized interrupts Æ masking
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

35

Interrupt Handling Procedure
 Interrupt Handling
Î Save interrupt information
Î OS determine the interrupt type (by polling)
Î Call the corresponding handlers
Î Return to the interrupted job by the restoring
important information (e.g., saved return addr. Æ
program counter) Interrupt
-------

Vector
indexed by
a unique
device
number

0
1

n
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

-------------

Interrupt Handlers
(Interrupt Service
Routines)

36

I/O Structure
 Device controllers are responsible of moving
data between the peripheral devices and their
local buffer storages.
tape
drivers

printer
CPU

printer
controller
registers buffers

memory
controller

tape-drive
controller
DMA
registers
buffers

memory
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

disk

37

I/O Structure


I/O operation
a. CPU sets up specific controller registers
within the controller.
b. Read: devices Æ controller buffers Æ
memory
Write: memory Æ controller buffers Æ
devices

c. Notify the completion of the operation by
triggering an interrupt
38
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

I/O Types
a. Synchronous I/O


Issues: overlapping of computations and IO
activities, concurrent I/O activities, etc.

I/O system call
wait till the
or • wait instruction (idle till interrupted)
completion
• looping
or • polling
• wait for an interrupt
Loop: jmp Loop
39
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

I/O Types
user

Requesting process

wait

user

Device driver

Device driver

Kernel

Interrupt handler

Hardware
data transfer

Time
Synchronous I/O
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Requesting process

Interrupt handler

Kernel
Hardware
data transfer

Time
Asynchronous I/O

40

I/O types
b. Asynchronous I/O

wait till the
completion
sync

wait mechanisms!!

*efficiency
41
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

I/O Types
 A Device-Status Table Approach
card reader 1
status: idle
line printer 3
status: busy
disk unit 3
status: idle

Request
addr. 38596
len?1372

........

Request
file:xx
Record
Addr. len

process 1

Request
file:yy
Record
Addr. len

process 2

•Tracking of many
I/O requests
•type-ahead service
42
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

DMA


Goal: Release CPU from handling excessive
interrupts!


E.g. 9600-baud terminal
2-microsecond service / 1000 microseconds

High-speed device:
2-microsecond service / 4 microseconds



Procedure





Execute the device driver to set up the
registers of the DMA controller.
DMA moves blocks of data between the
memory and its own buffers.
Transfer from its buffers to its devices.
Interrupt the CPU when the job is done.
43

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Storage Structure
registers

CPU

cache

HW-Managed

Primary Storage
• volatile storage

memory

SW-Managed

Secondary Storage
• nonvolatile storage
Tertiary Storage
• removable media

 Access time: a
cycle
 Access time:
several cycles
 Access time: many
cycles

Magnetic Disks
CD-ROMs/DVDs

* Differences:
Size, Cost,
Speed, Volatility

Jukeboxes
44
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Memory


R1
R2



R3
.
.
.

Device
Controller
Memory



Processor can have direct access!
Intermediate storage for data in the
registers of device controllers
Memory-Mapped I/O (PC & Mac)
(1) Frequently used devices
(2) Devices must be fast, such as video
controller, or special I/O instructions
is used to move data between
memory & device controller
registers

Programmed I/O – polling


or interrupt-driven handling

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

45

Magnetic disks
sector

spindle

r/w
head

track

cylinder

platter

arm
assembly

disk
arm

 Transfer Rate
 RandomAccess Time
 Seek time
in x ms
 Rotational
latency in y
ms
 60~200
times/sec
46

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Magnetic Disks
 Disks
 Fixed-head disks:
 More r/w heads v.s. fast track switching

 Moving-head disks (hard disk)
 Primary concerns:
 Cost, Size, Speed

 Computer Æ host controller Æ disk controller
Æ disk drives (cache ÅÆ disks)

 Floppy disk
 slow rotation, low capacity, low density, but
less expensive

 Tapes: backup or data transfer bet machines
47
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Storage Hierarchy
register
Speed

Cache

High hitting rate
• instruction & data cache
• combined cache

Main Memory
Volatile Storage

Electronic Disk

Faster than magnetic
disk – nonvolatile?!
Alias: RAM Disks

Cost

Magnetic Disk
Optical Disk
Magnetic Tape

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Sequential
Access
48

XX GB/350F

Storage Hierarchy
 Caching
 Information is copied to a faster storage
system on a temporary basis
 Assumption: Data will be used again soon.
 Programmable registers, instr. cache, etc.

 Cache Management
 Cache Size and the Replacement Policy

 Movement of Information Between
Hierarchy
 Hardware Design & Controlling Operating
Systems
49
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Storage Hierarchy
 Coherency and Consistency
 Among several storage levels (vertical)
 Multitasking vs unitasking

 Among units of the same storage level ,
(horizontal), e.g. cache coherency
 Multiprocessor or distributed systems
CPU

Cache
Memory

CPU

cache
Memory

50
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Hardware Protection
 Goal:
 Prevent errors and misuse!
 E.g., input errors of a program in a
simple batch operating system
 E.g., the modifications of data and code
segments of another process or OS

 Dual-Mode Operations – a mode bit
 User-mode executions except those
after a trap or an interrupt occurs.
 Monitor-mode (system mode, privileged
mode, supervisor mode)
 Privileged instruction:machine
instructions that may cause harm
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

51

Hardware Protection
 System Calls – trap to OS for executing
privileged instructions.
 Resources to protect
 I/O devices, Memory, CPU

 I/O Protection (I/O devices are scare
resources!)
 I/O instructions are privileged.
 User programs must issue I/O through
OS
 User programs can never gain control
over the computer in the system mode.
52
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Hardware Protection
 Memory Protection

kernel
job1
job2
……
……

 Goal: Prevent a user program from
modifying the code or data structures
of either the OS or other users!
 Instructions to modify the memory
space for a process are privileged.
Base register
Limit register

Ù Check for every
memory address by
hardware
53

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Hardware Protection
 CPU Protection
 Goal
 Prevent user programs from sucking
up CPU power!

 Use a timer to implement time-sharing
or to compute the current time.
 Instructions that modify timers are
privileged.

 Computer control is turned over to OS
for every time-slice of time!
 Terms: time-sharing, context switch
54
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Network Structure
 Local-Area Network (LAN)
 Characteristics:
 Geographically distributed in a small
area, e.g., an office with different
computers and peripheral devices.
 More reliable and better speed
 High-quality cables, e.g., twisted pair
cables for 10BaseT Ethernet or fiber optic
cables for 100BaseT Ethernet

 Started in 1970s
 Configurations: multiaccess bus, ring,
star networks (with gateways)
55
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Network Structure
 Wide-Area Network (WAN)
 Emerged in late 1960s (Arpanet in
1968)

 World Wide Web (WWW)
 Utilize TCP/IP over
ARPANET/Internet.
• Definition of “Intranet”: roughly speaking for any network under
one authorization, e.g., a company or a school.
• Often in a Local Area Network (LAN), or connected LAN’s.
• Having one (or several) gateway with the outside world.
• In general, it has a higher bandwidth because of a LAN.
56
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Network Structure – WAN
HINET
HINET
TARNET
TARNET

gateway
Intranet
Intranet

Intranet
Intranet
AAIntranet
Intranet
Intranet
AAIntranet

gateway
router
Intranet
Intranet
57

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Network Structure – WAN
 Router
 With a Routing table
 Use some routing protocol, e.g., to maintain
network topology by broadcasting.

 Connecting several subnets (of the same IP-orhigher-layer protocols) for forwarding packets to
proper subnets.

 Gateway
 Functionality containing that of routers.
 Connecting several subnets (of different or the
same networks, e.g., Bitnet and Internet)for
forwarding packets to proper subnets.
58
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Network Structure – WAN
 Connections between networks
 T1: 1.544 mbps, T3: 45mbps
(28T1)
 Telephone-system services over
T1

 Modems
 Conversion of the analog signal
and digital signal

59
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Network Layers in Linux
applications

Applications
Kernel

BSD sockets
INET sockets
UDP

TCP

Internet Protocol (IP)

Network Layer

PPP
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

SLIP

Ethernet

ARP

60

TCP/IP
 IP Address:
 140.123.101.1
 256*256*256*256 combinations
 140.123 -> Network Address
 101.1 -> Host Address

 Subnet:
 140.123.101 and 140.123.102

 Mapping of IP addresses and host names
 Static assignments: /etc/hosts
 Dynamic acquisition: DNS (Domain Name Server)
 /etc/resolv.confg

 If /etc/hosts is out-of-date, re-check it up with DNS!

 Domain name: cs.ccu.edu.tw as a domain name for
140.123.100, 140.123. 101, and 140.123.103
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

61

TCP/IP
 Transmission Control Protocol (TCP)
 Reliable point-to-point packet
transmissions.
 Applications which communicate over
TCP/IP with each another must provide IP
addresses and port numbers.
 /etc/services
 Port# 80 for a web server.

 User Datagram Protocol (UDP)
 Unreliable point-to-point services.

 Both are over IP.
62
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

TCP/IP
 Mapping of Ethernet physical addresses
and IP addresses
 Each Ethernet card has a built-in Ethernet
physical address, e.g., 08-01-2b-00-50-A6.
 Ethernet cards only recognize frames with
their physical addresses.
 Linux uses ARP (Address Resolution
Protocol) to know and maintain the mapping.
 Broadcast requests over Ethernet for IP
address resolution over ARP.
 Machines with the indicated IP addresses
reply with their Ethernet physical addresses.
63
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

TCP/IP
A TCP packet

An IP packet

An Ethernet Ethernet header
frame

TCP header + Data

IP header

Data

Data

• Each IP packet has an indicator of which protocol used, e.g., TCP or UDP
64
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Contents
1. Introduction
2. Computer-System Structures
3. Operating-System Structures
4. Processes
5. Threads
6. CPU Scheduling
7. Process Synchronization
8. Deadlocks
9. Memory Management
10. Virtual Memory
11. File Systems
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

65

Chapter 3
Operating-System
Structures

66

Operating-System Structures
 Goals: Provide a way to understand
an operating systems
 Services
 Interface
 System Components

 The type of system desired is the
basis for choices among various
algorithms and strategies!
67
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

System Components –
Process Management
 Process Management
 Process: An Active Entity
 Physical and Logical Resources
 Memory, I/O buffers, data, etc.

Program
(code)

 Data Structures Representing Current
Activities:
+ Program Counter
Stack
Data Section
CPU Registers
….
And More
68

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

System Components –
Process Management
 Services






Process creation and deletion
Process suspension and resumption
Process synchronization
Process communication
Deadlock handling

69
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

System Components – MainMemory Management
 Memory: a large array of words or bytes,
where each has its own address
 OS must keep several programs in
memory to improve CPU utilization and
user response time
 Management algorithms depend on the
hardware support
 Services
 Memory usage and availability
 Decision of memory assignment
 Memory allocation and deallocation
70
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

System Components – File
Management
 Goal:
 A uniform logical view of information
storage
 Each medium controlled by a device
 Magnetic tapes, magnetic disks, optical
disks, etc.

 OS provides a logical storage unit: File
 Formats:
 Free form or being formatted rigidly.

 General Views:
 A sequence of bits, bytes, lines, records

71

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

System Components – File
Management
 Services
 File creation and deletion
 Directory creation and deletion
 Primitives for file and directory
manipulation
 Mapping of files onto secondary
storage
 File Backup
* Privileges for file access control
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

72

System Components – I/O
System Management
 Goal:
 Hide the peculiarities of specific
hardware devices from users

 Components of an I/O System
 A buffering, caching, and spooling
system
 A general device-driver interface
 Drivers
73
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

System Components –
Secondary-Storage Management
 Goal:
 On-line storage medium for
programs & data
 Backup of main memory

 Services for Disk Management
 Free-space management
 Storage allocation, e.g., continuous
allocation
 Disk scheduling, e.g., FCFS
74
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

System Components –
Networking
 Issues
 Resources sharing
 Routing & connection strategies
 Contention and security

 Network access is usually
generalized as a form of file access
 World-Wide-Web over file-transfer
protocol (ftp), network file-system
(NFS), and hypertext transfer protocol
(http)
75
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

System Components –
Protection System
 Goal
 Resources are only allowed to
accessed by authorized processes.

 Protected Resources
 Files, CPU, memory space, etc.

 Services
 Detection & controlling mechanisms
 Specification mechanisms

 Remark: Reliability!
76
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

System Components –
Command-Interpreter system
 Command Interpreter
 Interface between the user and the
operating system
 Friendly interfaces
 Command-line-based interfaces or
mused-based window-and-menu
interface

 e.g., UNIX shell and command.com in
MS-DOS
User-friendly?

Get the next command
Execute the command
77

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Operation-System Services
 Program Execution
 Loading, running, terminating, etc

 I/O Operations
 General/special operations for devices:
 Efficiency & protection

 File-System Manipulation
 Read, write, create, delete, etc

 Communications
 Intra-processor or inter-processor
communication – shared memory or
message passing
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

78

Operation-System Services
 Error Detection
 Possible errors from CPU, memory,
devices, user programs Æ Ensure
correct & consistent computing

 Resource Allocation
 Utilization & efficiency

 Accounting
 Protection & Security
• user convenience or system efficiency!
79
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Operation-System Services
 System calls
 Interface between processes & OS

 How to make system calls?
 Assemble-language instructions or
subroutine/functions calls in high-level
language such as C or Perl?
 Generation of in-line instructions or a
call to a special run-time routine.

 Example: read and copy of a file!
 Library Calls vs System Calls
80
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Operation-System Services
 How a system call
occurs?

x
register

 Types and
information

x: parameters
for call
load address x
system call 13

use parameters
from table x

Code for
System
Call 13

 Parameter Passing
 Registers
 Registers pointing to
blocks
 Linux

 Stacks
81
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Operation-System Services
 System Calls






Process Control
File Management
Device Management
Information Maintenance
Communications

82
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Operation-System Services
 Process & Job Control
 End (normal exit) or abort (abnormal)
 Error level or no

 Load and execute
 How to return control?
 e.g., shell load & execute commands

 Creation and/or termination of
processes
 Multiprogramming?
83
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Operation-System Services
 Process & Job Control (continued)
 Process Control
 Get or set attributes of processes

 Wait for a specified amount of time
or an event
 Signal event

 Memory dumping, profiling, tracing,
memory allocation & de-allocation

84
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Operation-System Services
 Examples: MS-DOS & UNIX
free memory

process A

process

interpreter
free memory

command
interpreter

process B

kernel

kernel
85

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Operation-System Services
 File Management
 Create and delete
 Open and close
 Read, write, and reposition (e.g.,
rewinding)
 lseek

 Get or set attributes of files
 Operations for directories
86
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Operation-System Services
 Device management
 Request or release
 Open and close of special files
 Files are abstract or virtual devices.

 Read, write, and reposition (e.g.,
rewinding)
 Get or set file attributes
 Logically attach or detach devices
87
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Operation-System Services
 Information maintenance
 Get or set date or time
 Get or set system data, such as the amount
of free memory

 Communication
 Message Passing
 Open, close, accept connections
 Host ID or process ID

 Send and receive messages
 Transfer status information

 Shared Memory
 Memory mapping & process synchronization88
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Operation-System Services
 Shared Memory
 Max Speed & Comm Convenience

 Message Passing
 No Access Conflict & Easy Implementation
Process A M

Process A
Shared Memory

Process B M

kernel

M

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Process B

kernel

89

System Programs
 Goal:
 Provide a convenient environment for
program development and execution

 Types





File Management, e.g., rm.
Status information, e.g., date.
File Modifications, e.g., editors.
Program Loading and Executions, e.g.,
loader.
 Programming Language Supports, e.g.,
compilers.
 Communications, e.g., telnet.
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

90

System Programs –
Command Interpreter
 Two approaches:
 Contain codes to execute commands
 Fast but the interpreter tends to be
big!
 Painful in revision!

del

cd

91
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

System Programs –
Command Interpreter


Implement commands as system
programs Æ Search exec files
which corresponds to commands
(UNIX)

 Issues
a. Parameter Passing
 Potential Hazard: virtual memory

b. Being Slow
c. Inconsistent Interpretation of
Parameters
92
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

System Structure – MS-DOS
 MS-DOS Layer Structure
Application program
Resident system program
MS-DOS device drivers
ROM BIOS device drivers
93
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

System Structure – UNIX
User
interface
System call
interface

useruser user
user
user
user
user
Shells, compilers, X, application programs, etc.
CPU scheduling, signal handling,
virtual memory, paging, swapping,
file system, disk drivers, caching/buffering, etc.

Kernel interface
to the hardware

terminal controller, terminals,
physical memory, device controller,
devices such as disks, memory, etc.

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

UNIX

94

System Structure
 A Layered Approach – A Myth
new
ops

Layer M
hidden
ops

Layer M-1

existing
ops

Advantage: Modularity ~ Debugging &
Verification
Difficulty: Appropriate layer definitions, less
efficiency due to overheads！
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

95

System Structure
 A Layer Definition Example:
L5
L4
L3
L2
L1
L0

User programs
I/O buffering
Operator-console device driver
Memory management
CPU scheduling
Hardware
96

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

System Structure – OS/2
 OS/2 Layer Structure
Application

Application

Application

Application-program Interface
Subsystem

Subsystem

System kernel

Subsystem

‧memory management
‧task scheduling
‧device management

Device driver Device driver Device driver
* Some layers of NT were from user space to kernel space in NT4.0
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

97

System Structure –
Microkernels
 The concept of microkernels was
proposed in CMU in mid 1980s (Mach).
 Moving all nonessential components
from the kernel to the user or system
programs!
 No consensus on services in kernel
 Mostly on process and memory
management and communication

 Benefits:
 Ease of OS service extensions Æ
portability, reliability, security
98
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

System Structure –
Microkernels
 Examples
 Microkernels: True64UNIX (Mach
kernel), MacOS X (Mach kernel),
QNX (msg passing, proc scheduling,
HW interrupts, low-level networking)
 Hybrid structures: Windows NT
Win32
Applications

Win32
Server

OS/2
Applications

OS/2
Server

kernel
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

POSIX
Applications

POSIX
Server

99

Virtual Machine
 Virtual Machines: provide an interface that is
identical to the underlying bare hardware
processes

interface
kernel

hardware

processes

processes

processes

kernel

kernel

kernel

VM1

VM2

VM3

virtual machine implementation
hardware
100

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Virtual Machine
 Implementation Issues:
 Emulation of Physical Devices
 E.g., Disk Systems
 An IBM minidisk approach

 User/Monitor Modes
 (Physical) Monitor Mode
 Virtual machine software

 (Physical) User Mode
 Virtual monitor mode & Virtual user
mode
101
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Virtual Machine
virtual
user
mode

P1/VM1 system call
processes processes processes

Trap

virtual
monitor kernel 1 kernel 2 kernel 3
mode
monitor
mode

Finish
service

Service for the system call
Restart VM1

virtual machine software

Set program counter
& register contents,
& then restart VM1

hardware

Simulate the
effect of the I/O
instruction

time
102
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Virtual Machine
 Disadvantages:
 Slow!
 Execute most instructions directly on the
hardware

 No direct sharing of resources
 Physical devices and
communications
* I/O could be slow (interpreted) or fast (spooling)
103
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Virtual Machine
 Advantages:
 Complete Protection – Complete
Isolation！
 OS Research & Development
 System Development Time

 Extensions to Multiple Personalities, such
as Mach (software emulation)
 Emulations of Machines and OS’s, e.g.,
Windows over Linux

104
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Virtual Machine – Java
java .class files

class loader
verifier
java interpreter

 Sun Microsystems in late 1995
 Java Language and API Library
 Java Virtual Machine (JVM)

 Class loader (for
bytecode .class files)
 Class verifier
 Java interpreter

host system

 An interpreter, a just-in-time (JIT)
compiler, hardware
105

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Virtual Machine – Java
java .class files

 JVM
 Garbage collection
 Reclaim unused objects

class loader
verifier
java interpreter

 Implementation being specific for
different systems
 Programs are architecture neutral
and portable

host system
106
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

System Design &
Implementation
 Design Goals & Specifications:
 User Goals, e.g., ease of use
 System Goals, e.g., reliable

 Rule 1: Separation of Policy & Mechanism
 Policy：What will be done?
 Mechanism：How to do things?
 Example: timer construct and time slice

 Two extreme cases:
Microkernel-based OS
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Macintosh OS

107

System Design &
Implementation
 OS Implementation in High-Level
Languages
 E.g., UNIX, OS/2, MS NT, etc.
 Advantages:
 Being easy to understand & debug
 Being written fast, more compact,
and portable

 Disadvantages:
 Less efficient but more storage for
code
* Tracing for bottleneck identification, exploring of excellent algorithms, 108
etc.

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

System Generation
 SYSGEN (System Generation)
 Ask and probe for information concerning the
specific configuration of a hardware system
 CPU, memory, device, OS options, etc.

No recompilation
& completely
Linking of
table-driven
modules for
selected OS

Recompilation
of a modified
source code

 Issues
 Size, Generality, Ease of modification
109
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Contents
1. Introduction
2. Computer-System Structures
3. Operating-System Structures
4. Processes
5. Threads
6. CPU Scheduling
7. Process Synchronization
8. Deadlocks
9. Memory Management
10. Virtual Memory
11. File Systems
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

110

Chapter 4 Processes

111

Processes
 Objective:
 Process Concept & Definitions

 Process Classification:
 Operating system processes
executing system code
 User processes executing system
code
 User processes executing user code
112
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Processes
 Example: Special Processes in Unix
 PID 0 – Swapper (i.e., the scheduler)
 Kernel process
 No program on disks correspond to this
process

 PID 1 – init responsible for bringing up a Unix
system after the kernel has been
bootstrapped. (/etc/rc* & init or /sbin/rc* & init)
 User process with superuser privileges

 PID 2 - pagedaemon responsible for paging
 Kernel process
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

113

Processes
 Process
 A Basic Unit of Work from the Viewpoint of
OS
 Types:
 Sequential processes: an activity resulted from
the execution of a program by a processor
 Multi-thread processes

 An Active Entity
 Program Code – A Passive Entity
 Stack and Data Segments

 The Current Activity
 PC, Registers , Contents in the Stack and Data
Segments
114
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Processes
 Process State
new

terminated
admitted

ready
I/O or event completion

waiting

interrupt
scheduled

exit

running

I/O or event wait
115

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Processes
 Process Control Block (PCB)








Process State
Program Counter
CPU Registers
CPU Scheduling Information
Memory Management Information
Accounting Information
I/O Status Information
116

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Processes
 PCB: The repository for any information
that may vary from process to process
PCB[]
0
1
2

pointer
process state
pc
register

NPROC-1
117
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Processes
 Process Control Block (PCB) – An Unix
Example
 proc[i]
 Everything the system must know when the
process is swapped out.
 pid, priority, state, timer counters, etc.

 .u
 Things the system should know when process
is running
 signal disposition, statistics accounting, files[], etc.
118
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Processes
per-process
kernel stack

 Example: 4.3BSD

.u
argv, argc,…
user stack

text
structure
x_caddr

proc[i]
entry

p_p0br

sp

heap
Data Segment

p_textp
p_addr

Red
Zone

page
table

Code Segment

PC

u_proc
119
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Processes
 Example: 4.4BSD

per-process
kernel stack

.u
argv, argc,…
user stack

process grp

…
file descriptors

proc[i]
entry

region lists

VM space
p_addr

p_p0br

page
table

Code Segment
u_proc

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

heap
Data Segment

120

Process Scheduling
 The goal of multiprogramming
 Maximize CPU/resource utilization!

 The goal of time sharing
 Allow each user to interact with his/her program!
PCB1
ready
queue

head
tail

disk
unit 0

head
tail

tape
unit 1

head
tail

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

PCB2

PCB3

121

Process Scheduling – A
Queueing Diagram
ready queue
I/O

dispatch

I/O queue

CPU
I/O request
time slice expired

child terminate

child executes
interrupt occurs

fork a child
wait for an interrupt
122

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Process Scheduling –
Schedulers
 Long-Term (/Job) Scheduler
CPU

Job pool
Memory

 Goal: Select a good mix of I/O-bound and
CPU-bound process

 Remarks：
1. Control the degree of multiprogramming
2. Can take more time in selecting processes
because of a longer interval between executions
3. May not exist physically
123
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Process Scheduling –
Schedulers
 Short-Term (/CPU) Scheduler
 Goal：Efficiently allocate the CPU to
one of the ready processes
according to some criteria.

 Mid-Term Scheduler
 Swap processes in and out memory to
control the degree of multiprogramming

124
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Process Scheduling –
Context Switches
 Context Switch ~ Pure Overheads
 Save the state of the old process and load the
state of the newly scheduled process.
 The context of a process is usually reflected in
PCB and others, e.g., .u in Unix.

 Issues：
 The cost depends on hardware support
 e.g. processes with multiple register sets or
computers with advanced memory management.

 Threads, i.e., light-weight process (LWP), are

introduced to break this bottleneck！
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

125

Operations on Processes
 Process Creation & Termination
 Restrictions on resource usage
 Passing of Information
 Concurrent execution
root
pagedaemon

swapper
user1

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

init
user2

user3

126

Operations on Processes
 Process Duplication
 A copy of parent address space +
context is made for child, except the
returned value from fork()：
 Child returns with a value 0
 Parent returns with process id of child

 No shared data structures between
parent and child – Communicate via
shared files, pipes, etc.
 Use execve() to load a new program
 fork() vs vfork() (Unix)
127
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Operations on Processes
 Example:
…
if ( pid = fork() ) == 0) {
/* child process */
execlp(“/bin/ls”, “ls”, NULL);
} else if (pid < 0) {
fprintf(stderr, “Fork Failed”);
exit(-1);
} else {
/* parent process */
wait(NULL);
}
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

128

Operations on Processes
 Termination of Child Processes
 Reasons:
 Resource usages, needs, etc.

 Kill, exit, wait, abort, signal, etc.
 Cascading Termination

129
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Cooperating Processes
 Cooperating processes can affect or
be affected by the other processes
 Independent Processes

 Reasons:
 Information Sharing, e.g., files
 Computation Speedup, e.g.,
parallelism.
 Modularity, e.g., functionality dividing
 Convenience, e.g., multiple work
130
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Cooperating Processes
 A Consumer-Producer Example:
 Bounded buffer or unbounded buffer
 Supported by inter-process
communication (IPC) or by hand coding
2
1
buffer[0…n-1]
0
Initially,
n-1
in
z
out
in=out=0；
n-2
131
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Cooperating Processes
Producer:
while (1) {
/* produce an item nextp */
while (((in+1) % BUFFER_SIZE) == out)
; /* do nothing */
buffer[ in ] = nextp;
in = (in+1) % BUFFER_SIZE;
}

132
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Cooperating Processes
Consumer:
while (1) {

while (in == out)
; /* do nothing */
nextc = buffer[ out ];
out = (out+1) % BUFFER_SIZE ;
/* consume the item in nextc */
}

133
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Interprocess Communication
 Why Inter-Process Communication
(IPC)?
 Exchanging of Data and Control
Information!

 Why Process Synchronization?
 Protect critical sections!
 Ensure the order of executions!
134
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Interprocess Communication
 IPC
 Shared Memory
 Message Passing

 Logical Implementation of Message
Passing
 Fixed/variable msg size,
symmetric/asymmetric communication,
direct/indirect communication,
automatic/explicit buffering, send by
copy or reference, etc.
135
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Interprocess Communication
 Classification of Communication by
Naming
 Processes must have a way to refer
to each other!

 Types
 Direct Communication
 Indirect Communication

136
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Interprocess Communication –
Direct Communication
 Process must explicitly name the
recipient or sender of a communication
 Send(P, msg), Receive(Q, msg)

 Properties of a Link:
a. Communication links are established
automatically.
b. Two processes per a link
c. One link per pair of processes
d. Bidirectional or unidirectional
137
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Interprocess Communication –
Direct Communication
 Issue in Addressing:
 Symmetric or asymmetric addressing

Send(P, msg), Receive(id, msg)
 Difficulty:
 Process naming vs modularity

138
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Interprocess Communication –
Indirect Communication
 Two processes can communicate only
if the process share a mailbox (or ports)
send(A, msg)=>

AA

=>receive(A, msg)

 Properties:
1. A link is established between a pair of
processes only if they share a mailbox.
2. n processes per link for n >= 1.
3. n links can exist for a pair of processes for
n >=1.
139
4. Bidirectional or unidirectional
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Interprocess Communication –
Indirect Communication


Issues:
a. Who is the recipient of a message?
P1

P2
msgs

?

P3

b. Owners vs Users
 Process Æ owner as the sole recipient?
 OS Æ Let the creator be the owner?
Privileges can be passed?
Garbage collection is needed?
140
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Interprocess Communication –
Synchronization
 Blocking or Nonblocking
(Synchronous versus Asynchronous)





Blocking send
Nonblocking send
Blocking receive
Nonblocking receive

 Rendezvous – blocking send &
receive
141
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Interprocess Communication –
Buffering


The Capacity of a Link = the # of messages
could be held in the link.


Zero capacity(no buffering)




Bounded capacity




Sender can continue execution without waiting till the
link is full

Unbounded capacity




Msg transfer must be synchronized – rendezvous!

Sender is never delayed!

The last two items are for asynchronous
communication and may need acknowledgement
142

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Interprocess Communication –
Buffering


Special cases:
a. Msgs may be lost if the receiver
can not catch up with msg sending
Æ synchronization
b. Senders are blocked until the
receivers have received msgs and
replied by reply msgs
Æ A Remote Procedure Call (RPC)
framework
143

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Interprocess Communication –
Exception Conditions


Process termination
a. Sender TerminationÆ Notify or
terminate the receiver!
b. Receiver Termination
a. No capacity Æ sender is blocked.
b. BufferingÆ messages are
accumulated.

144
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Interprocess Communication –
Exception Conditions


Ways to Recover Lost Messages (due to
hardware or network failure):






OS detects & resends messages.
Sender detects & resends messages.
OS detects & notify the sender to handle it.

Issues:
a. Detecting methods, such as timeout!
b. Distinguish multiple copies if retransmitting is
possible



Scrambled Messages:


Usually OS adds checksums, such as CRC, inside
messages & resend them as necessary!
145

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Example - Mach
 Mach – A message-based OS from
the Carnegie Mellon University
 When a task is created, two special
mailboxes, called ports, are also
created.
 The Kernel mailbox is used by the
kernel to communication with the
tasks
 The Notify mailbox is used by the
kernel sends notification of event
occurrences.
146
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Example - Mach


Three system calls for message
transfer:


msg_send:

a.
b.
c.
d.

Options when mailbox is full:
Wait indefinitely
Return immediately
Wait at most for n ms
Temporarily cache a message.
a. A cached message per sending thread
for a mailbox

* One task can either own or receive from a mailbox.
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

147

Example - Mach
 msg_receive


To receive from a mailbox or a set of
mailboxes. Only one task can own &
have a receiving privilege of it
* options when mailbox is empty:
a. Wait indefinitely
b. Return immediately
c. Wait at most for n ms



msg_rpc


Remote Procedure Calls
148

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Example - Mach
 port_allocate
 create a mailbox (owner)
 port_status ~ .e.g, # of msgs in a link
 All messages have the same priority and are
served in a FIFO fashion.
 Message Size
 A fixed-length head + a variable-length
data + two mailbox names
 Message copying: message copying Æ
remapping of addressing space
 System calls are carried out by messages.
149
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Example – Windows 2000


Local Procedure Call (LPC) – Message
Passing on the Same Processor
1. The client opens a handle to a
subsystem’s connection port object.
2. The client sends a connection request.
3. The server creates two private
communication ports, and returns the
handle to one of them to the client.
4. The client and server use the
corresponding port handle to send
messages or callbacks and to listen for
replies.
150

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Example – Windows 2000
 Three Types of Message Passing
Techniques
 Small messages
 Message copying

 Large messages – section object
 To avoid memory copy
 Sending and receiving of the pointer
and size information of the object

 A callback mechanism
 When a response could not be
made immediately.
151
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Communication in ClientServer Systems
 Socket
 An endpoint for communication
identified by an IP address
concatenated with a port number
Host X

 A client-server architecture

Socket
Socket

146.86.5.2:1652
146.86.5.2:1652

Web server
Socket
Socket

161.25.19.8:80
161.25.19.8:80
152
* /etc/services: Port # under 1024 ~ 23-telnet, 21-ftp, 80-web server, etc.

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Communication in ClientServer Systems
 Three types of sockets in Java

Server

 Connection-oriented (TCP) – Socket class
 Connectionless (UDP) – DatagramSocket class
 MulticastSocket class – DatagramSocket subclass

sock = new ServerSocket(5155);
…
client = sock.accept();
pout = new PrintWriter(client.getOutputStream(),
true);
…
Pout.println(new java.util.Date().toString());
pout.close();
client.close();

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Client
sock = new Socket(“127.0.0.1”,5155);
…
in = sock.getInputStream();
bin = new BufferReader(new
InputStreamReader(in));
…
sock.close();
153

Communication in ClientServer Systems
 Remote Procedure Call (RPC)
 A way to abstract the procedure-call
mechanism for use between systems with
network connection.
 Needs:
 Ports to listen from the RPC daemon site
and to return results, identifiers of functions
to call, parameters to pack, etc.
 Stubs at the client site
 One for each RPC
 Locate the proper port and marshall parameters.
154
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Communication in ClientServer Systems
 Needs (continued)
 Stubs at the server site
 Receive the message
 Invoke the procedure and return the results.

 Issues for RPC
 Data representation
 External Data Representation (XDR)
 Parameter marshalling

 Semantics of a call
 History of all messages processed

 Binding of the client and server port
 Matchmaker – a rendezvous mechanism
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

155

Communication in ClientServer Systems
Client
Call kernel
to send RPC
msg to
Procedure X

Messages
Kernel sends
msg to
matchmaker

Port: matchaker
Re: addr. to X

Server
Matchmaker
receives msg

Kernel places
port P in usr
RPC msg

Port: kernel
Re: port P to X

Matchmaker
replies to client
with port P

Kernel sends
RPC

Port: P
<contents>

Daemon listens
to port P and
receives msg

Port: kernel
<output>

Daemon processes
request and sends
output

Kernel receives
reply and passes
to user
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

156

Communication in ClientServer Systems
 An Example for RPC
 A Distributed File System (DFS)
 A set of RPC daemons and clients
 DFS port on a server on which a file
operation is to take place:
 Disk operations: read, write,
delete, status, etc –
corresponding to usual system
calls
157
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Communication in ClientServer Systems
 Remote Method Invocation (RMI)
 Allow a thread to invoke a method on a
remote object.
 boolean val = Server.someMethod(A,B)

 Implementation
 Stub – a proxy for the remote object
 Parcel – a method name and its
marshalled parameters, etc.

 Skeleton – for the unmarshalling of
parameters and invocation of the method
and the sending of a parcel back
158
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Communication in ClientServer Systems
 Parameter Passing
 Local (or Nonremote) Objects
 Pass-by-copy – an object
serialization

 Remote Objects – Reside on a
different Java virtual machine (JVM)
 Pass-by-reference

 Implementation of the interface –
java.io.Serializable
159
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Contents
1. Introduction
2. Computer-System Structures
3. Operating-System Structures
4. Processes
5. Threads
6. CPU Scheduling
7. Process Synchronization
8. Deadlocks
9. Memory Management
10. Virtual Memory
11. File Systems
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

160

Chapter 5 Threads

161

Threads
 Objectives:
 Concepts and issues associated with
multithreaded computer systems.

 Thread – Lightweight process(LWP)
 a basic unit of CPU utilization
 A thread ID, program counter, a
register set, and a stack space

 Process – heavyweight process
 A single thread of control
162
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Threads
code segment

 Motivation
 A web browser
 Data retrieval
 Text/image displaying

 A word processor
stack stack stack
registers

registers

registers

data segment
filesfiles

 Displaying
 Keystroke reading
 Spelling and grammar
checking

 A web server
 Clients’ services
 Request listening
163

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Threads
 Benefits
 Responsiveness
 Resource Sharing
 Economy
 Creation and context switching
 30 times slower in process creation
in Solaris 2
 5 times slower in process context
switching in Solaris 2

 Utilization of Multiprocessor
Architectures
164
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

User-Level Threads
 User-level threads
are implemented by
a thread library at
the user level.
 Examples:
 Advantages

 POSIX Pthreads,
Mach C-threads,
Solaris 2 UI-threads

 Context switching among them is extremely fast

 Disadvantages
 Blocking of a thread in executing a system call can block the
entire process.
165
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Kernel-Level Threads
 Kernel-level threads
are provided a set of
system calls similar to
those of processes
 Examples
 Windows 2000, Solaris
 Advantage

2, True64UNIX

 Blocking of a thread will not block its entire task.

 Disadvantage
 Context switching cost is a little bit higher because
the kernel must do the switching.
166
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Multithreading Models
 Many-to-One Model
 Many user-level threads to one
kernel thread
 Advantage:
k

 Efficiency

 Disadvantage:
 One blocking system call blocks all.
 No parallelism for multiple processors

 Example: Green threads for Solaris 2
167
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Multithreading Models
 One-to-One Model

k

 One user-level thread to one kernel
thread
 Advantage: One system call blocks
one thread.
 Disadvantage: Overheads in creating
a kernel thread.
 Example: Windows NT, Windows
2000, OS/2
168

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Multithreading Models
 Many-to-Many Model
 Many user-level threads to many
kernel threads
 Advantage:
k k k

 A combination of parallelism and
efficiency

 Example: Solaris 2, IRIX, HPUX,Tru64 UNIX

169
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Threading Issues
 Fork and Exec System Calls
 Fork: Duplicate all threads or create
a duplicate with one thread?
 Exec: Replace the entire process,
including all threads and LWPs.
 Fork Æ exec?

170
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Threading Issues
 Thread Cancellation
 Target thread
 Two scenarios:
 Asynchronous cancellation
 Deferred cancellation
 Cancellation points in Pthread.

 Difficulty
 Resources have been allocated to a
cancelled thread.
 A thread is cancelled while it is updating
data.
171
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Threading Issues
 Signal Handling
 Signal
 Synchronous – delivered to the same
process that performed the operation
causing the signal,
 e.g., illegal memory access or division by
zero

 Asynchronous
 e.g., ^C or timer expiration

 Default or user-defined signal handler
 Signal masking
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

172

Threading Issues
 Delivery of a Signal
 To the thread to which the signal applies
 e.g., division-by-zero

 To every thread in the process
 e.g., ^C

 To certain threads in the process
 Assign a specific thread to receive all
threads for the process
 Solaris 2

 Asynchronous Procedure Calls (APCs)
 To a particular thread rather than a process
173
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Threading Issues
 Thread Pools
 Motivations
 Dynamic creation of threads
 Limit on the number of active threads

 Awake and pass a request to a thread in
the pool
 Benefits
 Faster for service delivery and limit on the
# of threads

 Dynamic or static thread pools
174
 Thread-specific data – Win32 & Pthreads
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Pthreads
 Pthreads (IEEE 1003.1c)
 API Specification for Thread Creation
and Synchronization
 UNIX-Based Systems, Such As
Solaris 2.

 User-Level Library
 Header File: <pthread.h>
 pthread_attr_init(), pthread_create(),
pthread_exit(), pthread_join(), etc.
175
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Pthreads
#include <pthread.h>
main(int argc, char *argv[]) {
…
pthread_attr_init(&attr);
pthread_create(&tid, &attr, runner, argv[1]);
pthread_join(tid, NULL);
…}
void *runner(void *param) {
int i, upper = atoi(param), sum = 0;
if (upper > 0)
for(i=1;i<=upper,i++)
sum+=i;
pthread_exit(0);
}
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

176

Solaris 2

kernel

 Implementation
user-level
of Pthread API
thread
in addition to
light weight
supporting
process
user-level
kernel threads
threads with a
library for
thread creation
and
CPU
management.
177

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Solaris 2
 Many-to-Many Model
 Each process has at least one LWP
 Each LWP has a kernel-level thread

 User-level threads must be connected
to LWPs to accomplish work.
 A bound user-level thread
 An unbound thread

 Some kernel threads running on the
kernel’s behalf have no associated
LWPs – system threads
178
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Solaris 2
 Processor Allocation:
 Multiprogramming or Pinned

 Switches of user-level threads
among LWPs do not need kernel
intervention.
 If the kernel thread is blocked, so
does the LWP and its user-level
threads.
 Dynamic adjustment of the number
of LWPs
179
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Solaris 2
Process ID
Mem Map
Priority
Open Files

 Data Structures
 A User-Level Thread
 A Thread ID, a register set (including
PC, SP), stack, and priority – in user
space

 A LWP
 A Register set for the running userlevel thread – in kernel space

LWP1
LWP2

Solaris 2 Process

 A Kernel thread
 A copy of the kernel registers, a
pointer to its LWP, priority, scheduling
information

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

180

Windows 2000
 Win32 API
 One-to-One Model
 Fiber Library for the M:M Model

 A Thread Contains
 A Thread ID
 Context: A Register Set, A User
Stack, A Kernel Stack, and A Private
Storage Space
181
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Windows 2000
 Data Structures
 ETHREAD (executive thread block)
Kernel
Space

 A ptr to the process,a ptr to KTHREAD,
the address of the starting routine

 KTHREAD (kernel thread block)
 Scheduling and synchronization
information, a kernel stack, a ptr to TEB

User
Space

 TEB (thread environment block)
 A user stack, an array for threadspecific data.
182

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Linux
 Threads introduced in Version 2.2
 clone() versus fork()
 Term task for process& thread
 Several per-process data structures,
e.g., pointers to the same data
structures for open files, signal
handling, virtual memory, etc.
 Flag setting in clone() invocation.

 Pthread implementations
183
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Java
 Thread Support at the Language Level
 Mapping of Java Threads to Kernel
Threads on the Underlying OS?
 Windows 2000: 1:1 Model

 Thread Creation
 Create a new class derived from the
Thread class
 Run its start method
 Allocate memory and initialize a new
thread in the JVM
 start() calls the run method, making the
thread eligible to be run by the JVM.
184
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Java
class Summation extends Thread
{ public Summation(int n) {
upper = n; }
public void run() {
int sum = 0;
…}
…}
public class ThreadTester
{…
Summation thrd = new
Summation(Integer.ParseInt(args[0]));
thrd.start();
…}
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

185

Contents
1. Introduction
2. Computer-System Structures
3. Operating-System Structures
4. Processes
5. Threads
6. CPU Scheduling
7. Process Synchronization
8. Deadlocks
9. Memory Management
10. Virtual Memory
11. File Systems
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

186

Chapter 6 CPU Scheduling

187

CPU Scheduling
 Objective:
 Basic Scheduling Concepts
 CPU Scheduling Algorithms

 Why Multiprogramming?
 Maximize CPU/Resources Utilization
(Based on Some Criteria)

188
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

CPU Scheduling
 Process Execution
 CPU-bound programs tend to have a
few very long CPU bursts.
 IO-bound programs tend to have
many very short CPU bursts.
CPU-Burst
New
Terminate
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

I/O-Burst
189

CPU Scheduling
 The distribution can help in selecting
an appropriate CPU-scheduling
algorithms
frequency

120
100
60
20
8

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

24
16
Burst Duration (ms)

190

CPU Scheduling
 CPU Scheduler – The Selection of
Process for Execution
 A short-term scheduler
New

Terminated
dispatched

Ready

Running
Waiting
191

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

CPU Scheduling
 Nonpreemptive Scheduling
 A running process keeps CPU until it
volunteers to release CPU
 E.g., I/O or termination

 Advantage
 Easy to implement (at the cost of service
response to other processes)

 E.g., Windows 3.1

192
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

CPU Scheduling
 Preemptive Scheduling
 Beside the instances for non-preemptive
scheduling, CPU scheduling occurs
whenever some process becomes
ready or the running process leaves the
running state!

 Issues involved:
 Protection of Resources, such as I/O
queues or shared data, especially for
multiprocessor or real-time systems.
 Synchronization
 E.g., Interrupts and System calls
193
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

CPU Scheduling
 Dispatcher
 Functionality:
 Switching context
 Switching to user mode
 Restarting a user program

 Dispatch Latency:
Stop a process

Must be fast
Start a process
194

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Scheduling Criteria
 Why?
 Different scheduling algorithms may
favor one class of processes over
another!

 Criteria






CPU Utilization
Throughput
Turnaround Time: CompletionT-StartT
Waiting Time: Waiting in the ReadyQ
Response Time: FirstResponseTime
195

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Scheduling Criteria
 How to Measure the Performance of
CPU Scheduling Algorithms?
 Optimization of what?
 General Consideration
 Average Measure
 Minimum or Maximum Values

 Variance Æ Predictable Behavior
196
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Scheduling Algorithms
 First-Come, First-Served Scheduling
(FIFO)
 Shortest-Job-First Scheduling (SJF)
 Priority Scheduling
 Round-Robin Scheduling (RR)
 Multilevel Queue Scheduling
 Multilevel Feedback Queue Scheduling
 Multiple-Processor Scheduling
197
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

First-Come, First-Served
Scheduling (FCFS)
 The process which requests the
CPU first is allocated the CPU
 Properties:
 Non-preemptive scheduling
 CPU might be hold for an extended
period.
CPU
request
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

A FIFO ready queue

dispatched

198

First-Come, First-Served
Scheduling (FCFS)
 Example
Process
P1
P2
P3
Gantt
Chart

P1
0
P2 P3
0 3 6

CPU Burst Time
24
3
3

Average waiting time
P2 P3
24 27 30 = (0+24+27)/3 = 17
Average waiting time
P1
30 = (6+0+3)/3 = 3

*The average waiting time is highly affected by process CPU
burst times !
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

199

First-Come, First-Served
Scheduling (FCFS)
 Example: Convoy
Effect

CPU

I/O device

ready queue

idle

 One CPU-bound
process + many
I/O-bound
processes

ready queue

All other processes wait for it
to get off the CPU!
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

200

Shortest-Job-First Scheduling
(SJF)
 Non-Preemptive SJF
 Shortest next CPU burst first

Average waiting time
= (3+16+9+0)/4 = 7

process
P1
P2
P3
P4

P4 P1
0 3

CPU burst time
6
8
7
3
P3
9

P2
16

24
201

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Shortest-Job-First Scheduling
(SJF)
 Nonpreemptive SJF is optimal when
processes are all ready at time 0
 The minimum average waiting time!

 Prediction of the next CPU burst time?
 Long-Term Scheduler
 A specified amount at its submission
time
 Short-Term Scheduler
 Exponential average (0<= α <=1)

τn+1 = α tn + (1-α) τn

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

202

Shortest-Job-First Scheduling
(SJF)
 Preemptive SJF
 Shortest-remaining-time-first
Process
P1
P2
P3
P4

CPU Burst Time Arrival Time
8
0
4
1
9
2
5
3

P1 P2
P4
P1
P3
10
17
26
0 1
5
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Average Waiting
Time = ((10-1) +
(1-1) + (17-2) +
(5-3))/4 = 26/4
= 6.5
203

Shortest-Job-First Scheduling
(SJF)
 Preemptive or Non-preemptive?
 Criteria such as AWT (Average
Waiting Time)
0

10
1

or

Non-preemptive
AWT = (0+(10-1))/2
= 9/2 = 4.5

10 11
11

0
1 2

Preemptive AWT
= ((2-1)+0) = 0.5

* Context switching cost ~ modeling & analysis
204

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Priority Scheduling
 CPU is assigned to the process
with the highest priority – A
framework for various scheduling
algorithms:
 FCFS: Equal-Priority with TieBreaking by FCFS
 SFJ: Priority = 1 / next CPU burst
length
205
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Priority Scheduling
Process
P1
P2
P3
P4
P5

CPU Burst Time
10
1
2
1
5

Average waiting time
= (6+0+16+18+1)/5 = 8.2

Gantt Graph
P2 P5
0 1

Priority
3
1
3
4
2

P1
6

P3 P4
16 18 19
206

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Priority Scheduling
 Priority Assignment
 Internally defined – use some
measurable quantity, such as the #
of open files, Average CPU Burst
Average I/O Burst

 Externally defined – set by criteria
external to the OS, such as the
criticality levels of jobs.

207
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Priority Scheduling
 Preemptive or Non-Preemptive?
 Preemptive scheduling – CPU
scheduling is invoked whenever a
process arrives at the ready queue,
or the running process relinquishes
the CPU.
 Non-preemptive scheduling – CPU
scheduling is invoked only when the
running process relinquishes the
CPU.
208
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Priority Scheduling
 Major Problem
 Indefinite Blocking (/Starvation)
 Low-priority processes could starve
to death!

 A Solution: Aging
 A technique that increases the
priority of processes waiting in the
system for a long time.

209
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Round-Robin Scheduling (RR)
 RR is similar to FCFS except that
preemption is added to switch between
processes.
ready

running

Interrupt at every time quantum (time slice)

 Goal: Fairness – Time Sharing
FIFO…

CPU

New process

The quantum is used up!
210
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Round-Robin Scheduling (RR)
Process
P1
P2
P3

CPU Burst Time
24
Time slice = 4
3
3

P1 P2 P3 P1 P1 P1 P1 P1
0 4 7 10 14 18 22 26 30
AWT = ((10-4) + (4-0) + (7-0))/3
= 17/3 = 5.66
211
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Round-Robin Scheduling (RR)
 Service Size and Interval
 Time quantum = q Æ Service interval <= (n1)*q if n processes are ready.
 IF q = ∞, then RR Æ FCFS.
 IF q = ε, then RR Æ processor sharing. The
# of context switchings increases!
process
0
0
0

10
6

10
10

If context switch cost
= 10%
time quantum
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

quantum context switch #
12
0
6
1
1
9
=> 1/11 of CPU is wasted!

212

Round-Robin Scheduling (RR)
 Turnaround Time
process (10ms) quantum = 10
P1
P2

0

0

10

20

30

0

10

20

30

30 0

10

20

30

10
10

P3

20
20

quantum = 1

Average Turnaround Time
= (10+20+30)/3 = 20

ATT = (28+29+30)/3 = 29

=> 80% CPU Burst < time slice
213
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Multilevel Queue Scheduling
 Partition the ready queue into
several separate queues =>
Processes can be classified into
different groups and permanently
assigned to one queue.
System Processes
Interactive Processes

…
Batch Processes
214
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Multilevel Queue Scheduling
 Intra-queue scheduling
 Independent choice of scheduling
algorithms.

 Inter-queue scheduling
a. Fixed-priority preemptive scheduling
a. e.g., foreground queues always have absolute
priority over the background queues.

b. Time slice between queues
a. e.g., 80% CPU is given to foreground processes,
and 20% CPU to background processes.

c. More??
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

215

Multilevel Feedback Queue
Scheduling


Different from Multilevel Queue
Scheduling by Allowing Processes to
Migrate Among Queues.


Configurable Parameters:

a. # of queues
b. The scheduling algorithm for each queue
c. The method to determine when to upgrade a
process to a higher priority queue.
d. The method to determine when to demote a
process to a lower priority queue.
e. The method to determine which queue a newly
ready process will enter.
216
*Inter-queue
scheduling:
Fixed-priority
preemptive?!
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Multilevel Feedback Queue
Scheduling
 Example
quantum = 8
quantum = 16

FCFS
*Idea: Separate processes with different CPU-burst
characteristics!
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

217

Multiple-Processor Scheduling
 CPU scheduling in a system with
multiple CPUs
 A Homogeneous System
 Processes are identical in terms of their
functionality.
Î Can processes run on any processor?

 A Heterogeneous System
 Programs must be compiled for
instructions on proper processors.
218
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Multiple-Processor Scheduling


Load Sharing – Load Balancing!!


A queue for each processor




Self-Scheduling – Symmetric
Multiprocessing

A common ready queue for all processors.




Self-Scheduling
 Need synchronization to access common
data structure, e.g., queues.
Master-Slave – Asymmetric Multiprocessing
 One processor accesses the system
structures Æ no need for data sharing 219

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Real-Time Scheduling
 Definition
 Real-time means on-time, instead of
fast!
 Hard real-time systems:
 Failure to meet the timing constraints
(such as deadline) of processes may
result in a catastrophe!

 Soft real-time systems:
 Failure to meet the timing constraints
may still contribute value to the
system.
220
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Real-Time Scheduling


Dispatch Latency
Dispatch latency
Conflicts

Dispatch

1. Preemption of the running process
2. Releasing resources needed by the higher
priority process
3. Context switching to the higher priority
process
221
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Real-Time Scheduling


Minimization of Dispatch Latency?




Context switching in many OS, e.g.,
some UNIX versions, can only be done
after a system call completes or an I/O
blocking occurs

Solutions:
1. Insert safe preemption points in longduration system calls.
2. Protect kernel data by some
synchronization mechanisms to make
the entire kernel preemptible.
222

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Real-Time Scheduling
 Priority Inversion:
 A higher-priority processes must wait for
the execution of a lower-priority
processes.
P1
P2
P3

D

P1
D

D

D

V
Time

P2
Request
for D

P3

Time
D

P3 also waits for P2 to complete?
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Time
223

Real-Time Scheduling
 Priority Inheritance
 The blocked process inherits the
priority of the process that causes
the blocking.
P1
P2
P3

D

P1

D

D D

V
Time

P2
Request
for D

P3
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Time
D
Time224

Real-Time Scheduling
 Earliest Deadline First Scheduling
(EDF)
 Processes with closer deadlines have
higher priorities.
( priority (τ i ) ∝ (1 / d i ))

 An optimal dynamic-priority-driven
scheduling algorithm for periodic and
aperiodic processes!
Liu & Layland [JACM 73] showed that EDF is optimal in the sense that a process set is
scheduled by EDF if its CPU utilization ∑ ⎛⎜⎝ C P ⎞⎟⎠ is no larger than 100%.
225
i

i

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Real-Time Scheduling – EDF
process
P1
P2
P3

CPU Burst time Deadline Initial Arrival Time
4
0
20
5
1
15
6
2
16

P2

P1
0 1

P3
6

P1
12

0 1

12

0 1

6

15

Average waiting time
=(11+0+4)/3=5

15

20
16

20

P3
0

2

6

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

12

18

20
226

A General Architecture of RTOS’s
 Objectives in the Design of Many
RTOS’s
 Efficient Scheduling Mechanisms
 Good Resource Management Policies
 Predictable Performance

 Common Functionality of Many RTOS’s





Task Management
Memory Management
Resource Control, including devices
Process Synchronization
227

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

A General Architecture
User
Space
OS

processes
Top
Half
Bottom
Half
hardware

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

System calls such as I/O requests
which may cause the releasing
CPU of a process!
Timer expires to
• Expire the running process’s
time quota
• Keep the accounting info
for each process
Interrupts for Services
228

A General Architecture
 2-Step Interrupt Services

ISR

Interrupt/ISR Latency

I

 Immediate Interrupt Service

 Scheduled Interrupt Service
Scheduled Service

IST Latency

 Interrupt priorities > process priorities
 Time: Completion of higher priority ISR,
context switch, disabling of certain
interrupts, starting of the right ISR
(urgent/low-level work, set events)
 Usually done by preemptible threads

 Remark: Reducing of non-preemptible
code, Priority Tracking/Inheritance
(LynxOS), etc.
229

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

A General Architecture
 Scheduler
 A central part in the kernel
 The scheduler is usually driven by a
clock interrupt periodically, except
when voluntary context switches
occur – thread quantum?

 Timer Resolution
 Tick size vs Interrupt Frequency
 10ms? 1ms? 1us? 1ns?

 Fine-Grained hardware clock
230
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

A General Architecture
 Memory Management
 No protection for many embedded
systems
 Memory-locking to avoid paging

 Process Synchronization
 Sources of Priority Inversion
 Nonpreemptible code
 Critical sections

 A limited number of priority levels, etc.
231
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Algorithm Evaluation
 A General Procedure
 Select criteria that may include several
measures, e.g., maximize CPU
utilization while confining the maximum
response time to 1 second
 Evaluate various algorithms

 Evaluation Methods:





Deterministic modeling
Queuing models
Simulation
Implementation
232

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Deterministic Modeling
 A Typical Type of Analytic Evaluation
 Take a particular predetermined workload
and defines the performance of each
algorithm for that workload

 Properties
 Simple and fast
 Through excessive executions of a number of
examples, treads might be identified
 But it needs exact numbers for inputs, and its
answers only apply to those cases
 Being too specific and requires too exact
knowledge to be useful!
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

233

Deterministic Modeling
FCFC

P2

P1
0
process CPU Burst time
P1
10
P2
29
P3
3
P4
7
P5
12

10

P3 P4
39 42

P5
49

61

Average Waiting Time (AWT)=(0+10+39+42+49)/5=28
Nonpreemptive Shortest Job First

P3 P4 P1
P5
0 3 10
20
32

P2
61

AWT=(10+32+0+3+20)/5=13
Round Robin (quantum =10)

P1
0

P2 P3 P4 P5
P2 P5 P2
10
2023 30
40
50 52 61

AWT=(0+(10+20+2)+20+23+(30+10))/5=23

Queueing Models


Motivation:




Workloads vary, and there is no static set
of processes

Models (~ Queueing-Network Analysis)


Workload:
a. Arrival rate: the distribution of times when
processes arrive.
b. The distributions of CPU & I/O bursts



Service rate
235

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Queueing Models
 Model a computer system as a network
of servers. Each server has a queue of
waiting processes
 Compute average queue length, waiting
time, and so on.

 Properties:
 Generally useful but with limited
application to the classes of algorithms &
distributions
 Assumptions are made to make
problems solvable => inaccurate results
236
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Queueing Models
 Example: Little’s formula

n = λ∗w

λ

w

steady state!

λ

n = # of processes in the queue
λ = arrival rate
ω = average waiting time in the queue
 If n =14 & λ =7 processes/sec, then w =
2 seconds.
237
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Simulation
 Motivation:
 Get a more accurate evaluation.

 Procedures:
 Program a model of the computer system
 Drive the simulation with various data sets
 Randomly generated according to some
probability distributions
=> inaccuracy occurs because of only the
occurrence frequency of events. Miss the order &
the relationships of events.

 Trace tapes: monitor the real system &
record the sequence of actual events.
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

238

Simulation
 Properties:
 Accurate results can be gotten, but it
could be expensive in terms of
computation time and storage space.
 The coding, design, and debugging of
a simulator can be a big job.

239
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Implementation
 Motivation:
 Get more accurate results than a
simulation!

 Procedure:
 Code scheduling algorithms
 Put them in the OS
 Evaluate the real behaviors
240
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Implementation
 Difficulties:
 Cost in coding algorithms and
modifying the OS
 Reaction of users to a constantly
changing the OS
 The environment in which algorithms
are used will change
 For example, users may adjust their
behaviors according to the selected
algorithms
=> Separation of the policy and
mechanism!
241
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Process Scheduling Model
 Process Local Scheduling
 E.g., those for user-level threads
 Thread scheduling is done locally to
each application.

 System Global Scheduling
 E.g., those for Kernel-level threads
 The kernel decides which thread to
run.
242
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Process Scheduling Model –
Solaris 2
 Priority-Based Process Scheduling
 Real-Time
 System
 Kernel-service processes
low

 Time-Sharing
 A default class

 Interactive

 Each LWP inherits its class from its
parent process
243
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Process Scheduling Model –
Solaris 2
 Real-Time
 A guaranteed response

 System
 The priorities of system processes are
fixed.

 Time-Sharing
 Multilevel feedback queue scheduling
– priorities inversely proportional to
time slices

 Interactive
 Prefer windowing process
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

244

Process Scheduling Model –
Solaris 2
 The selected thread runs until one of
the following occurs:
 It blocks.
 It uses its time slice (if it is not a
system thread).
 It is preempted by a higher-priority
thread.

 RR is used when several threads
have the same priority.
245
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Process Scheduling Model –
Windows 2000
 Priority-Based Preemptive Scheduling
 Priority Class/Relationship: 0..31
 Dispatcher: A process runs until
 It is preempted by a higher-priority process.
 It terminates
 Its time quantum ends
 It calls a blocking system call

 Idle thread

 A queue per priority level
246
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Process Scheduling Model –
Windows 2000
 Each thread has a base priority that
represents a value in the priority range of
its class.
 A typical class – Normal_Priority_Class
 Time quantum – thread
 Increased after some waiting
 Different for I/O devices.

 Decreased after some computation
 The priority is never lowered below the base
priority.

 Favor foreground processes (more time
quantum)
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

247

Process Scheduling Model –
Windows 2000
A Typical Class

Base
Priority

Realtime

High

Above Normal
normal

Below Idle
normal priority

Timecritical

31

15

15

15

15

15

Highest

26

15

12

10

8

6

Above
normal

25

14

11

9

7

5

Normal

24

13

10

8

6

4

Below
normal

23

12

9

7

5

3

Lowest

22

11

8

6

4

2

Idle

16

1

1

1

1

1

Real-Time Class
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Variable Class (1..15)

248

Process Scheduling Model –
Linux
 Three Classes (POSIX.1b)
 Time-Sharing
 Soft Real-Time: FCFS, and RR

 Real-Time Scheduling Algorithms
 FCFS & RR always run the highest
priority process.
 FCFS runs a process until it exits or
blocks.

 No scheduling in the kernel space for
conventional Linux
249
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Process Scheduling Model –
Linux
 A Time-Sharing Algorithm for Fairness
 Credits = (credits / 2) + priority
 Recrediting when no runnable process
has any credits.
 Mixture of a history and its priority

 Favor interactive or I/O-bound
processes
 Background processes could be given
lower priorities to receive less credits.
 nice in UNIX
250
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Contents
1. Introduction
2. Computer-System Structures
3. Operating-System Structures
4. Processes
5. Threads
6. CPU Scheduling
7. Process Synchronization
8. Deadlocks
9. Memory Management
10. Virtual Memory
11. File Systems
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

251

Chapter 7
Process Synchronization

252

Process Synchronization
 Why Synchronization?
 To ensure data consistency for
concurrent access to shared data!

 Contents:
 Various mechanisms to ensure the
orderly execution of cooperating
processes

253
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Process Synchronization
 A Consumer-Producer Example
 Producer

 Consumer:

while (1) {
while (counter == BUFFER_SIZE)
;
produce an item in nextp;
….
buffer[in] = nextp;
in = (in+1) % BUFFER_SIZE;
counter++;
}

while (1) {
while (counter == 0)
;
nextc = buffer[out];
out = (out +1) % BUFFER_SIZE;
counter--;
consume an item in nextc;
}

Process Synchronization


counter++ vs counter—
r1 = counter
r1 = r1 + 1
counter = r1



r2 = counter
r2 = r2 - 1
counter = r2

Initially, let counter = 5.
1.
2.
3.
4.
5.
6.

P: r1 = counter
P: r1 = r1 + 1
C: r2 = counter
C: r2 = r2 – 1
P: counter = r1
C: counter = r2

A Race Condition!

Process Synchronization
 A Race Condition:
 A situation where the outcome of the
execution depends on the particular
order of process scheduling.

 The Critical-Section Problem:
 Design a protocol that processes can
use to cooperate.
 Each process has a segment of code,
called a critical section, whose
execution must be mutually exclusive.
256
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Process Synchronization
 A General Structure for the CriticalSection Problem
do {
permission request

entry section;
critical section;

exit notification

exit section;
remainder section;
} while (1);

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

257

The Critical-Section Problem


Three Requirements

1. Mutual Exclusion
a. Only one process can be in its critical section.

2. Progress
a.
b.

Only processes not in their remainder section can
decide which will enter its critical section.
The selection cannot be postponed indefinitely.

3. Bounded Waiting
a. A waiting process only waits for a bounded
number of processes to enter their critical
sections.
258
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

The Critical-Section Problem –
A Two-Process Solution
 Notation
 Processes Pi and Pj, where j=1-i;

do {

 Assumption

while (turn != i) ;

 Every basic machine-language
instruction is atomic.
 Algorithm 1

critical section

 Idea: Remember which process is
allowed to enter its critical section,
That is, process i can enter its
critical section if turn = i.

turn=j;
remainder section
} while (1);
259

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

The Critical-Section Problem –
A Two-Process Solution
 Algorithm 1 fails the progress requirement:
suspend or Time
quit!

P0
turn=0

exit
turn=1

Time

P1
exit
turn=0
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

blocked on P1’s
entry section 260

The Critical-Section Problem –
A Two-Process Solution
 Algorithm 2

Initially, flag[0]=flag[1]=false

 Idea: Remember the state
of each process.
 flag[i]==true Æ Pi is ready
to enter its critical section.
 Algorithm 2 fails the
progress requirement
when
flag[0]==flag[1]==true;

 the exact timing of the
two processes?
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

do {
flag[i]=true;
while (flag[j]) ;
critical section
flag[i]=false;
remainder section
} while (1);
261

* The switching of “flag[i]=true” and “while (flag[j]);”.

The Critical-Section Problem –
A Two-Process Solution
 Algorithm 3
 Idea: Combine the
ideas of Algorithms 1
and 2
 When (flag[i] &&
turn=i), Pj must wait.
 Initially,
flag[0]=flag[1]=false,
and turn = 0 or 1

do {
flag[i]=true;
turn=j;
while (flag[j] && turn==j) ;
critical section
flag[i]=false;
remainder section
} while (1);
262

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

The Critical-Section Problem –
A Two-Process Solution
 Properties of Algorithm 3
 Mutual Exclusion
 The eventual value of turn determines
which process enters the critical section.

 Progress
 A process can only be stuck in the while
loop, and the process which can keep it
waiting must be in its critical sections.

 Bounded Waiting
 Each process wait at most one entry by the
other process.
263
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

The Critical-Section Problem –
A Multiple-Process Solution
 Bakery Algorithm
 Originally designed for distributed
systems
 Processes which are ready to enter
their critical section must take a
number and wait till the number
becomes the lowest.

 int number[i]: Pi’s number if it is
nonzero.
 boolean choosing[i]: Pi is taking a
number.
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

264

The Critical-Section Problem –
A Multiple-Process Solution
do {
choosing[i]=true;
number[i]=max(number[0], …number[n-1])+1;
choosing[i]=false;
for (j=0; j < n; j++)
while choosing[j] ;
while (number[j] != 0 && (number[j],j)<(number[i],i)) ;
critical section
number[i]=0;
remainder section
} while (1);

• An observation: If Pi is in its
critical section, and Pk (k != i) has
already chosen its number[k],
then (number[i],i) < (number[k],k).

Synchronization Hardware
 Motivation:
 Hardware features make programming
easier and improve system efficiency.

 Approach:
 Disable Interrupt Æ No Preemption
 Infeasible in multiprocessor environment
where message passing is used.
 Potential impacts on interrupt-driven system
clocks.

 Atomic Hardware Instructions
 Test-and-set, Swap, etc.
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

266

Synchronization Hardware
boolean TestAndSet(boolean &target) {
boolean rv = target;
target=true;
return rv;
}
do {
while (TestAndSet(lock)) ;
critical section
lock=false;
remainder section
} while (1);

Synchronization Hardware
void Swap(boolean &a, boolean &b) {
boolean temp = a;
a=b;
b=temp;
}
do {
key=true;
while (key == true)
Swap(lock, key);
critical section
lock=false;
remainder section
} while (1);

Synchronization Hardware
do {
waiting[i]=true;
key=true;
while (waiting[i] && key)
key=TestAndSet(lock);
waiting[i]=false;
critical section;
j= (i+1) % n;
while(j != i) && (not waiting[j])
j= (j+1) % n;
If (j=i) lock=false;
else waiting[j]=false;
remainder section
} while (1);

 Mutual Exclusion
 Pass if key == F
or waiting[i] == F
 Progress
 Exit process
sends a process in.
Bounded Waiting
 Wait at most n-1
times
Atomic TestAndSet is
hard to implement in a
multiprocessor
environment.

Semaphores
 Motivation:
 A high-level solution for more
complex problems.

 Semaphore
 A variable S only accessible by two
atomic operations:
wait(S) {

/* P */

while (S <= 0) ;
S—;

signal(S) {
S++;
}

/* V */

}
•Indivisibility for “(S<=0)”, “S—”, and “S++”
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

270

Semaphores – Usages
 Critical Sections
do {
wait(mutex);
critical section
signal(mutex);
remainder section
} while (1);

 Precedence Enforcement
P1:
S1;
signal(synch);
P2:
wait(synch);
S2;

Semaphores
 Implementation
 Spinlock – A Busy-Waiting Semaphore
 “while (S <= 0)” causes the wasting of
CPU cycles!
 Advantage:
 When locks are held for a short time,
spinlocks are useful since no context
switching is involved.

 Semaphores with Block-Waiting
 No busy waiting from the entry to the
critical section!
272
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Semaphores
 Semaphores with Block Waiting
typedef struct {
int value;
struct process *L;
} semaphore ;
void signal(semaphore S);
void wait(semaphore S) {
S.value++;
S.value--;
if (S.value <= 0) {
if (S.value < 0) {
remove a process P form S.L;
add this process to S.L;
wakeup(P);
block();
}
}
}
}
* |S.value| = the # of waiting processes if S.value < 0.

Semaphores
 The queueing strategy can be arbitrary,
but there is a restriction for the boundedwaiting requirement.
 Mutual exclusion in wait() & signal()
 Uniprocessor Environments
 Interrupt Disabling
 TestAndSet, Swap
 Software Methods, e.g., the Bakery Algorithm,
in Section 7.2

 Multiprocessor Environments

 Remarks: Busy-waiting is limited to only
the critical sections of the wait() & signal()!
274
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Deadlocks and Starvation
 Deadlock
 A set of processes is in a deadlock state when
every process in the set is waiting for an event
that can be caused only by another process in the
set.

P0: wait(S);
wait(Q);
…
signal(S);
signal(Q);

P1: wait(Q);
wait(S);
…
signal(Q);
signal(S);

 Starvation (or Indefinite Blocking)
 E.g., a LIFO queue
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

275

Binary Semaphore
 Binary Semaphores versus Counting
Semaphores
 The value ranges from 0 to 1Æ easy
implementation!
wait(S)

signal(S)

wait(S1); /* protect C */
wait(S1);
C--;
C++;
if (C < 0) {
if (C <= 0)
signal(S1);
signal (S2); /* wakeup */
wait(S2);
else
}
signal (S1);
signal(S1);
* S1 & S2: binary semaphores
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

276

Classical Synchronization
Problems – The Bounded Buffer
Producer:
do {

Initialized to n
Initialized to 1

Initialized to 0

produce an item in nextp;
…….
wait(empty); /* control buffer availability */
wait(mutex); /* mutual exclusion */
……
add nextp to buffer;
signal(mutex);
signal(full); /* increase item counts */
} while (1);
277

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Classical Synchronization
Problems – The Bounded Buffer
Consumer:
do {
Initialized to 0
Initialized to 1

Initialized to n

wait(full); /* control buffer availability */
wait(mutex); /* mutual exclusion */
…….
remove an item from buffer to nextp;
……
signal(mutex);
signal(empty); /* increase item counts */
consume nextp;
} while (1);
278

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Classical Synchronization
Problems – Readers and Writers
 The Basic Assumption:
 Readers: shared locks
 Writers: exclusive locks

 The first reader-writers problem
 No readers will be kept waiting unless a
writer has already obtained permission to
use the shared object Æ potential hazard
to writers!

 The second reader-writers problem:
 Once a writer is ready, it performs its write
asap! Æ potential hazard to readers!
279
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Classical Synchronization
Problems – Readers and Writers
Reader:
First R/W semaphore wrt, mutex;
wait(mutex);
(initialized to 1);
Solution
readcount++;
int readcount=0;
if (readcount == 1)
Writer:
wait(wrt);
Queueing
wait(wrt);
signal(mutex);
mechanism
……
…… reading ……
wait(mutex);
writing is performed
readcount--;
……
if (readcount== 0)
signal(wrt)
signal(wrt);
Which is awaken?
signal(mutex);

Classical Synchronization
Problems – Dining-Philosophers
 Each philosopher must pick up one
chopstick beside him/her at a time
 When two chopsticks are picked up,
the philosopher can eat.
thinking

hungry

eating

dead
281

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Classical Synchronization
Problems – Dining-Philosophers
semaphore chopstick[5];
do {
wait(chopstick[i]);
wait(chopstick[(i + 1) % 5 ]);
… eat …
signal(chopstick[i]);
signal(chopstick[(i+1) % 5]);
…think …
} while (1);

Classical Synchronization
Problems – Dining-Philosophers
 Deadlock or Starvation?!
 Solutions to Deadlocks:
 At most four philosophers appear.
 Pick up two chopsticks “simultaneously”.
 Order their behaviors, e.g., odds pick up their
right one first, and evens pick up their left one
first.

 Solutions to Starvation:
 No philosopher will starve to death.
 A deadlock could happen??
283
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Critical Regions
 Motivation:
 Various programming errors in using
low-level constructs,e.g., semaphores
 Interchange the order of wait and signal
operations
 Miss some waits or signals
 Replace waits with signals
 etc

 The needs of high-level language
constructs to reduce the possibility of
errors!
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

284

Critical Regions
 Region v when B do S;
 Variable v – shared among processes
and only accessible in the region
struct buffer {
item pool[n];
int count, in, out;
};

 B – condition
 count < 0

 S – statements

Example: Mutual Exclusion
region v when (true) S1;
region v when (true) S2;
285

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Critical Regions – ConsumerProducer
struct buffer {
item pool[n];
int count, in, out;
};
Producer:
Consumer:
region buffer when
region buffer when
(count > 0) {
(count < n) {
nextc = pool[out];
pool[in] = nextp;
out = (out + 1) % n;
in = (in + 1) % n;
count--;
count++;
}
}
286
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Critical Regions –

Implementation by Semaphores
Region x when B do S;
/* to protect the region */ wait(mutex);
semaphore mutex;
while (!B) {
/* to (re-)test B */
/* fail B */
semaphore first-delay;
first-count++;
int first-count=0;
if (second-count > 0)
/* to retest B */
/* try other processes waiting
semaphore second-delay;
on second-delay */
int second-count=0;
signal(second-delay);
else signal(mutex);
/* block itself on first-delay */
287
wait(first-delay);
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Critical Regions –

Implementation by Semaphores
first-count--;
second-count++;
if (first-count > 0)
signal(first-delay);
else signal(second-delay);
/* block itself on first-delay */
wait(second-delay);
second-count--;
}
S;
if (first-count > 0)
signal(first-delay);
else if (second-count > 0)
signal(second-delay);
else signal(mutex);
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

288

Monitor
 Components
 Variables – monitor state
 Procedures
 Only access local variables or formal
parameters

shared data
queue for x

x

 Condition variables
 Tailor-made sync
 x.wait() or x.signal

………

procedures

entry queue
initialization
code
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

monitor name {
variable declaration
void proc1(…) {
}
…
void procn(…) {
}
289
}

Monitor
 Semantics of signal & wait
 x.signal() resumes one suspended
process. If there is none, no effect is
imposed.
 P x.signal() a suspended process Q
 P either waits until Q leaves the
monitor or waits for another condition
 Q either waits until P leaves the
monitor, or waits for another
condition.
290
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Monitor – Dining-Philosophers
Pi:
dp.pickup(i);
… eat …
dp.putdown(i);

monitor dp {
enum {thinking, hungry, eating} state[5];
condition self[5];
void pickup(int i) {
stat[i]=hungry;
test(i);
if (stat[i] != eating)
self[i].wait;
}
void putdown(int i) {
stat[i] = thinking;
test((i+4) % 5);
test((i + 1) % 5);
291
}

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Monitor – Dining-Philosophers
void test(int i) {
if (stat[(i+4) % 5]) != eating &&
stat[i] == hungry &&
state[(i+1) % 5] != eating) {
No deadlock!
stat[i] = eating;
But starvation could occur!
self[i].signal();
}
}
void init() {
for (int i=0; i < 5; i++)
state[i] = thinking;
}
292
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Monitor – Implementation by
Semaphores
 Semaphores
 mutex – to protect the monitor
 next – being initialized to zero, on which
processes may suspend themselves
 nextcount

 For each external function F
wait(mutex);
…
body of F;
…
if (next-count > 0)
signal(next);
else signal(mutex);
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

293

Monitor – Implementation by
Semaphores
 For every condition x
 A semaphore x-sem
 An integer variable x-count
 Implementation of x.wait() and x.signal :
 x.wait()
x-count++;
if (next-count > 0)
signal(next);
else signal(mutex);
wait(x-sem);
x-count--;
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

 x.signal
if (x-count > 0) {
next-count++;
signal(x-sem);
wait(next);
next-count--;
}
294

* x.wait() and x.signal() are invoked within a monitor.

Monitor
 Process-Resumption Order
 Queuing mechanisms for a monitor
and its condition variables.
 A solution:
x.wait(c);

monitor ResAllc {
boolean busy;
condition x;
void acquire(int time) {
if (busy)
x.wait(time);
busy=true;
}
…
}

 where the expression c is evaluated to
determine its process’s resumption
order.
R.acquire(t);
…
access the resource;
R.release;
295

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Monitor
 Concerns:
 Processes may access resources
without consulting the monitor.
 Processes may never release
resources.
 Processes may release resources
which they never requested.
 Process may even request resources
twice.
296
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Monitor
 Remark: Whether the monitor is correctly
used?
=> Requirements for correct computations
 Processes always make their calls on the
monitor in correct order.
 No uncooperative process can access
resource directly without using the access
protocols.

 Note: Scheduling behavior should consult
the built-in monitor scheduling algorithm if
resource access RPC are built inside the
monitor.
297
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

OS Synchronization – Solaris 2
 Semaphores and Condition Variables
 Adaptive Mutex
 Spin-locking if the lock-holding thread
is running; otherwise, blocking is used.

 Readers-Writers Locks
 Expensive in implementations.

 Turnstile
 A queue structure containing threads
blocked on a lock.
 Priority inversion Æ priority inheritance
298
protocol for kernel threads
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

OS Synchronization – Windows
2000
 General Mechanism

 Spin-locking for short code segments in
a multiprocessor platform.
 Interrupt disabling when access to
global variables is done in a
uniprocessor platform.

 Dispatcher Object
 State: signaled or non-signaled
 Mutex – select one process from its
waiting queue to the ready queue.
 Events – select all processes waiting
for the event.
299
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Atomic Transactions
 Why Atomic Transactions?
 Critical sections ensure mutual
exclusion in data sharing, but the
relationship between critical sections
might also be meaningful!
Æ Atomic Transactions

 Operating systems can be viewed as
manipulators of data!
300
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Atomic Transactions –
System Model
 Transaction – a logical unit of
computation
 A sequence of read and write operations
followed by a commit or an abort.

 Beyond “critical sections”
1. Atomicity: All or Nothing
 An aborted transaction must be rolled
back.
 The effect of a committed transaction
must persist and be imposed as a logical
unit of operations.
301
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Atomic Transactions –
System Model
2. Serializability:


T0
R(A)
W(A)

The order of transaction executions
must be equivalent to a serial
schedule.

T1
R(A)
W(A)

R(B)
W(B)

Two operations Oi & Oj conflict if
1. Access the same object
2. One of them is write

R(B)
W(B)
302
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Atomic Transactions –
System Model
 Conflict Serializable:
 S is conflict serializable if S can be
transformed into a serial schedule by
swapping nonconflicting operations.
T0
R(A)
W(A)

T1
R(A)
W(A)

R(B)
W(B)
R(B)
W(B)
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

T0
R(A)
W(A)
R(B)
W(B)

T1

R(A)
W(A)
R(B)
W(B)

303

Atomic Transactions –
Concurrency Control
 Locking Protocols
 Lock modes (A general approach!)
 1. Shared-Mode: “Reads”.
 2. Exclusive-Mode: “Reads” & “Writes“

 General Rule
 A transaction must receive a lock of an
appropriate mode of an object before it
accesses the object. The lock may not
be released until the last access of the
object is done.
304
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Atomic Transactions –
Concurrency Control
Lock
Request

Locked?

Yes

Request
compatible with the
current lock?

No

No
Lock is
granted

Yes

WAIT
305

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Atomic Transactions –
Concurrency Control
 When to release locks w/o violating
serializability
R0(A) W0(A) R1(A) R1(B) R0(B) W0(B)

 Two-Phase Locking Protocol (2PL) –
Not Deadlock-Free
Growing
Phase

Shrinking
Phase

serializable
schedules
2PL schedules

 How to improve 2PL?
 Semantics, Order of Data, Access
Pattern, etc.
306
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Atomic Transactions –
Concurrency Control
 Timestamp-Based Protocols
 A time stamp for each transaction TS(Ti)
 Determine transactions’ order in a
schedule in advance!

 A General Approach:
 TS(Ti) – System Clock or Logical Counter
 Unique?

 Scheduling Scheme – deadlock-free &
serializable
 W − timestamp (Q ) = Max
Ti −W ( Q ) (TS (Ti ))


R − timestamp(Q) = MaxTi − R (Q ) (TS (Ti ))

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

307

Atomic Transactions –
Concurrency Control
 R(Q) requested by Ti Æ check TS(Ti) !
Rejected

Time

Granted

W-timestamp(Q)

 W(Q) requested by Ti Æ check TS(Ti) !
Rejected

Time

Granted

R-timestamp(Q)
Time
Rejected Granted
W-timestamp(Q)

 Rejected transactions are rolled back
and restated with a new time stamp.
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

308

Failure Recovery – A Way to
Achieve Atomicity
 Failures of Volatile and Nonvolatile Storages!
 Volatile Storage: Memory and Cache
 Nonvolatile Storage: Disks, Magnetic Tape, etc.
 Stable Storage: Storage which never fail.

 Log-Based Recovery
 Write-Ahead Logging
 Log Records
< Ti starts >
< Ti commits >
< Ti aborts >
< Ti, Data-Item-Name, Old-Value, New-Value>
309
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Failure Recovery
 Two Basic Recovery Procedures:
Time
restart

crash

 undo(Ti): restore data updated by Ti
 redo(Ti): reset data updated by Ti

 Operations must be idempotent!
 Recover the system when a failure occurs:
 “Redo” committed transactions, and
“undo” aborted transactions.
310
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Failure Recovery
 Why Checkpointing?
 The needs to scan and rerun all log
entries to redo committed transactions.

 CheckPoint
 Output all log records, Output DB, and Write
<check point> to stable storage!
 Commit: A Force Write Procedure

checkpoint
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

crash

Time

311

Contents
1. Introduction
2. Computer-System Structures
3. Operating-System Structures
4. Processes
5. Threads
6. CPU Scheduling
7. Process Synchronization
8. Deadlocks
9. Memory Management
10. Virtual Memory
11. File Systems
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

312

Chapter 8 Deadlocks

313

Deadlocks
 A set of process is in a deadlock state
when every process in the set is waiting
for an event that can be caused by only
another process in the set.
 A System Model
 Competing processes – distributed?
 Resources:
 Physical Resources, e.g., CPU, printers,
memory, etc.
 Logical Resources, e.g., files,
semaphores, etc.
314
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Deadlocks


A Normal Sequence
1. Request: Granted or Rejected
2. Use
3. Release



Remarks



No request should exceed the
system capacity!
Deadlock can involve different
resource types!


Several instances of the same type!
315

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Deadlock Characterization


Necessary Conditions

(deadlock Æ conditions or ¬ conditions Æ ¬ deadlock)

1. Mutual Exclusion – At least one
resource must be held in a nonsharable mode!
2. Hold and Wait – Pi is holding at least
one resource and waiting to acquire
additional resources that are currently
held by other processes!
316
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Deadlock Characterization
3. No Preemption – Resources are
nonpreemptible!
4. Circular Wait – There exists a set
{P0, P1, …, Pn} of waiting process
such that P0 wait P1, P1wait P2, …,
Pn-1 wait Pn, and Pn wait P0.


Remark:



Condition 4 implies Condition 2.
The four conditions are not
completely independent!
317

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Resource Allocation Graph
System Resource-Allocation Graph
R1
R3

P1

P2

R2

P3

R4

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Vertices
Processes:
{P1,…, Pn}
Resource Type :
{R1,…, Rm}
Edges
Request Edge:
Pi Æ Rj
Assignment Edge:
Ri Æ Pj
318

Resource Allocation Graph
 Example
R1

R3

 No-Deadlock
 Vertices
 P = { P1, P2, P3 }
 R = { R1, R2, R3, R4 }

P1

P2

P3

 Edges
 E = { P1ÆR1, P2ÆR3,
R1ÆP2, R2ÆP2,
R2ÆP1, R3ÆP3 }

R2

R4

 Resources
 R1:1, R2:2, R3:1, R4:3

 Æ results in a deadlock.
319
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Resource Allocation Graph
 Observation
 The existence of a cycle
 One Instance per Resource Type Æ Yes!!
 Otherwise Æ Only A Necessary Condition!!
R1

P1

R2

P2
P3
P4

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

320

Methods for Handling Deadlocks


Solutions:
1. Make sure that the system never
enters a deadlock state!



Deadlock Prevention: Fail at least one
of the necessary conditions
Deadlock Avoidance: Processes
provide information regarding their
resource usage. Make sure that the
system always stays at a “safe” state!

321
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Methods for Handling Deadlocks
2. Do recovery if the system is
deadlocked.



Deadlock Detection
Recovery

3. Ignore the possibility of deadlock
occurrences!




Restart the system “manually” if the
system “seems” to be deadlocked or
stops functioning.
Note that the system may be “frozen”
temporarily!
322

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Deadlock Prevention
 Observation:
 Try to fail anyone of the necessary
condition!
∵ ¬ (∧ i-th condition) → ¬ deadlock

 Mutual Exclusion
?? Some resources, such as a printer,
are intrinsically non-sharable??
323
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Deadlock Prevention
 Hold and Wait
 Acquire all needed resources before its
execution.
 Release allocated resources before
request additional resources!
[ Tape Drive Æ Disk ]

[ Disk & Printer ]

Hold Them All
Disk & Printer
Tape Drive & Disk

 Disadvantage:
 Low Resource Utilization
 Starvation
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

324

Deadlock Prevention
 No Preemption
 Resource preemption causes the release of resources.
 Related protocols are only applied to resources whose
states can be saved and restored, e.g., CPU register &
memory space, instead of printers or tape drives.

 Approach 1:
Resource
Request

Satisfied?

No

Allocated
resources
are released

Yes
granted
325
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Deadlock Prevention
 Approach 2
Resource
Request

Satisfied?

Yes

granted

No
Requested
Resources are
held by “Waiting”
processes?

Yes

Preempt
those
Resources.

No
“Wait” and its
allocated resources
may be preempted.
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

326

Deadlock Prevention
 Circular Wait
A resource-ordering approach:
F:RÆN
Resource requests must be made in
an increasing order of enumeration.

 Type 1 – strictly increasing order of
resource requests.
 Initially, order any # of instances of Ri
 Following requests of any # of instances
of Rj must satisfy F(Rj) > F(Ri), and so on.
* A single request must be issued for all
needed instances of the same resources.
327
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Deadlock Prevention
 Type 2
 Processes must release all Ri’s when
they request any instance of Rj if F(Ri) ≥
F(Rj)

 F : R Æ N must be defined according to
the normal order of resource usages in a
system, e.g.,
F(tape drive) = 1
F(disk drive) = 5
?? feasible ??
F(printer)
= 12
328
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Deadlock Avoidance
 Motivation:
 Deadlock-prevention algorithms can cause
low device utilization and reduced system
throughput!
Î Acquire additional information about how
resources are to be requested and have
better resource allocation!
 Processes declare their maximum
number of resources of each type that it
may need.

329

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Deadlock Avoidance
 A Simple Model
 A resource-allocation state
<# of available resources,
# of allocated resources,
max demands of processes>

 A deadlock-avoidance algorithm dynamically
examines the resource-allocation state and
make sure that it is safe.
 e.g., the system never satisfies the circularwait condition.
330
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Deadlock Avoidance
 Safe Sequence
 A sequence of processes <P1,
P2, …, Pn> is a safe sequence if

∀ Pi , need ( Pi ) ≤ Available + ∑ allocated ( Pj )
j<i

safe

unsafe
deadlock

 Safe State
 The existence of a safe sequence
 Unsafe

Deadlocks are avoided if the system can
allocate resources to each process up to its
maximum request in some order. If so, the
system is in a safe state!
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

331

Deadlock Avoidance
 Example:
max needs

Allocated

Available

P0

10

5

3

P1

4

2

P2

9

2

• The existence of a safe sequence <P1, P0, P2>.
• If P2 got one more, the system state is unsafe.
Q (( P0,5), ( P1,2), ( P 2,3), (available,2))

How to ensure that the system will always
remain in a safe state?
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

332

Deadlock Avoidance – ResourceAllocation Graph Algorithm
 One Instance per Resource Type
•Request Edge

R1

Pi
P1

P2
R2

Rj
resource
allocated

•Assignment Edge
Rj

Pi

•Claim Edge
Pi

request
made
resource
release

Rj
333

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Deadlock Avoidance – ResourceAllocation Graph Algorithm
R1
P1

A cycle is detected!
Î The system state is unsafe!
P2

R2

• R2 was requested & granted!
Safe state: no cycle
Unsafe state: otherwise

Cycle detection
can be done
in O(n2)

334
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Deadlock Avoidance – Banker’s
Algorithm
 Available [m]
 If Available [i] = k, there are k instances of
resource type Ri available.

n: # of
processes,
m: # of
resource
types

 Max [n,m]
 If Max [i,j] = k, process Pi may request at most k
instances of resource type Rj.

 Allocation [n,m]
 If Allocation [i,j] = k, process Pi is currently
allocated k instances of resource type Rj.

 Need [n,m]
 If Need [i,j] = k, process Pi may need k more
instances of resource type Rj.

¾ Need [i,j] = Max [i,j] – Allocation [i,j]
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

335

Deadlock Avoidance – Banker’s
Algorithm
 Safety Algorithm – A state is safe??
n: # of
processes,
m: # of
resource
types

1. Work := Available & Finish [i] := F, 1≦ i≦ n
2. Find an i such that both
1. Finish [i] =F
2. Need[i] ≦ Work
If no such i exist, then goto Step4
3. Work := Work + Allocation[i]
Finish [i] := T; Goto Step2
4. If Finish [i] = T for all i, then the system is in
a safe state.
Where Allocation[i] and Need[i] are the i-th row of
Allocation and Need, respectively, and
X≦ Y if X[i] ≦ Y[i] for all i,
X < Y if X ≦ Y and Y≠ X

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

336

Deadlock Avoidance – Banker’s
Algorithm
 Resource-Request Algorithm
Requesti [j] =k: Pi requests k instance of resource type Rj
1. If Requesti ≦ Needi, then Goto Step2; otherwise, Trap
2. If Requesti ≦ Available, then Goto Step3; otherwise, Pi
must wait.
3. Have the system pretend to have allocated resources to
process Pi by setting
Available := Available – Requesti;
Allocationi := Allocationi + Requesti;
Needi := Needi – Requesti;
Execute “Safety Algorithm”. If the system state is safe,
the request is granted; otherwise, Pi must wait, and the
old resource-allocation state is restored!
337
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Deadlock Avoidance
 An Example
Allocation

Max

Need

Available

A

B

C

A

B

C

A

B

C

A

B

C

P0

0

1

0

7

5

3

7

4

3

3

3

2

P1

2

0

0

3

2

2

1

2

2

P2

3

0

2

9

0

2

6

0

0

P3

2

1

1

2

2

2

0

1

1

P4

0

0

2

4

3

3

4

3

1

• A safe state
∵ <P1,P3,P4,P2,P0> is a safe sequence.
338
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Deadlock Avoidance
Let P1 make a request Requesti = (1,0,2)
Requesti ≦ Available ((1,0,2) ≦ (3,3,2))
Allocation

Need

Available

A

B

C

A

B

C

A

B

C

P0

0

1

0

7

4

3

2

3

0

P1

3

0

2

0

2

0

P2

3

0

2

6

0

0

P3

2

1

1

0

1

1

P4

0

0

2

4

3

1

Æ Safe ∵ <P1,P3,P4,P0,P2> is a safe sequence!
• If Request4 = (3,3,0) is asked later, it must be rejected.
• Request0 = (0,2,0) must be rejected because it results in an
unsafe state.
339
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Deadlock Detection
 Motivation:
 Have high resource utilization and
“maybe” a lower possibility of deadlock
occurrence.
 Overheads:
 Cost of information maintenance
 Cost of executing a detection algorithm
 Potential loss inherent from a deadlock
recovery
340
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Deadlock Detection – Single
Instance per Resource Type
P5
R1

R3

P5
R4

P1

P2

P3

R2

P4

R5

A Resource-Allocation Graph
Pi

Rq

Pj

P1

P2

P3

P4

A Wait-For Graph
Pi

Pj

• Detect an cycle in O(n2).
• The system needs to maintain the wait-for graph
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

341

Deadlock Detection – Multiple
Instance per Resource Type
 Data Structures

n: # of
processes,
m: # of
resource
types




Available[1..m]: # of available resource
instances
Allocation[1..n, 1..m]: current resource
allocation to each process
Request[1..n, 1..m]: the current request of
each process
 If Request[i,j] = k, Pi requests k more
instances of resource type Rj

342
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Deadlock Detection – Multiple
Instance per Resource Type

Complexity =
O(m * n2)

1. Work := Available. For i = 1, 2, …, n, if
Allocation[i] ≠ 0, then Finish[i] = F;
otherwise, Finish[i] =T.
2. Find an i such that both
a. Finish[i] = F
b. Request[i] ≦ Work
If no such i, Goto Step 4
3. Work := Work + Allocation[i]
Finish[i] := T
Goto Step 2
4. If Finish[i] = F for some i, then the system is
in a deadlock state. If Finish[i] = F, then
process Pi is deadlocked.

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

343

Deadlock Detection – Multiple
Instance per Resource Type
 An Example
Allocation

Request

Available

A

B

C

A

B

C

A

B

C

P0

0

1

0

0

0

0

0

2

0

P1

2

0

0

2

0

2

P2

3

0

3

0

0

0

P3

2

1

1

1

0

0

P4

0

0

2

0

0

2

Î Find a sequence <P0, P2, P3, P1, P4> such that Finish[i]
= T for all i.
If Request2 = (0,0,1) is issued, then P1, P2, P3, and P4 are
344
deadlocked.
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Deadlock Detection – Algorithm
Usage
 When should we invoke the detection
algorithm?
 How often is a deadlock likely to occur?
 How many processes will be affected by a
deadlock?
overheads
Every
－
＋
rejected
processes affected ∞
＋
request －
 Time for Deadlock Detection?
 CPU Threshold? Detection Frequency? …
345
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Deadlock Recovery
 Whose responsibility to deal with
deadlocks?
 Operator deals with the deadlock
manually.
 The system recover from the
deadlock automatically.

 Possible Solutions
 Abort one or more processes to
break the circular wait.
 Preempt some resources from one or
more deadlocked processes.
346
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Deadlock Recovery – Process
Termination
 Process Termination
 Abort all deadlocked processes!
 Simple but costly!
 Abort one process at a time until the deadlock
cycle is broken!
 Overheads for running the detection again and
again.
 The difficulty in selecting a victim!
But, can we abort any process?
Should we compensate any
damage caused by aborting?
347
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Deadlock Recovery – Process
Termination
 What should be considered in choosing
a victim?
 Process priority
 The CPU time consumed and to be
consumed by a process.
 The numbers and types of resources
used and needed by a process
 Process’s characteristics such as
“interactive or batch”
 The number of processes needed to be
aborted.
348
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Deadlock Recovery – Resource
Preemption
 Goal: Preempt some resources from processes
from processes and give them to other processes
until the deadlock cycle is broken!
 Issues
 Selecting a victim:
 It must be cost-effective!

 Roll-Back
 How far should we roll back a process whose resources
were preempted?

 Starvation
 Will we keep picking up the same process as a victim?
349
 How to control the # of rollbacks per process efficiently?
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Deadlock Recovery –
Combined Approaches
 Partition resources into classes that
are hierarchically ordered.
⇒ No deadlock involves more than
one class
 Handle deadlocks in each class
independently

350
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Deadlock Recovery –
Combined Approaches
Examples:
 Internal Resources: Resources used by the
system, e.g., PCB
→ Prevention through resource ordering
 Central Memory: User Memory
→ Prevention through resource preemption
 Job Resources: Assignable devices and files


→ Avoidance ∵ This info may be obtained!
Swappable Space: Space for each user process
on the backing store
→ Pre-allocation ∵ the maximum need is known!
351

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Contents
1. Introduction
2. Computer-System Structures
3. Operating-System Structures
4. Processes
5. Threads
6. CPU Scheduling
7. Process Synchronization
8. Deadlocks
9. Memory Management
10. Virtual Memory
11. File Systems
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

352

Chapter 9
Memory Management

353

Memory Management
 Motivation
 Keep several processes in memory
to improve a system’s performance
 Selection of different memory
management methods
 Application-dependent
 Hardware-dependent
 Memory – A large array of words or
bytes, each with its own address.
 Memory is always too small!
354
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Memory Management
 The Viewpoint of the Memory Unit
 A stream of memory addresses!

 What should be done?
 Which areas are free or used (by
whom)
 Decide which processes to get memory
 Perform allocation and de-allocation

 Remark:
 Interaction between CPU scheduling
and memory allocation!
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

355

Background
 Address Binding – binding of instructions and data
to memory addresses
Binding Time
Known at compile time,
where a program will be in
memory - “absolute code”
MS-DOS *.COM
At load time:
- All memory reference by a
program will be translated
- Code is relocatable
- Fixed while a program runs
At execution time
- binding may change
as a program run

source program

symbolic address
e.g., x

compiling
object module
other object
modules

Relocatable
address

linking
load module

system library

dynamically
loaded system
library

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

loading
in-memory binary
memory image

Absolute
address
356

Background
Main
Memory

• Binding at the Compiling
Time
•A process must execute at a
specific memory space
• Binding at the Load Time
• Relocatable Code
• Process may move from a
memory segment to another →
binding is delayed till run-time
357

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Logical Versus Physical Address

CPU

Logical
Address

346
The user program
deals with logical
addresses
- Virtual Addresses
(binding at the run time)

+
Relocation
Register

Physical
Address

14346

Memory
Address
Register

Memory
14000
Memory Management
Unit (MMU) –
“Hardware-Support”
358

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Logical Versus Physical Address
 A logical (physical) address space is the set of
logical (physical) addresses generated by a
process. Physical addresses of a program is
transparent to any process!
 MMU maps from virtual addresses to physical
addresses. Different memory mapping
schemes need different MMU’s that are
hardware devices. (slow down)
 Compile-time & load-time binding schemes
results in the collapsing of logical and physical
address spaces.
359
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Dynamic Loading
 Dynamic Loading
 A routine will not be loaded until it is
called. A relocatable linking loader
must be called to load the desired
routine and change the program’s
address tables.

 Advantage
 Memory space is better utilized.

 Users may use OS-provided
libraries to achieve dynamic loading
360
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Dynamic Linking
 Dynamic Linking

Static Linking

language library
A small piece of code, called
+
stub, is used to locate or load program object module
the appropriate routine
binary program image

Advantage
Save memory space by sharing
the library code among
processes Æ Memory
Protection & Library Update!
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Simple

361

Overlays
 Motivation
 Keep in memory only those instructions and data
needed at any given time.
 Example: Two overlays of a two-pass assembler
Symbol table

20KB

common routines 30KB
overlay driver
70KB Pass 1

10KB

Certain relocation &
linking algorithms are
needed!

Pass 2

80KB
362

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Overlays
 Memory space is saved at the cost of
run-time I/O.
 Overlays can be achieved w/o OS
support:
⇒ “absolute-address” code
 However, it’s not easy to program a
overlay structure properly!
⇒ Need some sort of automatic
techniques that run a large program in a
limited physical memory!
363
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Swapping
OS
swap out
User
Space

Main Memory

swap in

Process
p1
Process
p2

Backing Store

Should a process be put back into the same
memory space that it occupied previously?
↔ Binding Scheme?!
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

364

Swapping
 A Naive Way
Pick up
a process
from the
ready queue

Dispatcher
checks whether
the process is
in memory

Yes

Dispatch CPU to
the process

No
Swap in
the process

Potentially High Context-Switch Cost:
2 * (1000KB/5000KBps + 8ms) = 416ms
Transfer Time Latency Delay
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

365

Swapping
 The execution time of each process should
be long relative to the swapping time in
this case (e.g., 416ms in the last example)!
100k
disk
 Only swap in1000kwhat
is
actually
used. ⇒
= 100ms
per sec
+
Users must keep the system informed of
memory usage.
Memory
 Who should be swapped out?
OS
100k
disk
=100ms
1000kpersec
+

I/O buffering

 “Lower Priority” Processes?
 Any Constraint?
⇒ System Design

Pi

I/O buffering
?I/O?

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

366

Swapping
 Separate swapping space from the
file system for efficient usage
 Disable swapping whenever possible
such as many versions of UNIX –
Swapping is triggered only if the
memory usage passes a threshold,
and many processes are running!
 In Windows 3.1, a swapped-out
process is not swapped in until the
user selects the process to run.
367
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Contiguous Allocation – Single User
0000
a
b

OS

relocation register

a
User
limit register

Unused

b

8888



A single user is allocated as much memory as
needed
Problem: Size Restriction → Overlays (MS/DOS)

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

368

Contiguous Allocation – Single User
 Hardware Support for Memory Mapping
and Protection
relocation
register

limit
register

CPU
logical
address

<

Yes
No

+

physical
address

memory

trap

Disadvantage: Wasting of CPU and Resources
∵ No Multiprogramming Possible
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

369

Contiguous Allocation – Multiple Users
 Fixed Partitions

20k

Partition 1
45k

Partition 2

proc 1
proc 7

60k

proc 5

Partition 3
Partition 4

90k
100k

“fragmentation”
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

 Memory is divided into
fixed partitions, e.g.,
OS/360 (or MFT)
 A process is allocated on
an entire partition
 An OS Data Structure:
Partitions
size
#

location

status

1

25KB

20k

Used

2

15KB

45k

Used

3

30KB

60k

Used

4

10KB

90k

Free

370

Contiguous Allocation – Multiple Users
 Hardware Supports
 Bound registers
 Each partition may have a
protection key (corresponding to a
key in the current PSW)
 Disadvantage:
 Fragmentation gives poor memory
utilization !
371
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Contiguous Allocation – Multiple Users
 Dynamic Partitions
 Partitions are dynamically created.
 OS tables record free and used partitions
20k
40k

OS
Process 1

Used

Base = 20k
size = 20KB
user = 1

Base = 70k
size = 20KB
user = 2

Free

Base = 40k
size = 30KB

Base = 90k
size = 20KB

free
70k
90k
110k

Process 2

free

Input Queue
P3 with a 40KB
memory request !

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

372

Contiguous Allocation – Multiple Users
 Solutions for dynamic storage allocation :
 First Fit – Find a hole which is big enough
Better
in Time
and Storage
Usage

 Advantage: Fast and likely to have large chunks
of memory in high memory locations

 Best Fit – Find the smallest hole which is big
enough. → It might need a lot of search time
and create lots of small fragments !
 Advantage: Large chunks of memory available

 Worst Fit – Find the largest hole and create a
new partition out of it!
 Advantage: Having largest leftover holes with
lots of search time!
373
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Contiguous Allocation Example – First Fit
Process Memory Time
(RR Scheduler with Quantum = 1) A job queue
400k

OS

400k
1000k

OS
P1
P2

2000k
2300k
2560k

400k
1000k
1700k
2000k
2300k
2560k

Time = 0

OS
P1
P4
P3
Time = “14”

2560k

400k
1000k
1700k
2000k
2300k
2560k

P3

400k
1000k

OS
P1

2000k
2300k
2560k

Time = “0”

Time = 14
400k
900k
1000k

P4
300KB

+
260KB

Time = 28

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

600KB 10
1000KB 5
300KB 20
700KB 8
500KB 15

P2 terminates &
frees its memory

P3

OS

P3

P1
P2
P3
P4
P5

1700k
2000k
560KB 2300k

P5?

2560k

OS
P5
P4
P3
Time = “28”

374

Fragmentation – Dynamic Partitions


External fragmentation occurs as small
chunks of memory accumulate as a byproduct of partitioning due to imperfect fits.


Statistical Analysis For the First-Fit Algorithm:




1/3 memory is unusable – 50-percent rule

Solutions:
a. Merge adjacent free areas.
b. Compaction
-

Compact all free areas into one contiguous region
Requires user processes to be relocatable

Any optimal compaction strategy???
375
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Fragmentation – Dynamic Partitions
0
300K
500K
600K
1000K
1200K
1500K
1900K
2100K

OS
P1
P2
400KB
P3
300KB
P4
200KB

0

OS

300K
500K
600K
800K
1200K

P1
P2
*P3
*P4

0

OS

300K
500K
600K
1000K
1200K

900K
2100K

MOVE 600KB

P1
P2
*P4
P3
900K

2100K

0

OS

300K

P1
P2

500K
600K

900K
1500K
1900K
2100K

MOVE 400KB

P3
*P4

MOVE 200KB

 Cost: Time Complexity O(n!)?!!
 Combination of swapping and compaction

 Dynamic/static relocation
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

376

Fragmentation – Dynamic Partitions
 Internal fragmentation:
A small chunk of “unused” memory internal to a
partition.
OS
P1
20,002 bytes

P3 request 20KB
?? give P3 20KB & leave a
2-byte free area??

P2
Reduce free-space maintenance cost
Æ Give 20,002 bytes to P3 and have 2 bytes as an internal
377
fragmentation!
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Fragmentation – Dynamic Partitions
 Dynamic Partitioning:
 Advantage:
⇒ Eliminate fragmentation to some degree
⇒ Can have more partitions and a higher degree
of multiprogramming

 Disadvantage:
 Compaction vs Fragmentation
 The amount of free memory may not be enough for a
process! (contiguous allocation)
 Memory locations may be allocated but never
referenced.

 Relocation Hardware Cost & Slow Down

⇒ Solution: Paged Memory!
378
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Paging
 Objective
 Users see a logically contiguous address
space although its physical addresses are
throughout physical memory

 Units of Memory and Backing Store
 Physical memory is divided into fixed-sized
blocks called frames.
 The logical memory space of each process
is divided into blocks of the same size
called pages.
 The backing store is also divided into
blocks of the same size if used.

379

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Paging – Basic Method
Page Offset

Logical Address
CPU

p

d

f

d

f

Physical Address
Page Table
Page Number

p

d
……

..
f

Base Address of Page p

……
380
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Paging – Basic Method
 Address Translation
page size page offset

p
m-n

d
n
m

max number of pages: 2m-n
Logical Address Space: 2m
Physical Address Space: ???

 A page size tends to be a power of 2
for efficient address translation.
 The actual page size depends on the
computer architecture. Today, it is
from 512B or 16KB.
381
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Paging – Basic Method
Page
0

A

0

0

4

1
8

2
12

3
16

B

1

C

2
3

D
Logical
Memory

Logical Address
1*4+1=5

0
4
8
12
16
20
24
28

5
6
1
2
Page
Table

C
D
A
B

Frame
0
1
2
3
4
5
6
7

Physical Memory

01

01

110

01

Physical Address
= 6 * 4 + 1 = 25

382

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Paging – Basic Method
 No External Fragmentation
 Paging is a form of dynamic relocation.
 The average internal fragmentation is about
one-half page per process

 The page size generally grows over time as
processes, data sets, and memory have
become larger.
 4-byte page table entry & 4KB per page Æ
232 * 212B = 244B = 16TB of physical memory
Page Size

Disk I/O
Efficiency

Page Table
Maintenance

* Example: 8KB or 4KB for Solaris.

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Internal
Fragmentation
383

Paging – Basic Method
 Page Replacement:
 An executing process has all of its pages
in physical memory.

 Maintenance of the Frame Table
 One entry for each physical frame
 The status of each frame (free or allocated)
and its owner

 The page table of each process must be
saved when the process is preempted. Æ
Paging increases context-switch time!
384
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Paging – Hardware Support
 Page Tables
 Where: Registers or Memory
 Efficiency is the main consideration!

 The use of registers for page tables
 The page table must be small!
 The use of memory for page tables
 Page-Table Base Register (PTBR)

a
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

A Page
Table

385

Paging – Hardware Support
 Page Tables on Memory
 Advantages:
 The size of a page table is unlimited!
 The context switch cost may be low if the
CPU dispatcher merely changes PTBR,
instead of reloading another page table.

 Disadvantages:
 Memory access is slowed by a factor of 2
 Translation Look-aside buffers (TLB)
 Associate, high-speed memory
 (key/tag, value) – 16 ~ 1024 entries
 Less than 10% memory access time 386
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Paging – Hardware Support
 Translation Look-aside Buffers(TLB):
 Disadvantages: Expensive Hardware and
Flushing of Contents for Switching of
Page Tables
 Advantage: Fast – Constant-Search Time
key

value

item

387
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Paging – Hardware Support
Logical Address
CPU

p

p

d

Page# Frame#

….

TLB

TLB Hit
Physical
Memory

……..
f

Physical
Address

TLB Miss
* Address-Space Identifiers
(ASID) in TLB for process
matching? Protection? Flush?
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

d

f

Page
Table

• Update TLB if a TLB miss occurs!
• Replacement of TLB entries might
388
be needed.

Paging – Effective Memory
Access Time
 Hit Ratio = the percentage of times that a
page number is found in the TLB
 The hit ratio of a TLB largely depends
on the size and the replacement
strategy of TLB entries!
 Effective Memory Access Time
 Hit-Ratio * (TLB lookup + a mapped
memory access) + (1 – Hit-Ratio) *
(TLB lookup + a page table lookup + a
mapped memory access)
389
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Paging – Effective Memory
Access Time
 An Example
 20ns per TLB lookup, 100ns per memory
access

 Effective Access Time = 0.8*120ns
+0.2*220ns = 140 ns, when hit ratio = 80%
 Effective access time = 0.98*120ns
+0.02*220ns = 122 ns, when hit ratio = 98%
 Intel 486 has a 32-register TLB and claims a
98 percent hit ratio.
390
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Paging – Protection & Sharing
 Protection

y
y
y

v
v

2
7
3

y

v
1

0

memory r/w/e dirty
Is the page in memory?

Page Table

Valid-Invalid Bit
Valid Page?
Modified?
r/w/e protected: 100r, 010w, 110rw,
…

 Use a Page-Table Length Register (PTLR) to
indicate the size of the page table.
 Unused Paged table entries might be ignored
during maintenance.
391
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Paging – Protection & Sharing
 Example: a 12287-byte Process (16384=214)
0

P0

2K

P1

4K

P2

6K

P3

8K

P4

10K
10,468
12,287

Logical address
p
d
3

2
3
4
7
8
9
0
0

Page Table
(PTLR entries?)

P5

…

V
V
V
V
V
V
i
i

0
1
2
3
4
5
6
7

11

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

0
1
2
3
4
5
6
7
8
9

P0
P1
P2

P3
P4
P5

392

Paging – Protection & Sharing
P1

*ed1
*ed2

Page
Table 1

3
4
6

*ed3

1

P2

*ed1
*ed2
*ed3

Page
Table 2

3
4
6
7

* Data 2

* Data 1

*
*
*
*
*
*
*
::
data2
ed1 ed2
ed3
page 0
1
2
3
4
5
6
7
n
 Procedures which are executed often (e.g., editor) can be divided into
procedure + date. Memory can be saved a lot.
 Reentrant procedures can be saved! The non-modified nature of saved
code must be enforced
393
 Address referencing inside shared pages could be an issue.
*
data1

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Multilevel Paging
 Motivation
 The logical address space of a process
in many modern computer system is very
large, e.g., 232 to 264 Bytes.
32-bit address Æ 220 page entries Æ 4MB
4KB per page
4B per entries
page table

Æ Even the page table must be divided into
pieces to fit in the memory!
394
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Multilevel Paging – Two-Level Paging
Logical Address

P1 P2 d

Physical
Memory

P1
P2

PTBR

d
Outer-Page Table
A page of page table

Forward-Mapped Page Table
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

395

Multilevel Paging – N-Level Paging
 Motivation: Two-level paging is not
appropriate for a huge logical address space!
Logical Address
P1

P2

..

N pieces

PTBR

Pn d
P1

P2

…

Physical
Memory

Pn

d

1
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

+

1

+… +

1

= n+1

+

1

accesses

396

Multilevel Paging – N-Level Paging
 Example
 98% hit ratio, 4-level paging, 20ns TLB
access time, 100ns memory access time.
 Effective access time = 0.98 X 120ns +
0.02 X 520ns = 128ns

 SUN SPARC (32-bit addressing) Æ 3-level
paging
 Motorola 68030 (32-bit addressing) Æ 4-

level paging
 VAX (32-bit addressing) Æ 2-level paging
397
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Hashed Page Tables
 Objective:
 To handle large address spaces

 Virtual address Æ hash function Æ a
linked list of elements
 (virtual page #, frame #, a pointer)

 Clustered Page Tables
 Each entry contains the mappings for
several physical-page frames, e.g.,
16.
398
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Inverted Page Table
 Motivation
 A page table tends to be big and does not
correspond to the # of pages residing in the
physical memory.

 Each entry corresponds to a physical frame.
 Virtual Address: <Process ID, Page Number, Offset>
Logical
Address

CPU

pid

P

d

f

d

Physical
Memory

Physical
Address
pid: p

An Inverted Page Table
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

399

Inverted Page Table
 Each entry contains the virtual address of the frame.
 Entries are sorted by physical addresses.
 One table per system.
 When no match is found, the page table of the
corresponding process must be referenced.
 Example Systems: HP Spectrum, IBM RT, PowerPC,
SUN UltraSPARC
Logical
Address

CPU

pid

P

d

f

d

Physical
Memory

Physical
Address
pid: p

An Inverted Page Table
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

400

Inverted Page Table
 Advantage


Decrease the amount of memory needed
to store each page table

 Disadvantage
 The inverted page table is sorted by
physical addresses, whereas a page
reference is in logical address.
 The use of Hash Table to eliminate
lengthy table lookup time: 1HASH + 1IPT
 The use of an associate memory to hold
recently located entries.

 Difficult to implement with shared memory
401
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Segmentation
 Segmentation is a memory management
scheme that support the user view of memory:
 A logical address space is a collection of
segments with variable lengths.

Subroutine

Stack

Symbol

Sqrt

table
Main program
402

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Segmentation
 Why Segmentation?
 Paging separates the user’s view of
memory from the actual physical
memory but does not reflect the logical
units of a process!
 Pages & frames are fixed-sized, but
segments have variable sizes.

 For simplicity of representation,
<segment name, offset> Æ <segmentnumber, offset>
403
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Segmentation – Hardware Support
 Address Mapping
s
CPU

s

limit base

d

Segment
Table

limit

d

<

base

yes
d

+

Physical
Memory

no
trap
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

404

Segmentation – Hardware Support
 Implementation in Registers – limited size!
 Implementation in Memory
 Segment-table base register (STBR)
 Segment-table length register (STLR)
 Advantages & Disadvantages – Paging
 Use an associate memory (TLB) to improve the
effective memory access time !
 TLB must be flushed whenever a new segment
table is used !
a
STBR

Segment table

STLR
405

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Segmentation – Protection & Sharing
 Advantage:
 Segments are a semantically defined portion of
the program and likely to have all entries being
“homogeneous”.
 Example: Array, code, stack, data, etc.

Æ Logical units for protection !
 Sharing of code & data improves memory usage.
 Sharing occurs at the segment level.

406
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Segmentation – Protection & Sharing
 Potential Problems
 External Fragmentation
 Segments must occupy contiguous memory.
 Address referencing inside shared
segments can be a big issue:
Seg# offset
Indirect
addressing?!!!

Should all shared-code segments
have the same segment number?

 How to find the right segment number if the
number of users sharing the segments
increase! Æ Avoid reference to segment #
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

407

Segmentation – Fragmentation
 Motivation:
Segments are of variable lengths!
Æ Memory allocation is a dynamic
storage-allocation problem.
 best-fit? first-fit? worst-ft?

 External fragmentation will occur!!
 Factors, e.g., average segment sizes
Size
A byte

External
Fragmentation
Overheads increases substantially!
(base+limit “registers”)

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

408

Segmentation – Fragmentation
 Remark:
 Its external fragmentation problem is
better than that of the dynamic
partition method because segments
are likely to be smaller than the
entire process.

 Internal Fragmentation??

409
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Segmentation with Paging
 Motivation :
 Segmentation has external fragmentation.
 Paging has internal fragmentation.
 Segments are semantically defined
portions of a program.

Æ “Page” Segments !

410
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Paged Segmentation – Intel 80386
 8K Private Segments + 8K Public Segments
 Page Size = 4KB, Max Segment Size = 4GB
 Tables:
 Local Descriptor Table (LDT)
 Global Descriptor Table (GDT)

 6 microprogram segment registers for caching
Segment Offset

Selector

Logical Address

s
13

Linear Address
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

g p

sd

2

32

1

p1

p2

d

10

10

12

411

Paged Segmentation – Intel 80386
Logical Address
16

32

s+g+p

sd

Descriptor Table

:

:

Segment
Length

Segment
Base

:

Physical
address

no
Trap

:

Segment
table

+
10

p1

10

p2

Page Directory
Base Register
p1

;
p2

12

d

*Page table are limited by the segment
lengths of their segments.
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

d

f

>-

Physical
Memory

;
f

Page Directory
Page Table

412

Paging and Segmentation
 To overcome disadvantages of paging or
segmentation alone:
 Paged segments – divide segments further into
pages.
 Segment need not be in contiguous memory.

 Segmented paging – segment the page table.
 Variable size page tables.

 Address translation overheads increase!
 An entire process still needs to be in memory
at once!
Æ Virtual Memory!!
413
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Paging and Segmentation
 Considerations in Memory Management
 Hardware Support, e.g., STBR, TLB, etc.
 Performance
 Fragmentation
 Multiprogramming Levels






Relocation Constraints?
Swapping: +
Sharing?!
Protection?!
414

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Contents
1. Introduction
2. Computer-System Structures
3. Operating-System Structures
4. Processes
5. Threads
6. CPU Scheduling
7. Process Synchronization
8. Deadlocks
9. Memory Management
10. Virtual Memory
11. File Systems
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

415

Chapter 10
Virtual Memory

416

Virtual Memory
 Virtual Memory
 A technique that allows the execution
of a process that may not be
completely in memory.

 Motivation:
 An entire program in execution may
not all be needed at the same time!
 e.g. error handling routines, a large
array, certain program features, etc
417
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Virtual Memory
 Potential Benefits
 Programs can be much larger than the
amount of physical memory. Users can
concentrate on their problem programming.
 The level of multiprogramming increases
because processes occupy less physical
memory.
 Each user program may run faster because
less I/O is needed for loading or swapping
user programs.

 Implementation: demand paging,
demand segmentation (more difficult),etc.
418
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Demand Paging – Lazy
Swapping
 Process image may reside on the backing
store. Rather than swap in the entire
process image into memory, Lazy
Swapper only swap in a page when it is
needed!
 Pure Demand Paging – Pager vs Swapper
 A Mechanism required to recover from the
missing of non-resident referenced pages.
 A page fault occurs when a process
references a non-memory-resident
page.
419
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Demand Paging – Lazy
Swapping
0

CPU

p

f

d

1

d

2
3

A
B
C
D
E
F
Logical Memory

4
6
9

v
i
v
i
i
v
i
i

Page Table

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

4-A
5
6-C

valid-invalid bit

7
8

invalid page?
non-memoryresident page?

9 -F
.
.
.

420
Physical Memory

A Procedure to Handle a Page
Fault
3. Issue a ‘read”
instruction & find a
free frame
OS
2. Trap
(valid disk-resident page)
1. Reference
CPU
6. Return to
execute the
instruction
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

i
5. Reset
the Page
Table

Free
Frame

4. Bring in
the missing
page

421

A Procedure to Handle A
Page Fault
 Pure Demand Paging:
 Never bring in a page into the
memory until it is required!

 Pre-Paging
 Bring into the memory all of the
pages that “will” be needed at one
time!
 Locality of reference
422
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Hardware Support for Demand
Paging
 New Bits in the Page Table
 To indicate that a page is now in
memory or not.

 Secondary Storage
 Swap space in the backing store
 A continuous section of space in the
secondary storage for better
performance.
423
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Crucial issues
 Example 1 – Cost in restarting an
instruction
 Assembly Instruction: Add a, b, c
 Only a short job!
 Re-fetch the instruction, decode,
fetch operands, execute, save, etc
 Strategy:
 Get all pages and restart the
instruction from the beginning!
424
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Crucial Issues
 Example 2 – Block-Moving
Assembly Instruction

MVC x, y, 4
x:

 MVC x, y, 256
y:
 IBM System 360/ 370
 Characteristics
 More expensive
 “self-modifying” “operands”
 Solutions:
 Pre-load pages
 Pre-save & recover before
page-fault services

A
AB
B C Page fault!
C D Return??
D X is
destroyed

425
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Crucial Issues
 Example 3 – Addressing Mode
(R2) +
MOV (R2)+, -(R3)

Page Fault
- (R3)
When the page fault is serviced,
R2, R3 are modified!
- Undo Effects!
426

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Performance of Demand Paging
 Effective Access Time:
 ma: memory access time for paging
 p: probability of a page fault
 pft: page fault time
(1 - p) * ma + p * pft

427
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Performance of Demand Paging
 Page fault time - major components
 Components 1&3 (about 103 ns ~ 105 ns)
 Service the page-fault interrupt
 Restart the process

 Component 2 (about 25ms)
 Read in the page (multiprogramming!
However, let’s get the taste!)
 pft ≈ 25ms = 25,000,000 ns

 Effect Access Time (when ma = 100ns)
 (1-p) * 100ns + p * 25,000,000 ns
 100ns + 24,999,900ns * p
428
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Performance of Demand Paging
 Example (when ma = 100ns)
 p = 1/1000
 Effect Access Time ≈ 25,000 ns
→ Slowed down by 250 times
 How to only 10% slow-down?
110 > 100 * (1-p) + 25,000,000 * p
p < 0.0000004
p < 1 / 2,500,000

429
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Performance of Demand Paging
 How to keep the page fault rate low?
 Effective Access Time ≈ 100ns +
24,999,900ns * p

 Handling of Swap Space – A Way to
Reduce Page Fault Time (pft)
 Disk I/O to swap space is generally faster
than that to the file system.
 Preload processes into the swap space
before they start up.
 Demand paging from file system but do page
replacement to the swap space. (BSD UNIX)
430
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Process Creation
 Copy-on-Write
P1
Page
Table 1

3
4
6
1

P2
Page
Table 2

3

 Rapid Process Creation and Reducing
of New Pages for the New Process
 fork(); execve()
 Shared pages Æ copy-on-write pages
 Only the pages that are modified are
copied!

4

*
data1

6
1

page

0

1

2

*
*
*
*
ed1 ed2
3
4
5

*
* ??
ed3
6
7

::
n
431

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

* Windows 2000, Linux, Solaris 2 support this feature!

Process Creation
 Copy-on-Write
 zero-fill-on-demand
 Zero-filled pages, e.g., those for the
stack or bss.

 vfork() vs fork() with copy-on-write
 vfork() lets the sharing of the page
table and pages between the parent
and child processes.
 Where to keep the needs of copy-onwrite information for pages?
432
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Memory-Mapped Files
 File writes might not cause any disk write!
 Solaris 2 uses memory-mapped files for
open(), read(), write(), etc.
P1 VM
1
2
3
4
5
6

3
6
1
5
4
2
1 2 3 4 5 6

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Disk File

P2 VM
1
2
3
4
5
6

433

Page Replacement
 Demand paging increases the
multiprogramming level of a system by
“potentially” over-allocating memory.
 Total physical memory = 40 frames
 Run six processes of size equal to 10
frames but with only five frames. => 10
spare frames

 Most of the time, the average memory
usage is close to the physical memory
size if we increase a system’s
multiprogramming level!
434
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Page Replacement
 Q: Should we run the 7th processes?
 How if the six processes start to ask
their shares?

 What to do if all memory is in use, and
more memory is needed?
 Answers
 Kill a user process!
 But, paging should be transparent to
users?

 Swap out a process!
 Do page replacement!
435
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Page Replacement
 A Page-Fault Service
 Find the desired page on the disk!
 Find a free frame
 Select a victim and write the victim
page out when there is no free
frame!
 Read the desired page into the
selected frame.
 Update the page and frame tables, and
restart the user process.
436
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Page Replacement
Logical Memory
P1
PC

0

H

1 Load
M
2

J

3 v

0

OS

4 v

1

OS

2

D

3

H

5 v
i

3

P2

Page Table

4

M/B

i

5

J

D

2 v

6

A

E

7 v

7

E

0

A

1

B

2
3

6 v

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

B
M

437

Page Replacement
 Two page transfers per page fault if
no frame is available!
Page Table
6
4
3
7

V
V
V
V

Valid-Invalid Bit

N
N
Y
Y

Modify Bit is set by the
hardware automatically!
Modify (/Dirty) Bit! To
“eliminate” ‘swap out” =>
Reduce I/O time by one-half

438

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Page Replacement
 Two Major Pieces for Demand Paging
 Frame Allocation Algorithms
 How many frames are allocated to a
process?
 Page Replacement Algorithms
 When page replacement is required,
select the frame that is to be
replaced!
 Goal: A low page fault rate!

 Note that a bad replacement choice
does not cause any incorrect execution!
439
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Page Replacement Algorithms
 Evaluation of Algorithms
 Calculate the number of page faults on
strings of memory references, called
reference strings, for a set of algorithms

 Sources of Reference Strings
 Reference strings are generated artificially.
 Reference strings are recorded as system
traces:
 How to reduce the number of data?
440
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Page Replacement Algorithms
 Two Observations to Reduce the Number
of Data:
 Consider only the page numbers if the
page size is fixed.
 Reduce memory references into page
references
 If a page p is referenced, any immediately
following references to page p will never
cause a page fault.
 Reduce consecutive page references of
page p into one page reference.
441
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Page Replacement Algorithms
 Example
XX

XX

page# offset
0100, 0432, 0101, 0612, 0103, 0104, 0101, 0611
01, 04, 01, 06, 01, 01, 01, 06
01, 04, 01, 06, 01, 06

Does the number of page faults decrease when the
number of page frames available increases?
442
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

FIFO Algorithm


A FIFO Implementation
1. Each page is given a time stamp when it
is brought into memory.
2. Select the oldest page for replacement!

reference
7
string

0

1

2

7

7

7

0

page
frames

FIFO
queue

7

7
0

0

3

0

4

2

3

0

2

2

2

4

4

4

0

0

3

3

3

2

1

1

1

0

0

7
0
1

0
1
2

1
2
3

2
3
0

3
0
4

3

2

1

2

0

0

2

2

0

3

0
4
2

4
2
3

0

1

7

0

0

7

7

7

1

1

1

0

0

3

3

2

2

2

1

2
3
0

3
0
1

0
1
2

1
2
7

2
7
0

7
0
1
443

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

1

FIFO Algorithm
 The Idea behind FIFO
 The oldest page is unlikely to be used
again.
??Should we save the page which will be
used in the near future??

 Belady’s anomaly
 For some page-replacement algorithms,
the page fault rate may increase as the
number of allocated frames increases.
444
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

FIFO Algorithm
Run the FIFO algorithm on the following reference:
string:
1 2 3 4 1 2 5 1 2 3 4 5
3 frames

4 frames

1

1
2

1
2
3

2
3
4

3
4
1

4
1
2

1
2
5

1
2
5

1
2
5

2
5
3

5
3
4

5
3
4

1

1
2

1
2
3

1
2
3
4

1
2
3
4

1
2
3
4

2
3
4
5

3
4
5
1

4
5
1
2

5
1
2
3

1
2
3
4

2
3
4
5

Push out pages
that will be used later!
445
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Optimal Algorithm (OPT)
 Optimality
 One with the lowest page fault rate.

 Replace the page that will not be used for the
longest period of time. ÅÆ Future Prediction
reference
7
string

0

1

2

7

7

7

2

2

2

2

2

7

0

0

0

0

4

0

0

0

1

1

3

3

3

1

1

page
frames

0

3

0

next 0

4

2

3

3

2

1

2

0

1

7

0

next 7
next 1

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

0

446

1

Least-Recently-Used Algorithm
(LRU)
 The Idea:
 OPT concerns when a page is to be used!
 “Don’t have knowledge about the future”?!

 Use the history of page referencing in the
past to predict the future!
S ? SR ( SR is the reverse of S !)
447
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

LRU Algorithm
 Example
reference
7
string

0

1

2

7

7

7

2

0

0

page
frames

LRU
queue

0

0
7

0

4

2

3

0

2

4

4

4

0

1

1

7

0

0

0

0

3

3

3

0

0

1

1

3

3

2

2

2

2

2

7

1
0
7

2
1
0

4
0
3

2
4
0

3
2
4

0
3
2

0
2
1

3

3
0
2

0

0
3
2

3

3
0
2

2

2
3
0

1

1
2
3

2

2
1
3

0

0
2
1

1

1
0
2

7

7
1
0

0

1

0 1
7 0
1 7

a wrong prediction!

Remark: LRU is like OPT which “looks backward” in time.448
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

LRU Implementation – Counters
Logical
Address

CPU

p

f
d

f

Physical
Memory

A Logical Clock

p

…

cnt++

d

time

frame # v/i tag
……

Update the
“time-of-use”
field

Page
Table
for Pi
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Time of Last
Use!

Disk
449

LRU Implementation – Counters
 Overheads
 The logical clock is incremented for
every memory reference.
 Update the “time-of-use” field for each
page reference.
 Search the LRU page for replacement.
 Overflow prevention of the clock & the
maintenance of the “time-of-use” field
of each page table.
450
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

LRU Implementation – Stack
Logical
Address

CPU

p

f
d

f

Physical
Memory

Head

…

p

frame #

v/i

……

…

A LRU
Stack

d

move
Page Table
Tail
(The LRU page!)

Overheads: Stack maintenance per memory
reference ~ no search for page replacement!

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Disk
451

A Stack Algorithm
memoryresident
pages

n frames
available

⊆

memoryresident
pages

(n +1) frames
available

 Need hardware support for efficient
implementations.
 Note that LRU maintenance needs to
be done for every memory reference.
452
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

LRU Approximation Algorithms
 Motivation
 No sufficient hardware support
 Most systems provide only “reference bit”
which only indicates whether a page is
used or not, instead of their order.






Additional-Reference-Bit Algorithm
Second-Chance Algorithm
Enhanced Second Chance Algorithm
Counting-Based Page Replacement
453

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Additional-Reference-Bits Algorithm
 Motivation
 Keep a history of reference bits
1
0

01101101
10100011
…

…
0
1
reference
bit

11101010
00000001

OS shifts all
history registers right
by one bit at each
regular interval!!

one byte per page in memory
454

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Additional-Reference-Bits Algorithm
 History Registers
LRU
(smaller value!)

00000000
00000001

MRU

11111110
11111111

Not used for 8 times

Used at least once
every time

 But, how many bits per history register
should be used?
 Fast but cost-effective!
 The more bits, the better the approximation is.

455

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Second-Chance (Clock) Algorithm
Reference
Bit

Page

0

Reference
Bit

Page

0

0

0

1

0

1

0

0

0
1

1

1

 Use the reference bit
only

 Basic Data Structure:
 Circular FIFO Queue

 Basic Mechanism
 When a page is selected
…

…

…

…
1

 Motivation

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

 Take it as a victim if its
reference bit = 0
 Otherwise, clear the bit
and advance to the
next page
456

Enhanced Second-Chance
Algorithm
 Motivation:
 Consider the cost in swapping out” pages.

 4 Classes (reference bit, modify bit)
low priority
high priority






(0,0) – not recently used and not “dirty”
(0,1) – not recently used but “dirty”
(1,0) – recently used but not “dirty”
(1,1) – recently used and “dirty”

457
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Enhanced Second-Chance
Algorithm
 Use the second-chance algorithm to
replace the first page encountered in
the lowest nonempty class.
=> May have to scan the circular queue
several times before find the right page.

 Macintosh Virtual Memory
Management

458
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Counting-Based Algorithms
 Motivation:

 Count the # of references made to each
page, instead of their referencing times.

 Least Frequently Used Algorithm (LFU)
 LFU pages are less actively used pages!
 Potential Hazard: Some heavily used
pages may no longer be used !
 A Solution – Aging

 Shift counters right by one bit at each
regular interval.
459
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Counting-Based Algorithms
 Most Frequently Used Algorithm (MFU)
 Pages with the smallest number of
references are probably just brought in
and has yet to be used!

 LFU & MFU replacement schemes can
be fairly expensive!
 They do not approximate OPT very well!

460
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Page Buffering


Basic Idea
a. Systems keep a pool of free frames
b. Desired pages are first “swapped in” some
pages in the pool.
c. When the selected page (victim) is later
written out, its frame is returned to the pool.



Variation 1
a. Maintain a list of modified pages.
b. Whenever the paging device is idle, a
modified page is written out and reset its
“modify bit”.

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

461

Page Buffering
 Variation 2
a. Remember which page was in each frame of
the pool.
b. When a page fault occurs, first check
whether the desired page is there already.
 Pages which were in frames of the pool must
be “clean”.
 “Swapping-in” time is saved!

 VAX/VMS with the FIFO replacement
algorithm adopt it to improve the
performance of the FIFO algorithm.
462
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Frame Allocation – Single User
 Basic Strategy:
 User process is allocated any free frame.
 User process requests free frames from the
free-frame list.
 When the free-frame list is exhausted, page
replacement takes place.
 All allocated frames are released by the
ending process.

 Variations
 O.S. can share with users some free frames
for special purposes.
 Page Buffering - Frames to save “swapping”
time
463
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Frame Allocation – Multiple
Users
 Fixed Allocation
a. Equal Allocation
m frames, n processes Æ m/n frames per
process

b. Proportional Allocation
1. Ratios of Frames ∝ Size
S = Σ Si, Ai ∝ (Si / S) x m, where (sum <= m) &
(Ai >= minimum # of frames required)

2. Ratios of Frames ∝ Priority
Si : relative importance

3. Combinations, or others.
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

464

Frame Allocation – Multiple
Users
 Dynamic Allocation
a. Allocated frames ∝ the
multiprogramming level
b. Allocated frames ∝ Others

 The minimum number of frames
required for a process is determined
by the instruction-set architecture.
 ADD A,B,C Æ 4 frames needed
 ADD (A), (B), (C) Æ 1+2+2+2 = 7
frames, where (A) is an indirect
addressing.
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

465

Frame Allocation – Multiple
Users
 Minimum Number of Frames
(Continued)
 How many levels of indirect
addressing should be supported?
16 bits

address
0

1

direct
indirect

 It may touch every page in the logical
address space of a process
=> Virtual memory is collapsing!

 A long instruction may cross a page
boundary.
MVC

X, Y, 256 Æ 2 + 2 + 2 = 6 frames

 The spanning of the instruction and
the operands.
466
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Frame Allocation – Multiple
Users
 Global Allocation
 Processes can take frames from others. For
example, high-priority processes can
increase its frame allocation at the expense
of the low-priority processes!

 Local Allocation
 Processes can only select frames from their
own allocated frames Æ Fixed Allocation
 The set of pages in memory for a process is
affected by the paging behavior of only that
process.
467
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Frame Allocation – Multiple
Users
 Remarks
a.Global replacement generally results
in a better system throughput
b.Processes can not control their own
page fault rates such that a process
can affect each another easily.

468
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Thrashing
 Thrashing – A High Paging Activity:
 A process is thrashing if it is spending
more time paging than executing.

 Why thrashing?
 Too few frames allocated to a process!
CPU utilization

Thrashing

thrashing

under a global pagereplacement algorithm
Dispatch a new process

low CPU utilization

degree of multiprogramming
469
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Thrashing
 Solutions:
 Decrease the multiprogramming level
Æ Swap out processes!
 Use local page-replacement algorithms
 Only limit thrashing effects “locally”
 Page faults of other processes also
slow down.

 Give processes as many frames as
they need!
 But, how do you know the right number
of frames for a process?
470
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Locality Model
localityi =
{Pi,1,Pi,2,…,Pi,ni}

localityj =
{Pj,1,Pj,2,…,Pj,nj}
control flow

 A program is composed of several different
(overlapped) localities.
 Localities are defined by the program
structures and data structures (e.g., an array,
hash tables)

 How do we know that we allocate enough
frames to a process to accommodate its
current locality?
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

471

Working-Set Model
Page references
…2 6 1 5 7 7 7 7 5 1 6 2 3 4 1 2 3 4 4 4 3 4 3 4 4 4
Δ
Δ
working-set window

working-set window

t1

working-set(t1) = {1,2,5,6,7}

t2

working-set(t2) = {3,4}

 The working set is an approximation
of a program’s locality.
The minimum
allocation

Δ

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

∞

All touched pages
may cover several
localities.

472

Working-Set Model
D = ∑ working − set − sizei ≤ M
where M is the total number of
available frames.
D>M
D>M
Suspend some
processes and
swap out
their pages.

“Safe”

Extra frames
are available,
and initiate
new processes.

D≦M
473
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Working-Set Model
 The maintenance of working sets is expensive!
 Approximation by a timer and the reference bit
0
1

timer!

1
0
reference bit

……
……
……
……

shift or
copy

in-memory history

 Accuracy v.s. Timeout Interval!
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

474

Page-Fault Frequency
 Motivation
 Control thrashing directly through the
observation on the page-fault rate!
page-fault rate

increase # of frames!

upper bound
lower bound
decrease # of frames!

number of frames
*Processes are suspended and swapped out if the number of
available frames is reduced to that under the minimum needs.475
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

OS Examples – NT
 Virtual Memory – Demand Paging with
Clustering
 Clustering brings in more pages
surrounding the faulting page!

 Working Set
 A Min and Max bounds for a process
 Local page replacement when the max
number of frames are allocated.

 Automatic working-set trimming reduces
allocated frames of a process to its min
when the system threshold on the
available frames is reached.
476
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

OS Examples – Solaris
 Process pageout first clears
the reference bit of all pages
to 0 and then later returns all
pages with the reference bit =
0 to the system (handspread).

8192
fastscan

 4HZ Æ 100HZ when desfree
is reached!

100
slowscan
minfree desfree

lotsfree

 Swapping starts when
desfree fails for 30s.

 pageout runs for every
request to a new page when
minfree is reached.
477
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Other Considerations
 Pre-Paging
 Bring into memory at one time all the
pages that will be needed!
ready
processes

 Issue

swapped
out
resumed

suspended
processes

Do pre-paging if the working set is known!

Pre-Paging Cost

Cost of Page Fault Services

Not every page in the working set will be used!
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

478

Other Considerations
 Page Size
Better
Page Size
Resolution
for Locality & small
large
p d
Internal
9)~16,384B(212)
512B(2
Fragmentation

Smaller Page
Table Size &
Better I/O
Efficiency

 Trends - Large Page Size
∵ The CPU speed and the memory capacity
grow much faster than the disk speed!
479
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Other Considerations
 TLB Reach
 TLB-Entry-Number * Page-Size

 Wish
 The working set is stored in the TLB!
 Solutions
 Increase the page size
 Have multiple page sizes –
UltraSparc II (8KB - 4MB) + Solaris 2
(8KB or 4MB)
480
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Other Considerations
 Inverted Page Table
 The objective is to reduce the
amount of physical memory for page
tables, but they are needed when a
page fault occurs!
 More page faults for page tables will
occur!!!

481
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Other Considerations
 Program Structure
 Motivation – Improve the system performance
by an awareness of the underlying demand
paging.

128
words

A(1,1)
A(1,2)
.
.
A(1,128)

var A: array [1..128,1..128] of integer;
for j:=1 to 128
for i:=1 to 128
A(i,j):=0
A(2,1)
A(128,1)
A(2,2)
A(128,2)
128x128 page
.
.
……
faults if the
.
.
process has
A(2,128)
A(128,128)
less than 128
frames!!
128 pages
482

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Other Considerations
 Program Structures:
 Data Structures
 Locality: stack, hash table, etc.
 Search speed, # of memory references, # of
pages touched, etc.

 Programming Language
 Lisp, PASCAL, etc.

 Compiler & Loader
 Separate code and data
 Pack inter-related routines into the same page
 Routine placement (across page boundary?)
483
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

I/O Interlock

buffer

Physical Memory

Drive

• DMA gets the following
information of the buffer:
• Base Address in
Memory
• Chunk Size
• Could the buffer-residing
pages be swapped out?

484

* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

I/O Interlock
 Solutions
 I/O Device ÅÆ System Memory ÅÆ
User Memory
 Extra Data Copying!!

 Lock pages into memory
 The lock bit of a page-faulting page is set
until the faulting process is dispatched!
 Lock bits might never be turned off!
 Multi-user systems usually take locks as
“hints” only!
485
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Real-Time Processing
Predictable
Behavior

Virtual memory
introduces unexpected,
long-term delays in the
execution of a program.

 Solution:
 Go beyond locking hints Î Allow
privileged users to require pages being
locked into memory!
486
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

Demand Segmentation
 Motivation
 Segmentation captures better the logical
structure of a process!
 Demand paging needs a significant
amount of hardware!

 Mechanism
 Like demand paging!
 However, compaction may be needed!
 Considerable overheads!
487
* All rights reserved, Tei-Wei Kuo, National Taiwan University, 2004.

