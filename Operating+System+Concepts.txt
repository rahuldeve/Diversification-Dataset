STUDENT’S MANUAL
TO ACCOMPANY

OPERATING
SYSTEM
CONCEPTS
SEVENTH EDITION

ABRAHAM SILBERSCHATZ
Yale University
PETER BAER GALVIN
Corporate Technologies
GREG GAGNE
Westminster College

Preface
This volume is a student’s manual for the Seventh Edition of Operating System
Concepts, by Abraham Silberschatz, Peter Baer Galvin, and Greg Gagne. It
consists of answers to the exercises in the parent text.
Although we have tried to produce a student’s manual that will aid all of
the users of our book as much as possible, there can always be improvements
(improved answers, additional questions, sample test questions, programming
projects, alternative orders of presentation of the material, additional references, and so on). We invite you, both instructors and students, to help us
improve this manual. If you have better solutions to the exercises or other
items that would be of use with Operating System Concepts, we invite you to
send them to us for consideration in later editions of this manual. All contributions will, of course, be properly credited to their contributor.
Internet electronic mail should be addressed to os-book@cs.yale.edu.
Physical mail may be sent to Avi Silberschatz, Yale University, Department of
Computer Science, 51 Prospect Street, P.O. box 208285, New Haven, CT 06520,
USA.
A. S.
P. B. G
G. G.

iii

Contents
Chapter 1

Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1

Chapter 2

Operating-System Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5

Chapter 3

Processes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9

Chapter 4

Threads . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11

Chapter 5

CPU Scheduling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13

Chapter 6

Process Synchronization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17

Chapter 7

Deadlocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

Chapter 8

Memory Management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25

Chapter 9

Virtual Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29

Chapter 10

File-Systems Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35

Chapter 11

File-Systems Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39

Chapter 12

Mass Storage Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43

Chapter 13

I/O Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51

Chapter 14

Protection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55

Chapter 15

Security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57

Chapter 16

Distributed System Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59

Chapter 17

Distributed File Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63

Chapter 18

Distributed Coordination . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65

Chapter 19

Real-Time Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67

Chapter 20

Multimedia Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69

Chapter 21

The Linux System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71

Chapter 22

Windows XP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79

Chapter 23

Influential Operating Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83

v

1

CHAPTER

Introduction

Exercises
1.1

What are the three main purposes of an operating system?
Answer:
• To provide an environment for a computer user to execute programs
on computer hardware in a convenient and efficient manner.
• To allocate the separate resources of the computer as needed to
solve the problem given. The allocation process should be as fair
and efficient as possible.
• As a control program it serves two major functions: (1) supervision
of the execution of user programs to prevent errors and improper
use of the computer, and (2) management of the operation and
control of I/O devices.

1.2

What are the main differences between operating systems for mainframe
computers and personal computers?
Answer: Generally, operating systems for batch systems have simpler
requirements than for personal computers. Batch systems do not have
to be concerned with interacting with a user as much as a personal
computer. As a result, an operating system for a PC must be concerned
with response time for an interactive user. Batch systems do not have
such requirements. A pure batch system also may have not to handle
time sharing, whereas an operating system must switch rapidly between
different jobs.

1.3

List the four steps that are necessary to run a program on a completely
dedicated machine.
Answer:
1

2

Chapter 1 Introduction

a. Reserve machine time.
b. Manually load program into memory.
c. Load starting address and begin execution.
d. Monitor and control execution of program from console.
1.4

We have stressed the need for an operating system to make efficient use
of the computing hardware. When is it appropriate for the operating
system to forsake this principle and to “waste” resources? Why is such
a system not really wasteful?
Answer: Single-user systems should maximize use of the system for
the user. A GUI might “waste” CPU cycles, but it optimizes the user’s
interaction with the system.

1.5

What is the main difficulty that a programmer must overcome in writing
an operating system for a real-time environment?
Answer: The main difficulty is keeping the operating system within
the fixed time constraints of a real-time system. If the system does not
complete a task in a certain time frame, it may cause a breakdown
of the entire system it is running. Therefore when writing an operating
system for a real-time system, the writer must be sure that his scheduling
schemes don’t allow response time to exceed the time constraint.

1.6

Consider the various definitions of operating system. Consider whether
the operating system should include applications such as Web browsers
and mail programs. Argue both that it should and that it should not, and
support your answer.
Answer: Point. Applications such as web browsers and email tools are
performing an increasingly important role in modern desktop computer
systems. To fulfill this role, they should be incorporated as part of the
operating system. By doing so, they can provide better performance
and better integration with the rest of the system. In addition, these
important applications can have the same look-and-feel as the operating
system software.
Counterpoint. The fundamental role of the operating system is to manage system resources such as the CPU, memory, I/O devices, etc. In addition, it’s role is to run software applications such as web browsers and
email applications. By incorporating such applications into the operating
system, we burden the operating system with additional functionality.
Such a burden may result in the operating system performing a less-thansatisfactory job at managing system resources. In addition, we increase
the size of the operating system thereby increasing the likelihood of
system crashes and security violations.

1.7

How does the distinction between kernel mode and user mode function
as a rudimentary form of protection (security) system?
Answer: The distinction between kernel mode and user mode provides a rudimentary form of protection in the following manner. Certain
instructions could be executed only when the CPU is in kernel mode.
Similarly, hardware devices could be accessed only when the program
is executing in kernel mode. Control over when interrupts could be en-

Exercises

3

abled or disabled is also possible only when the CPU is in kernel mode.
Consequently, the CPU has very limited capability when executing in
user mode, thereby enforcing protection of critical resources.
1.8

Which of the following instructions should be privileged?
a. Set value of timer.
b. Read the clock.
c. Clear memory.
d. Issue a trap instruction.
e. Turn off interrupts.
f. Modify entries in device-status table.
g. Switch from user to kernel mode.
h. Access I/O device.
Answer: The following operations need to be privileged: Set value of
timer, clear memory, turn off interrupts, modify entries in device-status
table, access I/O device. The rest can be performed in user mode.

1.9

Some early computers protected the operating system by placing it in
a memory partition that could not be modified by either the user job
or the operating system itself. Describe two difficulties that you think
could arise with such a scheme.
Answer: The data required by the operating system (passwords, access
controls, accounting information, and so on) would have to be stored
in or passed through unprotected memory and thus be accessible to
unauthorized users.

1.10

Some CPUs provide for more than two modes of operation. What are
two possible uses of these multiple modes?
Answer: Although most systems only distinguish between user and
kernel modes, some CPUs have supported multiple modes. Multiple
modes could be used to provide a finer-grained security policy. For
example, rather than distinguishing between just user and kernel mode,
you could distinguish between different types of user mode. Perhaps
users belonging to the same group could execute each other’s code. The
machine would go into a specified mode when one of these users was
running code. When the machine was in this mode, a member of the
group could run code belonging to anyone else in the group.
Another possibility would be to provide different distinctions within
kernel code. For example, a specific mode could allow USB device drivers
to run. This would mean that USB devices could be serviced without
having to switch to kernel mode, thereby essentially allowing USB device
drivers to run in a quasi-user/kernel mode.

1.11

Timers could be used to compute the current time. Provide a short description of how this could be accomplished.
Answer: A program could use the following approach to compute the
current time using timer interrupts. The program could set a timer for

4

Chapter 1 Introduction

some time in the future and go to sleep. When it is awakened by the
interrupt, it could update its local state, which it is using to keep track
of the number of interrupts it has received thus far. It could then repeat
this process of continually setting timer interrupts and updating its local
state when the interrupts are actually raised.
1.12

Is the Internet a LAN or a WAN?
Answer: The Internet is a WAN as the various computers are located
at geographically different places and are connected by long-distance
network links.

OperatingSystem
Structures

2

CHAPTER

Exercises
2.1

What is the purpose of system calls?
Answer: System calls allow user-level processes to request services of
the operating system.

2.2

What are the five major activities of an operating system in regard to
process management?
Answer:
a. The creation and deletion of both user and system processes
b. The suspension and resumption of processes
c. The provision of mechanisms for process synchronization
d. The provision of mechanisms for process communication
e. The provision of mechanisms for deadlock handling

2.3

What are the three major activities of an operating system in regard to
memory management?
Answer:
a. Keep track of which parts of memory are currently being used
and by whom.
b. Decide which processes are to be loaded into memory when memory space becomes available.
c. Allocate and deallocate memory space as needed.

2.4

What are the three major activities of an operating system in regard to
secondary-storage management?
Answer:
5

6

Chapter 2 Operating-System Structures

• Free-space management.
• Storage allocation.
• Disk scheduling.
2.5

What is the purpose of the command interpreter? Why is it usually
separate from the kernel?
Answer: It reads commands from the user or from a file of commands
and executes them, usually by turning them into one or more system
calls. It is usually not part of the kernel since the command interpreter
is subject to changes.

2.6

What system calls have to be executed by a command interpreter or shell
in order to start a new process?
Answer: In Unix systems, a fork system call followed by an exec system
call need to be performed to start a new process. The fork call clones the
currently executing process, while the exec call overlays a new process
based on a different executable over the calling process.

2.7

What is the purpose of system programs?
Answer: System programs can be thought of as bundles of useful
system calls. They provide basic functionality to users so that users do
not need to write their own programs to solve common problems.

2.8

What is the main advantage of the layered approach to system design?
What are the disadvantages of using the layered approach?
Answer: As in all cases of modular design, designing an operating
system in a modular way has several advantages. The system is easier
to debug and modify because changes affect only limited sections of
the system rather than touching all sections of the operating system.
Information is kept only where it is needed and is accessible only within
a defined and restricted area, so any bugs affecting that data must be
limited to a specific module or layer.

2.9

List five services provided by an operating system. Explain how each
provides convenience to the users. Explain also in which cases it would
be impossible for user-level programs to provide these services.
Answer:
a. Program execution. The operating system loads the contents (or
sections) of a file into memory and begins its execution. A userlevel program could not be trusted to properly allocate CPU time.
b. I/O operations. Disks, tapes, serial lines, and other devices must
be communicated with at a very low level. The user need only
specify the device and the operation to perform on it, while the
system converts that request into device- or controller-specific
commands. User-level programs cannot be trusted to access only
devices they should have access to and to access them only when
they are otherwise unused.
c. File-system manipulation. There are many details in file creation,
deletion, allocation, and naming that users should not have to perform. Blocks of disk space are used by files and must be tracked.

Exercises

7

Deleting a file requires removing the name file information and
freeing the allocated blocks. Protections must also be checked to
assure proper file access. User programs could neither ensure adherence to protection methods nor be trusted to allocate only free
blocks and deallocate blocks on file deletion.
d. Communications. Message passing between systems requires
messages to be turned into packets of information, sent to the network controller, transmitted across a communications medium,
and reassembled by the destination system. Packet ordering and
data correction must take place. Again, user programs might not
coordinate access to the network device, or they might receive
packets destined for other processes.
e. Error detection. Error detection occurs at both the hardware and
software levels. At the hardware level, all data transfers must be
inspected to ensure that data have not been corrupted in transit.
All data on media must be checked to be sure they have not
changed since they were written to the media. At the software
level, media must be checked for data consistency; for instance,
whether the number of allocated and unallocated blocks of storage
match the total number on the device. There, errors are frequently
process-independent (for instance, the corruption of data on a
disk), so there must be a global program (the operating system)
that handles all types of errors. Also, by having errors processed
by the operating system, processes need not contain code to catch
and correct all the errors possible on a system.
2.10

What is the purpose of system calls?
Answer: System calls allow user-level processes to request services of
the operating system.

2.11

What are the main advantages of the microkernel approach to system
design?
Answer: Benefits typically include the following (a) adding a new
service does not require modifying the kernel, (b) it is more secure as
more operations are done in user mode than in kernel mode, and (c)
a simpler kernel design and functionality typically results in a more
reliable operating system.

2.12

Why do some systems store the operating system in firmware, and others
on disk?
Answer: For certain devices, such as handheld PDAs and cellular telephones, a disk with a file system may be not be available for the device.
In this situation, the operating system must be stored in firmware.

2.13

How could a system be designed to allow a choice of operating systems
to boot from? What would the bootstrap program need to do?
Answer: Consider a system that would like to run both Windows
XP and three different distributions of Linux (e.g., RedHat, Debian, and
Mandrake). Each operating system will be stored on disk. During system
boot-up, a special program (which we will call the boot manager) will
determine which operating system to boot into. This means that rather

8

Chapter 2 Operating-System Structures

initially booting to an operating system, the boot manager will first run
during system startup. It is this boot manager that is responsible for
determining which system to boot into. Typically boot managers must
be stored at certain locations of the hard disk to be recognized during
system startup. Boot managers often provide the user with a selection of
systems to boot into; boot managers are also typically designed to boot
into a default operating system if no choice is selected by the user.

3

CHAPTER

Processes

Exercises
3.1

Palm OS provides no means of concurrent processing. Discuss three
major complications that concurrent processing adds to an operating
system.
Answer:
a. A method of time sharing must be implemented to allow each
of several processes to have access to the system. This method
involves the preemption of processes that do not voluntarily give
up the CPU (by using a system call, for instance) and the kernel
being reentrant (so more than one process may be executing kernel
code concurrently).
b. Processes and system resources must have protections and must
be protected from each other. Any given process must be limited
in the amount of memory it can use and the operations it can
perform on devices like disks.
c. Care must be taken in the kernel to prevent deadlocks between
processes, so processes aren’t waiting for each other’s allocated
resources.

3.2

The Sun UltraSPARC processor has multiple register sets. Describe the
actions of a context switch if the new context is already loaded into
one of the register sets. What else must happen if the new context is in
memory rather than in a register set and all the register sets are in use?
Answer: The CPU current-register-set pointer is changed to point to the
set containing the new context, which takes very little time. If the context
is in memory, one of the contexts in a register set must be chosen and be
moved to memory, and the new context must be loaded from memory
9

10

Chapter 3 Processes

into the set. This process takes a little more time than on systems with
one set of registers, depending on how a replacement victim is selected.
3.3

When a process creates a new process using the fork() operation, which
of the following state is shared between the parent process and the child
process?
a. Stack
b. Heap
c. Shared memory segments
Answer: Only the shared memory segments are shared between the
parent process and the newly forked child process. Copies of the stack
and the heap are made for the newly created process.

3.4

Again considering the RPC mechanism, consider the “exactly once” semantic. Does the algorithm for implementing this semantic execute correctly even if the “ACK” message back to the client is lost due to a network
problem? Describe the sequence of messages and whether "exactly once"
is still preserved.
Answer: The “exactly once” semantics ensure that a remore procedure
will be executed exactly once and only once. The general algorithm for
ensuring this combines an acknowledgment (ACK) scheme combined
with timestamps (or some other incremental counter that allows the
server to distinguish between duplicate messages).
The general strategy is for the client to send the RPC to the server along
with a timestamp. The client will also start a timeout clock. The client
will then wait for one of two occurrences: (1) it will receive an ACK from
the server indicating that the remote procedure was performed, or (2) it
will time out. If the client times out, it assumes the server was unable
to perform the remote procedure so the client invokes the RPC a second
time, sending a later timestamp. The client may not receive the ACK for
one of two reasons: (1) the original RPC was never received by the server,
or (2) the RPC was correctly received —and performed —by the server
but the ACK was lost. In situation (1), the use of ACKs allows the server
ultimately to receive and perform the RPC. In situation (2), the server will
receive a duplicate RPC and it will use the timestamp to identify it as a
duplicate so as not to perform the RPC a second time. It is important to
note that the server must send a second ACK back to the client to inform
the client the RPC has been performed.

3.5

Assume that a distributed system is susceptible to server failure. What
mechanisms would be required to guarantee the “exactly once” semantics for execution of RPCs?
Answer: The server should keep track in stable storage (such as a
disk log) information regarding what RPC operations were received,
whether they were successfully performed, and the results associated
with the operations. When a server crash takes place and a RPC message
is received, the server can check whether the RPC had been previously
performed and therefore guarantee “exactly once” semanctics for the
execution of RPCs.

4

CHAPTER

Threads

Exercises
4.1

Provide two programming examples in which multithreading provides
better performance than a single-threaded solution.
Answer: (1) A Web server that services each request in a separate thread.
2) (A parallelized application such as matrix multiplication where (different parts of the matrix may be worked on in parallel. (3) An (interactive GUI program such as a debugger where a thread is used (to monitor
user input, another thread represents the running (application, and a
third thread monitors performance.

4.2

What are two differences between user-level threads and kernel-level
threads? Under what circumstances is one type better than the other?
Answer: (1) User-level threads are unknown by the kernel, whereas the
kernel is aware of kernel threads. (2) On systems using either M:1 or M:N
mapping, user threads are scheduled by the thread library and the kernel
schedules kernel threads. (3) Kernel threads need not be associated with
a process whereas every user thread belongs to a process. Kernel threads
are generally more expensive to maintain than user threads as they must
be represented with a kernel data structure.

4.3

Describe the actions taken by a kernel to context switch between kernellevel threads.
Answer: Context switching between kernel threads typically requires
saving the value of the CPU registers from the thread being switched out
and restoring the CPU registers of the new thread being scheduled.

4.4

What resources are used when a thread is created? How do they differ
from those used when a process is created?
Answer: Because a thread is smaller than a process, thread creation
typically uses fewer resources than process creation. Creating a process
11

12

Chapter 4 Threads

requires allocating a process control block (PCB), a rather large data structure. The PCB includes a memory map, list of open files, and environment variables. Allocating and managing the memory map is typically
the most time-consuming activity. Creating either a user or kernel thread
involves allocating a small data structure to hold a register set, stack, and
priority.
4.5

Assume an operating system maps user-level threads to the kernel using the many-to-many model and the mapping is done through LWPs.
Furthermore, the system allows developers to create real-time threads.
Is it necessary to bind a real-time thread to an LWP? Explain.
Answer: Yes. Timing is crucial to real-time applications. If a thread is
marked as real-time but is not bound to an LWP, the thread may have
to wait to be attached to an LWP before running. Consider if a real-time
thread is running (is attached to an LWP) and then proceeds to block (i.e.
must perform I/O, has been preempted by a higher-priority real-time
thread, is waiting for a mutual exclusion lock, etc.) While the real-time
thread is blocked, the LWP it was attached to has been assigned to another
thread. When the real-time thread has been scheduled to run again, it
must first wait to be attached to an LWP. By binding an LWP to a realtime thread you are ensuring the thread will be able to run with minimal
delay once it is scheduled.

4.6

A Pthread program that performs the summation function was provided
in Section 4.3.1. Rewrite this program in Java.
Answer: Please refer to the supporting Web site for source code solution.

5

CHAPTER

CPU Scheduling

Exercises
5.1

A CPU scheduling algorithm determines an order for the execution of its
scheduled processes. Given n processes to be scheduled on one processor, how many possible different schedules are there? Give a formula in
terms of n.
Answer: n! (n factorial = n × n – 1 × n – 2 × ... × 2 × 1).

5.2

Define the difference between preemptive and nonpreemptive scheduling.
Answer: Preemptive scheduling allows a process to be interrupted
in the midst of its execution, taking the CPU away and allocating it
to another process. Nonpreemptive scheduling ensures that a process
relinquishes control of the CPU only when it finishes with its current
CPU burst.

5.3

Suppose that the following processes arrive for execution at the times
indicated. Each process will run the listed amount of time. In answering
the questions, use nonpreemptive scheduling and base all decisions on
the information you have at the time the decision must be made.
Process
P1
P2
P3

Arrival Time
0.0
0.4
1.0

Burst Time
8
4
1

a. What is the average turnaround time for these processes with the
FCFS scheduling algorithm?
13

14

Chapter 5 CPU Scheduling

b. What is the average turnaround time for these processes with the
SJF scheduling algorithm?
c. The SJF algorithm is supposed to improve performance, but notice
that we chose to run process P1 at time 0 because we did not know
that two shorter processes would arrive soon. Compute what the
average turnaround time will be if the CPU is left idle for the first 1
unit and then SJF scheduling is used. Remember that processes P1
and P2 are waiting during this idle time, so their waiting time may
increase. This algorithm could be known as future-knowledge
scheduling.
Answer:
a. 10.53
b. 9.53
c. 6.86
Remember that turnaround time is finishing time minus arrival time, so
you have to subtract the arrival times to compute the turnaround times.
FCFS is 11 if you forget to subtract arrival time.
5.4

What advantage is there in having different time-quantum sizes on different levels of a multilevel queueing system?
Answer: Processes that need more frequent servicing, for instance,
interactive processes such as editors, can be in a queue with a small time
quantum. Processes with no need for frequent servicing can be in a queue
with a larger quantum, requiring fewer context switches to complete the
processing, and thus making more efficient use of the computer.

5.5

Many CPU-scheduling algorithms are parameterized. For example, the
RR algorithm requires a parameter to indicate the time slice. Multilevel
feedback queues require parameters to define the number of queues,
the scheduling algorithms for each queue, the criteria used to move
processes between queues, and so on.
These algorithms are thus really sets of algorithms (for example, the
set of RR algorithms for all time slices, and so on). One set of algorithms
may include another (for example, the FCFS algorithm is the RR algorithm
with an infinite time quantum). What (if any) relation holds between the
following pairs of sets of algorithms?
a. Priority and SJF
b. Multilevel feedback queues and FCFS
c. Priority and FCFS
d. RR and SJF
Answer:
a. The shortest job has the highest priority.
b. The lowest level of MLFQ is FCFS.

Exercises

15

c. FCFS gives the highest priority to the job having been in existence
the longest.
d. None.
5.6

Suppose that a scheduling algorithm (at the level of short-term CPU
scheduling) favors those processes that have used the least processor
time in the recent past. Why will this algorithm favor I/O-bound programs and yet not permanently starve CPU-bound programs?
Answer: It will favor the I/O-bound programs because of the relatively
short CPU burst request by them; however, the CPU-bound programs
will not starve because the I/O-bound programs will relinquish the CPU
relatively often to do their I/O.

5.7

Distinguish between PCS and SCS scheduling.
Answer: PCS scheduling is done local to the process. It is how the
thread library schedules threads onto available LWPs. SCS scheduling is
the situation where the operating system schedules kernel threads. On
systems using either many-to-one or many-to-many, the two scheduling
models are fundamentally different. On systems using one-to-one, PCS
and SCS are the same.

5.8

Assume an operating system maps user-level threads to the kernel using
the many-to-many model where the mapping is done through the use
of LWPs. Furthermore, the system allows program developers to create
real-time threads. Is it necessary to bind a real-time thread to an LWP?
Answer: Yes, otherwise a user thread may have to compete for an
available LWP prior to being actually scheduled. By binding the user
thread to an LWP, there is no latency while waiting for an available LWP;
the real-time user thread can be scheduled immediately.

6

CHAPTER

Process
Synchronization

Exercises
6.1

In Section 6.4 we mentioned that disabling interrupts frequently could
affect the system’s clock. Explain why it could and how such effects
could be minimized.
Answer: The system clock is updated at every clock interrupt. If interrupts were disabled —particularly for a long period of time —it is
possible the system clock could easily lose the correct time. The system clock is also used for scheduling purposes. For example, the time
quantum for a process is expressed as a number of clock ticks. At every
clock interrupt, the scheduler determines if the time quantum for the
currently running process has expired. If clock interrupts were disabled,
the scheduler could not accurately assign time quantums. This effect can
be minimized by disabling clock interrupts for only very short periods.

6.2

The Cigarette-Smokers Problem. Consider a system with three smoker processes and one agent process. Each smoker continuously rolls a cigarette
and then smokes it. But to roll and smoke a cigarette, the smoker needs
three ingredients: tobacco, paper, and matches. One of the smoker processes has paper, another has tobacco, and the third has matches. The
agent has an infinite supply of all three materials. The agent places
two of the ingredients on the table. The smoker who has the remaining
ingredient then makes and smokes a cigarette, signaling the agent on
completion. The agent then puts out another two of the three ingredients, and the cycle repeats. Write a program to synchronize the agent
and the smokers using Java synchronization.
Answer: Please refer to the supporting Web site for source code solution.

6.3

Give the reasons why Solaris, Windows XP, and Linux implement multiple locking mechanisms. Describe the circumstances under which they
17

18

Chapter 6 Process Synchronization

use spinlocks, mutexes, semaphores, adaptive mutexes, and condition
variables. In each case, explain why the mechanism is needed.
Answer: These operating systems provide different locking mechanisms depending on the application developers’ needs. Spinlocks are
useful for multiprocessor systems where a thread can run in a busy-loop
(for a short period of time) rather than incurring the overhead of being
put in a sleep queue. Mutexes are useful for locking resources. Solaris 2
uses adaptive mutexes, meaning that the mutex is implemented with a
spin lock on multiprocessor machines. Semaphores and condition variables are more appropriate tools for synchronization when a resource
must be held for a long period of time, since spinning is inefficient for a
long duration.
6.4

Explain the differences, in terms of cost, among the three storage types
volatile, nonvolatile, and stable.
Answer: Volatile storage refers to main and cache memory and is very
fast. However, volatile storage cannot survive system crashes or powering down the system. Nonvolatile storage survives system crashes and
powered-down systems. Disks and tapes are examples of nonvolatile
storage. Recently, USB devices using erasable program read-only memory (EPROM) have appeared providing nonvolatile storage. Stable storage refers to storage that technically can never be lost as there are redundant backup copies of the data (usually on disk).

6.5

Explain the purpose of the checkpoint mechanism. How often should
checkpoints be performed? Describe how the frequency of checkpoints
affects:
• System performance when no failure occurs
• The time it takes to recover from a system crash
• The time it takes to recover from a disk crash
Answer: A checkpoint log record indicates that a log record and its
modified data has been written to stable storage and that the transaction
need not to be redone in case of a system crash. Obviously, the more often
checkpoints are performed, the less likely it is that redundant updates
will have to be performed during the recovery process.
• System performance when no failure occurs—If no failures occur,
the system must incur the cost of performing checkpoints that are
essentially unnecessary. In this situation, performing checkpoints
less often will lead to better system performance.
• The time it takes to recover from a system crash—The existence of a
checkpoint record means that an operation will not have to be
redone during system recovery. In this situation, the more often
checkpoints were performed, the faster the recovery time is from a
system crash.
• The time it takes to recover from a disk crash—The existence of a
checkpoint record means that an operation will not have to be
redone during system recovery. In this situation, the more often

Exercises

19

checkpoints were performed, the faster the recovery time is from a
disk crash.
6.6

Explain the concept of transaction atomicity.
Answer: A transaction is a series of read and write operations upon
some data followed by a commit operation. If the series of operations in
a transaction cannot be completed, the transaction must be aborted and
the operations that did take place must be rolled back. It is important
that the series of operations in a transaction appear as one indivisible
operation to ensure the integrity of the data being updated. Otherwise,
data could be compromised if operations from two (or more) different
transactions were intermixed.

6.7

Show that some schedules are possible under the two-phase locking
protocol but not possible under the timestamp protocol, and vice versa.
Answer: A schedule that is allowed in the two-phase locking protocol
but not in the timestamp protocol is:
step
1
2
3
4
5
6
7
8
9

T0
lock-S(A)
read(A)

T1

Precedence

lock-X(B)
write(B)
unlock(B)
lock-S(B)
read(B)
unlock(A)
unlock(B)

T1 → T0

This schedule is not allowed in the timestamp protocol because at step
7, the W-timestamp of B is 1.
A schedule that is allowed in the timestamp protocol but not in the
two-phase locking protocol is:
step
1
2
3
4
5

T0
write(A)

T1

T2

write(A)
write(A)
write(B)
write(B)

This schedule cannot have lock instructions added to make it legal under
two-phase locking protocol because T1 must unlock (A) between steps 2
and 3, and must lock (B) between steps 4 and 5.
6.8

The wait() statement in all Java program examples was part of a while
loop. Explain why you would always need to use a while statement
when using wait() and why you would never use an if statement.
Answer: This is an important issue to emphasize! Java only provides
anonymous notification—you cannot notify a certain thread that a cer-

20

Chapter 6 Process Synchronization

tain condition is true. When a thread is notified, it is its responsibility
to re-check the condition that it is waiting for. If a thread did not recheck the condition, it might have received the notification without the
condition having been met.

7

CHAPTER

Deadlocks

Exercises
7.1

List three examples of deadlocks that are not related to a computersystem environment.
Answer:
• Two cars crossing a single-lane bridge from opposite directions.
• A person going down a ladder while another person is climbing up
the ladder.
• Two trains traveling toward each other on the same track.
• Two carpenters who must pound nails. There is a single hammer
and a single bucket of nails. Deadlock occurs if one carpenter has
the hammer and the other carpenter has the nails.

7.2

Suppose that a system is in an unsafe state. Show that it is possible for
the processes to complete their execution without entering a deadlock
state.
Answer: An unsafe state may not necessarily lead to deadlock, it just
means that we cannot guarantee that deadlock will not occur. Thus, it
is possible that a system in an unsafe state may still allow all processes
to complete without deadlock occurring. Consider the situation where
a system has 12 resources allocated among processes P0 , P1 , and P2 . The
resources are allocated according to the following policy:
P0
P1
P2

Max
10
4
9

Current
5
2
3

Need
5
2
6
21

22

Chapter 7 Deadlocks
for (int i = 0; i < n; i++) {
// first find a thread that can finish
for (int j = 0; j < n; j++) {
if (!finish[j]) {
boolean temp = true;
for (int k = 0; k < m; k++) {
if (need[j][k] > work[k])
temp = false;
}
if (temp) { // if this thread can finish
finish[j] = true;
for (int x = 0; x < m; x++)
work[x] += work[j][x];
}
}
}
}
Figure 7.1 Banker’s algorithm safety algorithm.

Currently there are two resources available. This system is in an unsafe state as process P1 could complete, thereby freeing a total of four
resources. But we cannot guarantee that processes P0 and P2 can complete. However, it is possible that a process may release resources before
requesting any further. For example, process P2 could release a resource,
thereby increasing the total number of resources to five. This allows process P0 to complete, which would free a total of nine resources, thereby
allowing process P2 to complete as well.
7.3

Prove that the safety algorithm presented in Section 7.5.3 requires an
order of m × n2 operations.
Answer:
Figure 7.1 provides Java code that implement the safety algorithm of
the banker’s algorithm (the complete implementation of the banker’s
algorithm is available with the source code download).
As can be seen, the nested outer loops—both of which loop through n
times—provide the n2 performance. Within these outer loops are two
sequential inner loops which loop m times. The big-oh of this algorithm
is therefore O(m × n2 ).

7.4

Consider a computer system that runs 5,000 jobs per month with no
deadlock-prevention or deadlock-avoidance scheme. Deadlocks occur
about twice per month, and the operator must terminate and rerun about
10 jobs per deadlock. Each job is worth about $2 (in CPU time), and the
jobs terminated tend to be about half-done when they are aborted.
A systems programmer has estimated that a deadlock-avoidance
algorithm (like the banker’s algorithm) could be installed in the system
with an increase in the average execution time per job of about 10 percent.
Since the machine currently has 30-percent idle time, all 5,000 jobs per
month could still be run, although turnaround time would increase by
about 20 percent on average.

Exercises

23

a. What are the arguments for installing the deadlock-avoidance
algorithm?
b. What are the arguments against installing the deadlock-avoidance
algorithm?
Answer: An argument for installing deadlock avoidance in the system
is that we could ensure deadlock would never occur. In addition, despite
the increase in turnaround time, all 5,000 jobs could still run.
An argument against installing deadlock avoidance software is that
deadlocks occur infrequently and they cost little when they do occur.
7.5

Can a system detect that some of its processes are starving? If you answer
“yes,” explain how it can. If you answer “no,” explain how the system
can deal with the starvation problem.
Answer: Starvation is a difficult topic to define as it may mean different
things for different systems. For the purposes of this question, we will
define starvation as the situation whereby a process must wait beyond
a reasonable period of time —perhaps indefinitely—before receiving a
requested resource. One way of detecting starvation would be to first
identify a period of time — T —that is considered unreasonable. When a
process requests a resource, a timer is started. If the elapsed time exceeds
T, then the process is considered to be starved.
One strategy for dealing with starvation would be to adopt a policy
where resources are assigned only to the process that has been waiting
the longest. For example, if process Pa has been waiting longer for resource X than process Pb , the request from process Pb would be deferred
until process Pa ’s request has been satisfied.
Another strategy would be less strict than what was just mentioned. In
this scenario, a resource might be granted to a process that has waited less
than another process, providing that the other process is not starving.
However, if another process is considered to be starving, its request
would be satisfied first.

7.6

Consider the following resource-allocation policy. Requests and releases
for resources are allowed at any time. If a request for resources cannot
be satisfied because the resources are not available, then we check any
processes that are blocked, waiting for resources. If they have the desired
resources, then these resources are taken away from them and are given
to the requesting process. The vector of resources for which the process
is waiting is increased to include the resources that were taken away.
For example, consider a system with three resource types and the
vector Available initialized to (4,2,2). If process P0 asks for (2,2,1), it gets
them. If P1 asks for (1,0,1), it gets them. Then, if P0 asks for (0,0,1), it
is blocked (resource not available). If P2 now asks for (2,0,0), it gets the
available one (1,0,0) and one that was allocated to P0 (since P0 is blocked).
P0 ’s Allocation vector goes down to (1,2,1) and its Need vector goes up to
(1,0,1).
a. Can deadlock occur? If you answer “yes”, give an example. If you
answer “no,” specify which necessary condition cannot occur.
b. Can indefinite blocking occur? Explain your answer.

24

Chapter 7 Deadlocks

Answer:
a. Deadlock cannot occur because preemption exists.
b. Yes. A process may never acquire all the resources it needs if they
are continuously preempted by a series of requests such as those
of process C.
7.7

Suppose that you have coded the deadlock-avoidance safety algorithm
and now have been asked to implement the deadlock-detection algorithm. Can you do so by simply using the safety algorithm code and
redefining Ma xi = Wa itingi + Alloca tioni , where Wa itingi is a vector
specifying the resources process i is waiting for, and Alloca tioni is as
defined in Section 7.5? Explain your answer.
Answer:
Yes. The Max vector represents the maximum request a process may
make. When calculating the safety algorithm we use the Need matrix,
which represents Max — Allocation. Another way to think of this is Max
= Need + Allocation. According to the question, the Waiting matrix fulfills
a role similar to the Need matrix, therefore Max = Waiting + Allocation.

7.8

Is it possible to have a deadlock involving only one single process?
Explain your answer.
Answer: No. This follows directly from the hold-and-wait condition.

8

CHAPTER

Memory
Management

Exercises
8.1

Name two differences between logical and physical addresses.
Answer: A logical address does not refer to an actual existing address;
rather, it refers to an abstract address in an abstract address space. Contrast this with a physical address that refers to an actual physical address
in memory. A logical address is generated by the CPU and is translated
into a physical address by the memory management unit(MMU). Therefore, physical addresses are generated by the MMU.

8.2

Consider a system in which a program can be separated into two parts:
code and data. The CPU knows whether it wants an instruction (instruction fetch) or data (data fetch or store). Therefore, two base–limit
register pairs are provided: one for instructions and one for data. The
instruction base–limit register pair is automatically read-only, so programs can be shared among different users. Discuss the advantages and
disadvantages of this scheme.
Answer: The major advantage of this scheme is that it is an effective
mechanism for code and data sharing. For example, only one copy of an
editor or a compiler needs to be kept in memory, and this code can be
shared by all processes needing access to the editor or compiler code.
Another advantage is protection of code against erroneous modification.
The only disadvantage is that the code and data must be separated,
which is usually adhered to in a compiler-generated code.

8.3

Why are page sizes always powers of 2?
Answer: Recall that paging is implemented by breaking up an address
into a page and offset number. It is most efficient to break the address
into X page bits and Y offset bits, rather than perform arithmetic on
the address to calculate the page number and offset. Because each bit
25

26

Chapter 8 Memory Management

position represents a power of 2, splitting an address between bits results
in a page size that is a power of 2.
8.4

Consider a logical address space of eight pages of 1024 words each,
mapped onto a physical memory of 32 frames.
a. How many bits are there in the logical address?
b. How many bits are there in the physical address?
Answer:
a. Logical address: 13 bits
b. Physical address: 15 bits

8.5

What is the effect of allowing two entries in a page table to point to the
same page frame in memory? Explain how this effect could be used to
decrease the amount of time needed to copy a large amount of memory
from one place to another. What effect would updating some byte on the
one page have on the other page?
Answer: By allowing two entries in a page table to point to the same
page frame in memory, users can share code and data. If the code is reentrant, much memory space can be saved through the shared use of large
programs such as text editors, compilers, and database systems. “Copying” large amounts of memory could be effected by having different
page tables point to the same memory location.
However, sharing of nonreentrant code or data means that any user
having access to the code can modify it and these modifications would
be reflected in the other user’s “copy.”

8.6

Describe a mechanism by which one segment could belong to the address
space of two different processes.
Answer: Since segment tables are a collection of base–limit registers,
segments can be shared when entries in the segment table of two different
jobs point to the same physical location. The two segment tables must
have identical base pointers, and the shared segment number must be
the same in the two processes.

8.7

Sharing segments among processes without requiring the same segment
number is possible in a dynamically linked segmentation system.
a. Define a system that allows static linking and sharing of segments
without requiring that the segment numbers be the same.
b. Describe a paging scheme that allows pages to be shared without
requiring that the page numbers be the same.
Answer: Both of these problems reduce to a program being able to
reference both its own code and its data without knowing the segment or
page number associated with the address. MULTICS solved this problem
by associating four registers with each process. One register had the
address of the current program segment, another had a base address for
the stack, another had a base address for the global data, and so on. The
idea is that all references have to be indirect through a register that maps
to the current segment or page number. By changing these registers, the

Exercises

27

same code can execute for different processes without the same page or
segment numbers.
8.8

In the IBM/370, memory protection is provided through the use of keys.
A key is a 4-bit quantity. Each 2K block of memory has a key (the storage
key) associated with it. The CPU also has a key (the protection key)
associated with it. A store operation is allowed only if both keys are
equal, or if either is zero. Which of the following memory-management
schemes could be used successfully with this hardware?
a. Bare machine
b. Single-user system
c. Multiprogramming with a fixed number of processes
d. Multiprogramming with a variable number of processes
e. Paging
f. Segmentation
Answer:
a. Protection not necessary, set system key to 0.
b. Set system key to 0 when in supervisor mode.
c. Region sizes must be fixed in increments of 2k bytes, allocate key
with memory blocks.
d. Same as above.
e. Frame sizes must be in increments of 2k bytes, allocate key with
pages.
f. Segment sizes must be in increments of 2k bytes, allocate key with
segments.

9

CHAPTER

Virtual
Memory

Exercises
9.1

Under what circumstances do page faults occur? Describe the actions
taken by the operating system when a page fault occurs.
Answer: A page fault occurs when an access to a page that has not been
brought into main memory takes place. The operating system verifies
the memory access, aborting the program if it is invalid. If it is valid, a
free frame is located and I/O is requested to read the needed page into
the free frame. Upon completion of I/O, the process table and page table
are updated and the instruction is restarted.

9.2

Assume that you have a page-reference string for a process with m
frames (initially all empty). The page-reference string has length p; n
distinct page numbers occur in it. Answer these questions for any pagereplacement algorithms:
a. What is a lower bound on the number of page faults?
b. What is an upper bound on the number of page faults?
Answer:
a. n
b. p

9.3

Which of the following programming techniques and structures are
“good” for a demand-paged environment ? Which are “not good”? Explain your answers.
a. Stack
b. Hashed symbol table
29

30

Chapter 9 Virtual Memory

c. Sequential search
d. Binary search
e. Pure code
f. Vector operations
g. Indirection
Answer:
a. Stack—good.
b. Hashed symbol table —not good.
c. Sequential search—good.
d. Binary search—not good.
e. Pure code —good.
f. Vector operations—good.
g. Indirection—not good.
9.4

Consider the following page-replacement algorithms. Rank these algorithms on a five-point scale from “bad” to “perfect” according to
their page-fault rate. Separate those algorithms that suffer from Belady’s
anomaly from those that do not.
a. LRU replacement
b. FIFO replacement
c. Optimal replacement
d. Second-chance replacement
Answer:
Rank
1
2
3
4

Algorithm
Optimal
LRU

Second-chance
FIFO

Suffer from Belady’s anomaly
no
no
yes
yes

9.5

When virtual memory is implemented in a computing system, there are
certain costs associated with the technique and certain benefits. List the
costs and the benefits. Is it possible for the costs to exceed the benefits?
If it is, what measures can be taken to ensure that this does not happen?
Answer: The costs are additional hardware and slower access time. The
benefits are good utilization of memory and larger logical address space
than physical address space.

9.6

An operating system supports a paged virtual memory, using a central
processor with a cycle time of 1 microsecond. It costs an additional 1
microsecond to access a page other than the current one. Pages have 1000

Exercises

31

words, and the paging device is a drum that rotates at 3000 revolutions
per minute and transfers 1 million words per second. The following
statistical measurements were obtained from the system:
• 1 percent of all instructions executed accessed a page other than the
current page.
• Of the instructions that accessed another page, 80 percent accessed a
page already in memory.
• When a new page was required, the replaced page was modified 50
percent of the time.
Calculate the effective instruction time on this system, assuming that the
system is running one process only and that the processor is idle during
drum transfers.
Answer:

effective access time

=
=
=

9.7

0.99 × (1 ␮sec + 0.008 × (2 ␮sec)
+ 0.002 × (10,000 ␮sec + 1,000 ␮sec)
+ 0.001 × (10,000 ␮sec + 1,000 ␮sec)
(0.99 + 0.016 + 22.0 + 11.0) ␮sec
34.0 ␮sec

Consider the two-dimensional array A:
int A[][] = new int[100][100];
where A[0][0] is at location 200, in a paged memory system with pages
of size 200. A small process is in page 0 (locations 0 to 199) for manipulating the matrix; thus, every instruction fetch will be from page
0.
For three page frames, how many page faults are generated by the following array-initialization loops, using LRU replacement, and assuming
page frame 1 has the process in it, and the other two are initially empty?
a. for (int j = 0; j < 100; j++)
for (int i = 0; i < 100; i++)
A[i][j] = 0;
b. for (int i = 0; i < 100; i++)
for (int j = 0; j < 100; j++)
A[i][j] = 0;
Answer:
a. 50
b. 5,000

9.8

Consider the following page reference string:
1, 2, 3, 4, 2, 1, 5, 6, 2, 1, 2, 3, 7, 6, 3, 2, 1, 2, 3, 6.

32

Chapter 9 Virtual Memory

How many page faults would occur for the following replacement algorithms, assuming one, two, three, four, five, six, or seven frames?
Remember all frames are initially empty, so your first unique pages will
all cost one fault each.
• LRU replacement
• FIFO replacement
• Optimal replacement
Answer:
Number of frames
1
2
3
4
5
6
7

LRU

FIFO

20
18
15
10
8
7
7

20
18
16
14
10
10
7

Optimal
20
15
11
8
7
7
7

9.9

Suppose that you want to use a paging algorithm that requires a reference bit (such as second-chance replacement or working-set model), but
the hardware does not provide one. Sketch how you could simulate a
reference bit even if one were not provided by the hardware, or explain
why it is not possible to do so. If it is possible, calculate what the cost
would be.
Answer: You can use the valid/invalid bit supported in hardware to
simulate the reference bit. Initially set the bit to invalid. On first reference
a trap to the operating system is generated. The operating system will
set a software bit to 1 and reset the valid/invalid bit to valid.

9.10

You have devised a new page-replacement algorithm that you think may
be optimal. In some contorted test cases, Belady’s anomaly occurs. Is the
new algorithm optimal? Explain your answer.
Answer: No. An optimal algorithm will not suffer from Belady’s
anomaly because —by definition—an optimal algorithm replaces the
page that will not be used for the longest time. Belady’s anomaly occurs
when a page-replacement algorithm evicts a page that will be needed
in the immediate future. An optimal algorithm would not have selected
such a page.

9.11

Segmentation is similar to paging but uses variable-sized “pages.” Define two segment-replacement algorithms based on FIFO and LRU pagereplacement schemes. Remember that since segments are not the same
size, the segment that is chosen to be replaced may not be big enough
to leave enough consecutive locations for the needed segment. Consider
strategies for systems where segments cannot be relocated, and those
for systems where they can.
Answer:

Exercises

33

a. FIFO. Find the first segment large enough to accommodate the incoming segment. If relocation is not possible and no one segment
is large enough, select a combination of segments whose memories are contiguous, which are “closest to the first of the list”
and which can accommodate the new segment. If relocation is
possible, rearrange the memory so that the first N segments large
enough for the incoming segment are contiguous in memory. Add
any leftover space to the free-space list in both cases.
b. LRU. Select the segment that has not been used for the longest
period of time and that is large enough, adding any leftover space
to the free space list. If no one segment is large enough, select
a combination of the “oldest” segments that are contiguous in
memory (if relocation is not available) and that are large enough.
If relocation is available, rearrange the oldest N segments to be
contiguous in memory and replace those with the new segment.
9.12

Consider a demand-paged computer system where the degree of multiprogramming is currently fixed at four. The system was recently measured to determine utilization of CPU and the paging disk. The results
are one of the following alternatives. For each case, what is happening?
Can the degree of multiprogramming be increased to increase the CPU
utilization? Is the paging helping?
a. CPU utilization 13 percent; disk utilization 97 percent
b. CPU utilization 87 percent; disk utilization 3 percent
c. CPU utilization 13 percent; disk utilization 3 percent
Answer:
a. Thrashing is occurring.
b. CPU utilization is sufficiently high to leave things alone, and increase degree of multiprogramming.
c. Increase the degree of multiprogramming.

9.13

We have an operating system for a machine that uses base and limit
registers, but we have modified the machine to provide a page table.
Can the page tables be set up to simulate base and limit registers? How
can they be, or why can they not be?
Answer: The page table can be set up to simulate base and limit registers
provided that the memory is allocated in fixed-size segments. In this
way, the base of a segment can be entered into the page table and the
valid/invalid bit used to indicate that portion of the segment as resident
in the memory. There will be some problem with internal fragmentation.

10

CHAPTER

File-System
Interface

Exercises
10.1

Some systems automatically delete all user files when a user logs off or
a job terminates, unless the user explicitly requests that they be kept;
other systems keep all files unless the user explicitly deletes them.
Discuss the relative merits of each approach.
Answer: Deleting all files not specifically saved by the user has the
advantage of minimizing the file space needed for each user by not
saving unwanted or unnecessary files. Saving all files unless specifically
deleted is more secure for the user in that it is not possible to lose files
inadvertently by forgetting to save them.

10.2

Why do some systems keep track of the type of a file, while others leave
it to the user or simply do not implement multiple file types? Which
system is “better?”
Answer: Some systems allow different file operations based on the
type of the file (for instance, an ascii file can be read as a stream while a
database file can be read via an index to a block). Other systems leave
such interpretation of a file’s data to the process and provide no help in
accessing the data. The method that is “better” depends on the needs
of the processes on the system, and the demands the users place on the
operating system. If a system runs mostly database applications, it may
be more efficient for the operating system to implement a databasetype file and provide operations, rather than making each program
implement the same thing (possibly in different ways). For generalpurpose systems it may be better to only implement basic file types to
keep the operating system size smaller and allow maximum freedom
to the processes on the system.
35

36

Chapter 10 File-System Interface

10.3

Similarly, some systems support many types of structures for a file’s
data, while others simply support a stream of bytes. What are the
advantages and disadvantages?
Answer: An advantage of having the system support different file
structures is that the support comes from the system; individual applications are not required to provide the support. In addition, if the
system provides the support for different file structures, it can implement the support presumably more efficiently than an application.
The disadvantage of having the system provide support for defined file
types is that it increases the size of the system. In addition, applications
that may require different file types other than what is provided by the
system may not be able to run on such systems.
An alternative strategy is for the operating system to define no support
for file structures and instead treat all files as a series of bytes. This is
the approach taken by UNIX systems. The advantage of this approach
is that it simplifies the operating system support for file systems, as the
system no longer has to provide the structure for different file types.
Furthermore, it allows applications to define file structures, thereby alleviating the situation where a system may not provide a file definition
required for a specific application.

10.4

Could you simulate a multilevel directory structure with a single-level
directory structure in which arbitrarily long names can be used? If your
answer is yes, explain how you can do so, and contrast this scheme with
the multilevel directory scheme. If your answer is no, explain what
prevents your simulation’s success. How would your answer change
if file names were limited to seven characters?
Answer: If arbitrarily long names can be used then it is possible to
simulate a multilevel directory structure. This can be done, for example,
by using the character “.” to indicate the end of a subdirectory. Thus, for
example, the name jim.java.F1 specifies that F1 is a file in subdirectory
java which in turn is in the root directory jim.
If file names were limited to seven characters, then the above scheme
could not be utilized and thus, in general, the answer is no. The next best
approach in this situation would be to use a specific file as a symbol
table (directory) to map arbitrarily long names (such as jim.java.F1)
into shorter arbitrary names (such as XX00743), which are then used
for actual file access.

10.5

Explain the purpose of the open() and close() operations.
Answer:
• The open() operation informs the system that the named file is
about to become active.
• The close() operation informs the system that the named file is
no longer in active use by the user who issued the close operation.

10.6

Give an example of an application in which data in a file should be
accessed in the following order:
a. Sequentially

Exercises

37

b. Randomly
Answer:
a. Print the content of the file.
b. Print the content of record i. This record can be found using
hashing or index techniques.
10.7

In some systems, a subdirectory can be read and written by an authorized user, just as ordinary files can be.
a. Describe the protection problems that could arise.
b. Suggest a scheme for dealing with each of the protection problems you named in part a.
Answer:
a. One piece of information kept in a directory entry is file location.
If a user could modify this location, then he could access other
files defeating the access-protection scheme.
b. Do not allow the user to directly write onto the subdirectory.
Rather, provide system operations to do so.

10.8

Consider a system that supports 5000 users. Suppose that you want to
allow 4990 of these users to be able to access one file.
a. How would you specify this protection scheme in UNIX?
b. Could you suggest another protection scheme that can be used
more effectively for this purpose than the scheme provided by
UNIX?
Answer:
a. There are two methods for achieving this:
1. Create an access control list with the names of all 4990
users.
2. Put these 4990 users in one group and set the group access
accordingly. This scheme cannot always be implemented
since user groups are restricted by the system.
b. The universal access to files applies to all users unless their name
appears in the access-control list with different access permission. With this scheme you simply put the names of the remaining ten users in the access control list but with no access
privileges allowed.

10.9

Researchers have suggested that, instead of having an access list associated with each file (specifying which users can access the file, and how),
we should have a user control list associated with each user (specifying
which files a user can access, and how). Discuss the relative merits of
these two schemes.
Answer:

38

Chapter 10 File-System Interface

• File control list. Since the access control information is concentrated
in one single place, it is easier to change access control information
and this requires less space.
• User control list. This requires less overhead when opening a file.

11

CHAPTER

File-System
Implementation

Exercises
11.1

Consider a file currently consisting of 100 blocks. Assume that the
file control block (and the index block, in the case of indexed allocation) is already in memory. Calculate how many disk I/O operations
are required for contiguous, linked, and indexed (single-level) allocation strategies, if, for one block, the following conditions hold. In the
contiguous-allocation case, assume that there is no room to grow in the
beginning, but there is room to grow in the end. Assume that the block
information to be added is stored in memory.
a. The block is added at the beginning.
b. The block is added in the middle.
c. The block is added at the end.
d. The block is removed from the beginning.
e. The block is removed from the middle.
f. The block is removed from the end.
Answer:

a.
b.
c.
d.
e.
f.

Contiguous
201
101
1
198
98
0

Linked
1
52
3
1
52
100

Indexed
1
1
1
0
0
0
39

40

Chapter 11 File-System Implementation

11.2

What problems could occur if a system allowed a file system to be
mounted simultaneously at more than one location?
Answer: There would be multiple paths to the same file, which could
confuse users or encourage mistakes (deleting a file with one path
deletes the file in all the other paths).

11.3

Why must the bit map for file allocation be kept on mass storage, rather
than in main memory?
Answer: In case of system crash (memory failure) the free-space list
would not be lost as it would be if the bit map had been stored in main
memory.

11.4

Consider a system that supports the strategies of contiguous, linked,
and indexed allocation. What criteria should be used in deciding which
strategy is best utilized for a particular file?
Answer:
• Contiguous—if file is usually accessed sequentially, if file is
relatively small.
• Linked —if file is large and usually accessed sequentially.
• Indexed —if file is large and usually accessed randomly.

11.5

One problem with contiguous allocation is that the user must preallocate enough space for each file. If the file grows to be larger than the
space allocated for it, special actions must be taken. One solution to
this problem is to define a file structure consisting of an initial contiguous area (of a specified size). If this area is filled, the operating
system automatically defines an overflow area that is linked to the initial contiguous area. If the overflow area is filled, another overflow area
is allocated. Compare this implementation of a file with the standard
contiguous and linked implementations.
Answer: This method requires more overhead then the standard contiguous allocation. It requires less overhead than the standard linked
allocation.

11.6

How do caches help improve performance? Why do systems not use
more or larger caches if they are so useful?
Answer: Caches allow components of differing speeds to communicate
more efficiently by storing data from the slower device, temporarily,
in a faster device (the cache). Caches are, almost by definition, more
expensive than the device they are caching for, so increasing the number
or size of caches would increase system cost.

11.7

Why is it advantageous for the user for an operating system to dynamically allocate its internal tables? What are the penalties to the operating
system for doing so?
Answer: Dynamic tables allow more flexibility in system use growth —
tables are never exceeded, avoiding artificial use limits. Unfortunately,
kernel structures and code are more complicated, so there is more
potential for bugs. The use of one resource can take away more system
resources (by growing to accommodate the requests) than with static
tables.

Exercises

11.8

41

Explain how the VFS layer allows an operating system easily to support
multiple types of file systems.
Answer: VFS introduces a layer of indirection in the file system implementation. In many ways, it is similar to object-oriented programming
techniques. System calls can be made generically (independent of file
system type). Each file system type provides its function calls and data
structures to the VFS layer. A system call is translated into the proper
specific functions for the target file system at the VFS layer. The calling
program has no file-system-specific code, and the upper levels of the
system call structures likewise are file system-independent. The translation at the VFS layer turns these generic calls into file-system-specific
operations.

Mass
Storage
Structure

12

CHAPTER

Exercises
12.1

The accelerating seek described in Exercise 12.3 is typical of hard-disk
drives. By contrast, floppy disks (and many hard disks manufactured
before the mid-1980s) typically seek at a fixed rate. Suppose that the
disk in Exercise 12.3 has a constant-rate seek rather than a constantacceleration seek, so the seek time is of the form t = x + yL, where t
is the time in milliseconds and L is the seek distance. Suppose that the
time to seek to an adjacent cylinder is 1 millisecond, as before, and is
0.5 milliseconds for each additional cylinder.
a. Write an equation for this seek time as a function of the seek
distance.
b. Using the seek-time function from part a, calculate the total seek
time for each of the schedules in Exercise 12.2. Is your answer
the same as it was for Exercise 12.3(c)?
c. What is the percentage speedup of the fastest schedule over FCFS
in this case?
Answer:
a. t = 0.95 + 0.05L
b. FCFS 362.60; SSTF 95.80; SCAN 497.95; LOOK 174.50; C-SCAN 500.15;
(and C-LOOK 176.70). SSTF is still the winner, and LOOK is the
runner-up.
c. (362.60 − 95.80)/362.60 = 0.74 The percentage speedup of SSTF
over FCFS is 74%, with respect to the seek time. If we include the
overhead of rotational latency and data transfer, the percentage
speedup will be less.
43

44

Chapter 12 Mass-Storage Structure

12.2

Is disk scheduling, other than FCFS scheduling, useful in a single-user
environment? Explain your answer.
Answer: In a single-user environment, the I/O queue usually is empty.
Requests generally arrive from a single process for one block or for a
sequence of consecutive blocks. In these cases, FCFS is an economical
method of disk scheduling. But LOOK is nearly as easy to program
and will give much better performance when multiple processes are
performing concurrent I/O, such as when a Web browser retrieves data
in the background while the operating system is paging and another
application is active in the foreground.

12.3

Explain why SSTF scheduling tends to favor middle cylinders over the
innermost and outermost cylinders.
Answer: The center of the disk is the location having the smallest
average distance to all other tracks. Thus the disk head tends to move
away from the edges of the disk. Here is another way to think of it. The
current location of the head divides the cylinders into two groups. If
the head is not in the center of the disk and a new request arrives, the
new request is more likely to be in the group that includes the center
of the disk; thus, the head is more likely to move in that direction.

12.4

Why is rotational latency usually not considered in disk scheduling?
How would you modify SSTF, SCAN, and C-SCAN to include latency
optimization?
Answer: Most disks do not export their rotational position information
to the host. Even if they did, the time for this information to reach the
scheduler would be subject to imprecision and the time consumed by
the scheduler is variable, so the rotational position information would
become incorrect. Further, the disk requests are usually given in terms
of logical block numbers, and the mapping between logical blocks and
physical locations is very complex.

12.5

How would use of a RAM disk affect your selection of a disk-scheduling
algorithm? What factors would you need to consider? Do the same
considerations apply to hard-disk scheduling, given that the file system
stores recently used blocks in a buffer cache in main memory?
Answer: Disk scheduling attempts to reduce the overhead time of
disk head positioning. Since a RAM disk has uniform access times,
scheduling is largely unnecessary. The comparison between RAM disk
and the main memory disk-cache has no implications for hard-disk
scheduling because we schedule only the buffer cache misses, not the
requests that find their data in main memory.

12.6

Why is it important to balance file system I/O among the disks and
controllers on a system in a multitasking environment?
Answer: A system can perform only at the speed of its slowest bottleneck. Disks or disk controllers are frequently the bottleneck in modern
systems as their individual performance cannot keep up with that of
the CPU and system bus. By balancing I/O among disks and controllers,
neither an individual disk nor a controller is overwhelmed, so that
bottleneck is avoided.

Exercises

45

12.7

What are the tradeoffs involved in rereading code pages from the file
system versus using swap space to store them?
Answer: If code pages are stored in swap space, they can be transferred
more quickly to main memory (because swap space allocation is tuned
for faster performance than general file system allocation). Using swap
space can require startup time if the pages are copied there at process
invocation rather than just being paged out to swap space on demand.
Also, more swap space must be allocated if it is used for both code and
data pages.

12.8

Is there any way to implement truly stable storage? Explain your answer.
Answer: Truly stable storage would never lose data. The fundamental
technique for stable storage is to maintain multiple copies of the data,
so that if one copy is destroyed, some other copy is still available for
use. But for any scheme, we can imagine a large enough disaster that
all copies are destroyed.

12.9

The term “fast wide SCSI-II” denotes a SCSI bus that operates at a data
rate of 20 megabytes per second when it moves a packet of bytes between the host and a device. Suppose that a fast wide SCSI-II disk drive
spins at 7200 RPM, has a sector size of 512 bytes, and holds 160 sectors
per track.
a. Estimate the sustained transfer rate of this drive in megabytes
per second.
b. Suppose that the drive has 7000 cylinders, 20 tracks per cylinder,
a head switch time (from one platter to another) of 0.5 millisecond, and an adjacent cylinder seek time of 2 milliseconds. Use
this additional information to give an accurate estimate of the
sustained transfer rate for a huge transfer.
c. Suppose that the average seek time for the drive is 8 milliseconds.
Estimate the I/Os per second and the effective transfer rate for
a random-access workload that reads individual sectors that are
scattered across the disk.
d. Calculate the random-access I/Os per second and transfer rate
for I/O sizes of 4 kilobytes, 8 kilobytes, and 64 kilobytes.
e. If multiple requests are in the queue, a scheduling algorithm such
as SCAN should be able to reduce the average seek distance. Suppose that a random-access workload is reading 8-kilobyte pages,
the average queue length is 10, and the scheduling algorithm
reduces the average seek time to 3 milliseconds. Now calculate
the I/Os per second and the effective transfer rate of the drive.
Answer:
a. The disk spins 120 times per second, and each spin transfers a
track of 80 KB. Thus, the sustained transfer rate can be approximated as 9600 KB/s.

46

Chapter 12 Mass-Storage Structure

b. Suppose that 100 cylinders is a huge transfer. The transfer rate is
total bytes divided by total time. Bytes: 100 cyl * 20 trk/cyl * 80
KB/trk, i.e., 160,000 KB. Time: rotation time + track switch time +
cylinder switch time. Rotation time is 2000 trks/120 trks per sec,
i.e., 16.667 s. Track switch time is 19 switch per cyl * 100 cyl * 0.5
ms, i.e., 950 ms. Cylinder switch time is 99 * 2 ms, i.e., 198 ms.
Thus, the total time is 16.667 + 0.950 + 0.198, i.e., 17.815 s. (We
are ignoring any initial seek and rotational latency, which might
add about 12 ms to the schedule, i.e. 0.1%.) Thus the transfer rate
is 8981.2 KB/s. The overhead of track and cylinder switching is
about 6.5%.
c. The time per transfer is 8 ms to seek + 4.167 ms average rotational
latency + 0.052 ms (calculated from 1/(120 trk per second * 160
sector per trk)) to rotate one sector past the disk head during
reading. We calculate the transfers per second as 1/(0.012219),
i.e., 81.8. Since each transfer is 0.5 KB, the transfer rate is 40.9
KB/s.
d. We ignore track and cylinder crossings for simplicity. For reads of
size 4 KB, 8 KB, and 64 KB, the corresponding I/Os per second are
calculated from the seek, rotational latency, and rotational transfer time as in the previous item, giving (respectively) 1/(0.0126),
1/(0.013), and 1/(0.019). Thus we get 79.4, 76.9, and 52.6 transfers per second, respectively. Transfer rates are obtained from 4,
8, and 64 times these I/O rates, giving 318 KB/s, 615 KB/s, and
3366 KB/s, respectively.
e. From 1/(3+4.167+0.83) we obtain 125 I/Os per second. From 8
KB per I/O we obtain 1000 KB/s.
12.10

More than one disk drive can be attached to a SCSI bus. In particular,
a fast wide SCSI-II bus (see Exercise 12.9) can be connected to at most
15 disk drives. Recall that this bus has a bandwidth of 20 megabytes
per second. At any time, only one packet can be transferred on the bus
between some disk’s internal cache and the host. However, a disk can
be moving its disk arm while some other disk is transferring a packet
on the bus. Also, a disk can be transferring data between its magnetic
platters and its internal cache while some other disk is transferring a
packet on the bus. Considering the transfer rates that you calculated
for the various workloads in Exercise 12.9, discuss how many disks can
be used effectively by one fast wide SCSI-II bus.
Answer:
For 8 KB random I/Os on a lightly loaded disk, where the random access
time is calculated to be about 13 ms (see Exercise 12.9), the effective
transfer rate is about 615 MB/s. In this case, 15 disks would have an
aggregate transfer rate of less than 10 MB/s, which should not saturate
the bus. For 64 KB random reads to a lightly loaded disk, the transfer
rate is about 3.4 MB/s, so five or fewer disk drives would saturate the
bus. For 8 KB reads with a large enough queue to reduce the average
seek to 3 ms, the transfer rate is about 1 MB/s, so the bus bandwidth
may be adequate to accommodate 15 disks.

Exercises

47

12.11

Remapping of bad blocks by sector sparing or sector slipping could
influence performance. Suppose that the drive in Exercise 12.9 has a
total of 100 bad sectors at random locations and that each bad sector is
mapped to a spare that is located on a different track, but within the
same cylinder. Estimate the number of I/Os per second and the effective transfer rate for a random-access workload consisting of 8-kilobyte
reads, with a queue length of 1 (that is, the choice of scheduling algorithm is not a factor). What is the effect of a bad sector on performance?
Answer: Since the disk holds 22,400,000 sectors, the probability of
requesting one of the 100 remapped sectors is very small. An example
of a worst-case event is that we attempt to read, say, an 8 KB page, but
one sector from the middle is defective and has been remapped to the
worst possible location on another track in that cylinder. In this case,
the time for the retrieval could be 8 ms to seek, plus two track switches
and two full rotational latencies. It is likely that a modern controller
would read all the requested good sectors from the original track before
switching to the spare track to retrieve the remapped sector and thus
would incur only one track switch and rotational latency. So the time
would be 8 ms seek + 4.17 ms average rotational latency + 0.05 ms
track switch + 8.3 ms rotational latency + 0.83 ms read time (8 KBis 16
sectors, 1/10 of a track rotation). Thus, the time to service this request
would be 21.8 ms, giving an I/O rate of 45.9 requests per second and
an effective bandwidth of 367 KB/s. For a severely time-constrained
application this might matter, but the overall impact in the weighted
average of 100 remapped sectors and 22.4 million good sectors is nil.

12.12

In a disk jukebox, what would be the effect of having more open files
than the number of drives in the jukebox?
Answer: Two bad outcomes could result. One possibility is starvation
of the applications that issue blocking I/Os to tapes that are not mounted
in drives. Another possibility is thrashing, as the jukebox is commanded
to switch tapes after every I/O operation.

12.13

If magnetic hard disks eventually have the same cost per gigabyte as do
tapes, will tapes become obsolete, or will they still be needed? Explain
your answer.
Answer: Tapes are easily removable, so they are useful for off-site
backups and for bulk transfer of data (by sending cartridges). As a
rule, a magnetic hard disk is not a removable medium.

12.14

It is sometimes said that tape is a sequential-access medium, whereas
magnetic disk is a random-access medium. In fact, the suitability of
a storage device for random access depends on the transfer size. The
term streaming transfer rate denotes the data rate for a transfer that
is underway, excluding the effect of access latency. By contrast, the
effective transfer rate is the ratio of total bytes per total seconds, including
overhead time such as the access latency.
Suppose that, in a computer, the level-2 cache has an access latency
of 8 nanoseconds and a streaming transfer rate of 800 megabytes per
second, the main memory has an access latency of 60 nanoseconds and
a streaming transfer rate of 80 megabytes per second, the magnetic disk

48

Chapter 12 Mass-Storage Structure

has an access latency of 15 millisecond and a streaming transfer rate of
5 megabytes per second, and a tape drive has an access latency of 60
seconds and a streaming transfer rate of 2 megabytes per seconds.
a. Random access causes the effective transfer rate of a device to
decrease, because no data are transferred during the access time.
For the disk described, what is the effective transfer rate if an
average access is followed by a streaming transfer of 512 bytes,
8 kilobytes, 1 megabyte, and 16 megabytes?
b. The utilization of a device is the the ratio of effective transfer
rate to streaming transfer rate. Calculate the utilization of the
disk drive for random access that performs transfers in each of
the four sizes given in part a.
c. Suppose that a utilization of 25 percent (or higher) is considered
acceptable. Using the performance figures given, compute the
smallest transfer size for disk that gives acceptable utilization.
d. Complete the following sentence: A disk is a random-access device for transfers larger than
bytes, and is a sequentialaccess device for smaller transfers.
e. Compute the minimum transfer sizes that give acceptable utilization for cache, memory, and tape.
f. When is a tape a random-access device, and when is it a sequentialaccess device?
Answer:
a. For 512 bytes, the effective transfer rate is calculated as follows.
ETR = transfer size/transfer time.
If X is transfer size, then transfer time is ((X/STR) + latency).
Transfer time is 15ms + (512B/5MB per second) = 15.0097ms.
Effective transfer rate is therefore 512B/15.0097ms = 33.12 KB/sec.
ETR for 8KB = .47MB/sec.
ETR for 1MB = 4.65MB/sec.
ETR for 16MB = 4.98MB/sec.
b. Utilization of the device for 512B = 33.12 KB/sec / 5MB/sec =
.0064 = .64
For 8KB = 9.4%.
For 1MB = 93%.
For 16MB = 99.6%.
c. Calculate .25 = ETR/STR, solving for transfer size X.
STR = 5MB, so 1.25MB/S = ETR.
1.25MB/S * ((X/5) + .015) = X.
.25X + .01875 = X.
X = .025MB.
d. A disk is a random-access device for transfers larger than K bytes
(where K > disk block size), and is a sequential-access device for
smaller transfers.

Exercises

49

e. Calculate minimum transfer size for acceptable utilization of
cache memory:
STR = 800MB, ETR = 200, latency = 8 * 10−9 .
200 (XMB/800 + 8 X 10−9 ) = XMB.
.25XMB + 1600 * 10−9 = XMB.
X = 2.24 bytes.
Calculate for memory:
STR = 80MB, ETR = 20, L = 60 * 10−9 .
20 (XMB/80 + 60 * 10−9 ) = XMB.
.25XMB + 1200 * 10−9 = XMB.
X = 1.68 bytes.
Calculate for tape:
STR = 2MB, ETR = .5, L = 60s.
.5 (XMB/2 + 60) = XMB.
.25XMB + 30 = XMB.
X = 40MB.
f. It depends upon how it is being used. Assume we are using
the tape to restore a backup. In this instance, the tape acts as a
sequential-access device where we are sequentially reading the
contents of the tape. As another example, assume we are using
the tape to access a variety of records stored on the tape. In this
instance, access to the tape is arbitrary and hence considered
random.
12.15

Suppose that we agree that 1 kilobyte is 1,024 bytes, 1 megabyte is
1,0242 bytes, and 1 gigabyte is 1,0243 bytes. This progression continues
through terabytes, petabytes, and exabytes (1,0246 ). There are currently
several new proposed scientific projects that plan to record and store a
few exabytes of data during the next decade. To answer the following
questions, you will need to make a few reasonable assumptions; state
the assumptions that you make.
a. How many disk drives would be required to hold 4 exabytes of
data?
b. How many magnetic tapes would be required to hold 4 exabytes
of data?
c. How many optical tapes would be required to hold 4 exabytes
of data (see Exercise 12.21)?
d. How many holographic storage cartridges would be required to
hold 4 exabytes of data (see Exercise 12.20)?
e. How many cubic feet of storage space would each option require?
Answer:
a. Assume that a disk drive holds 10 GB. Then 100 disks hold 1
TB, 100,000 disks hold 1 PB, and 100,000,000 disks hold 1 EB. To
store 4 EBwould require about 400 million disks. If a magnetic
tape holds 40 GB, only 100 million tapes would be required. If

50

Chapter 12 Mass-Storage Structure

an optical tape holds 50 times more data than a magnetic tape, 2
million optical tapes would suffice. If a holographic cartridge can
store 180 GB, about 22.2 million cartridges would be required.
b. A 3.5" disk drive is about 1" high, 4" wide, and 6" deep. In feet,
this is 1/12 by 1/3 by 1/2, or 1/72 cubic feet. Packed densely,
the 400 million disks would occupy 5.6 million cubic feet. If we
allow a factor of two for air space and space for power supplies,
the required capacity is about 11 million cubic feet.
c. A 1/2" tape cartridge is about 1" high and 4.5" square. The volume is about 1/85 cubic feet. For 100 million magnetic tapes
packed densely, the volume is about 1.2 million cubic feet. For 2
million optical tapes, the volume is 23,400 cubic feet.
d. A CD-ROM is 4.75" in diameter and about 1/16" thick. If we
assume that a holostore disk is stored in a library slot that is 5"
square and 1/8" wide, we calculate the volume of 22.2 million
disks to be about 40,000 cubic feet.

13

CHAPTER

I/O Systems

Exercises
13.1

State three advantages of placing functionality in a device controller,
rather than in the kernel. State three disadvantages.
Answer: Three advantages: Bugs are less likely to cause an operating
system crash
Performance can be improved by utilizing dedicated hardware and
hard-coded algorithms
The kernel is simplified by moving algorithms out of it
Three disadvantages: Bugs are harder to fix—a new firmware version
or new hardware is needed
Improving algorithms likewise require a hardware update rather than
just a kernel or device-driver update
Embedded algorithms could conflict with application’s use of the device, causing decreased performance.

13.2

The example of handshaking in Section 13.2 used 2 bits: a busy bit and a
command-ready bit. Is it possible to implement this handshaking with
only 1 bit? If it is, describe the protocol. If it is not, explain why 1 bit is
insufficient.
Answer: It is possible, using the following algorithm. Let’s assume
we simply use the busy-bit (or the command-ready bit; this answer
is the same regardless). When the bit is off, the controller is idle. The
host writes to data-out and sets the bit to signal that an operation is
ready (the equivalent of setting the command-ready bit). When the
controller is finished, it clears the busy bit. The host then initiates the
next operation.
This solution requires that both the host and the controller have read
and write access to the same bit, which can complicate circuitry and
increase the cost of the controller.
51

52

Chapter 13 I/O Systems

13.3

Why might a system use interrupt-driven I/O to manage a single serial
port, but polling I/O to manage a front-end processor, such as a terminal
concentrator?
Answer: Polling can be more efficient than interrupt-driven I/O. This
is the case when the I/O is frequent and of short duration. Even though
a single serial port will perform I/O relatively infrequently and should
thus use interrupts, a collection of serial ports such as those in a terminal
concentrator can produce a lot of short I/O operations, and interrupting
for each one could create a heavy load on the system. A well-timed
polling loop could alleviate that load without wasting many resources
through looping with no I/O needed.

13.4

Polling for an I/O completion can waste a large number of CPU cycles
if the processor iterates a busy-waiting loop many times before the I/O
completes. But if the I/O device is ready for service, polling can be much
more efficient than is catching and dispatching an interrupt. Describe
a hybrid strategy that combines polling, sleeping, and interrupts for
I/O device service. For each of these three strategies (pure polling, pure
interrupts, hybrid), describe a computing environment in which that
strategy is more efficient than is either of the others.
Answer: A hybrid approach could switch between polling and interrupts depending on the length of the I/O operation wait. For example,
we could poll and loop N times, and if the device is still busy at N+1,
we could set an interrupt and sleep. This approach would avoid long
busy-waiting cycles. This method would be best for very long or very
short busy times. It would be inefficient it the I/O completes at N+T
(where T is a small number of cycles) due to the overhead of polling
plus setting up and catching interrupts.
Pure polling is best with very short wait times. Interrupts are best with
known long wait times.

13.5

How does DMA increase system concurrency? How does it complicate
hardware design?
Answer: DMA increases system concurrency by allowing the CPU
to perform tasks while the DMA system transfers data via the system
and memory buses. Hardware design is complicated because the DMA
controller must be integrated into the system, and the system must
allow the DMA controller to be a bus master. Cycle stealing may also
be necessary to allow the CPU and DMA controller to share use of the
memory bus.

13.6

Why is it important to scale up system bus and device speeds as the
CPU speed increases?
Answer: Consider a system which performs 50% I/O and 50% computes. Doubling the CPU performance on this system would increase
total system performance by only 50%. Doubling both system aspects
would increase performance by 100%. Generally, it is important to remove the current system bottleneck, and to increase overall system
performance, rather than blindly increasing the performance of individual system components.

13.7

Distinguish between a STREAMS driver and a STREAMS module.

Exercises

53

Answer: The STREAMS driver controls a physical device that could be
involved in a STREAMS operation. The STREAMS module modifies the
flow of data between the head (the user interface) and the driver.

14

CHAPTER

Protection

Exercises
14.1

What are the main differences between capability lists and access lists?
Answer: An access list is a list for each object consisting of the domains
with a nonempty set of access rights for that object. A capability list is
a list of objects and the operations allowed on those objects for each
domain.

14.2

A Burroughs B7000/B6000 MCP file can be tagged as sensitive data.
When such a file is deleted, its storage area is overwritten by some
random bits. For what purpose would such a scheme be useful?
Answer: This would be useful as an extra security measure so that the
old content of memory cannot be accessed, either intentionally or by
accident, by another program. This is especially useful for any highly
classified information.

14.3

In a ring-protection system, level 0 has the greatest access to objects,
and level n (greater than zero) has fewer access rights. The access rights
of a program at a particular level in the ring structure are considered as
a set of capabilities. What is the relationship between the capabilities
of a domain at level j and a domain at level i to an object (for j > i)?
Answer: D j is a subset of Di .

14.4

The RC 4000 system (and other systems) have defined a tree of processes
(called a process tree) such that all the descendants of a process are given
resources (objects) and access rights by their ancestors only. Thus, a
descendant can never have the ability to do anything that its ancestors
cannot do. The root of the tree is the operating system, which has the
ability to do anything. Assume the set of access rights was represented
by an access matrix, A. A(x,y) defines the access rights of process x to
55

56

Chapter 14 Protection

object y. If x is a descendant of z, what is the relationship between A(x,y)
and A(z,y) for an arbitrary object y?
Answer: A(x,y) is a subset of A(z,y).
14.5

What protection problems may arise if a shared stack is used for parameter passing?
Answer: The contents of the stack could be compromised by other
process(es) sharing the stack.

14.6

Consider a computing environment where a unique number is associated with each process and each object in the system. Suppose that we
allow a process with number n to access an object with number m only
if n > m. What type of protection structure do we have?
Answer: Hierarchical structure.

14.7

Consider a computing environment where a process is given the privilege of accessing an object only n times. Suggest a scheme for implementing this policy.
Answer: Add an integer counter with the capability.

14.8

If all the access rights to an object are deleted, the object can no longer
be accessed. At this point, the object should also be deleted, and the
space it occupies should be returned to the system. Suggest an efficient
implementation of this scheme.
Answer: Reference counts.

14.9

Why is it difficult to protect a system in which users are allowed to do
their own I/O?
Answer: In earlier chapters we identified a distinction between kernel
and user mode where kernel mode is used for carrying out privileged
operations such as I/O. One reason why I/O must be performed in
kernel mode is that I/O requires accessing the hardware and proper
access to the hardware is necessary for system integrity. If we allow
users to perform their own I/O, we cannot guarantee system integrity.

14.10

Capability lists are usually kept within the address space of the user.
How does the system ensure that the user cannot modify the contents
of the list?
Answer: A capability list is considered a “protected object” and is
accessed only indirectly by the user. The operating system ensures the
user cannot access the capability list directly.

15

CHAPTER

Security
No Exercises

57

Distributed
System
Structures

16

CHAPTER

Exercises
16.1

Most WANs employ only a partially connected topology. Why is this
so?
Answer: Cost. A fully connected network requires a link between
every node in the network. For a WAN, this may be too costly as communication links between physically distant hosts may be expensive.

16.2

Under what circumstances is a token-passing network more effective
than an Ethernet network?
Answer: A token ring is very effective under high sustained load, as
no collisions can occur and each slot may be used to carry a message,
providing high throughput. A token ring is less effective when the
load is light (token processing takes longer than bus access, so any one
packet can take longer to reach its destination) or sporadic.

16.3

Why would it be a bad idea for gateways to pass broadcast packets
between networks? What would be the advantages of doing so?
Answer: All broadcasts would be propagated to all networks, causing
a lot of network traffic. If broadcast traffic were limited to important
data (and very little of it), then broadcast propagation would save
gateways from having to run special software to watch for this data
(such as network routing information) and rebroadcast it.

16.4

Discuss the advantages and disadvantages of caching name translations for computers located in remote domains.
Answer: There is a performance advantage to caching name translations for computers located in remote domains: repeated resolution of
the same name from different computers located in the local domain
could be performed locally without requiring a remote name lookup
operation. The disadvantage is that there could be inconsistencies in the
59

60

Chapter 16 Distributed System Structures

name translations when updates are made in the mapping of names to
IP addresses. These consistency problems could be solved by invalidating translations, which would require state to be managed regarding
which computers are caching a certain translation and also would require a number of invalidation messages, or by using leases whereby
the caching entity invalidates a translation after a certain period of time.
The latter approach requires less state and no invalidation messages but
might suffer from temporary inconsistencies.
16.5

What are the advantages and disadvantages of using circuit switching?
For what kinds of applications is circuit switching a viable strategy?
Answer: Circuit switching guarantees that the network resources required for a transfer are reserved before the transmission takes place.
This ensures that packets will not be dropped and their delivery would
satisfy quality of service requirements. The disadvantage of circuit
switching is that it requires a round-trip message to set-up the reservations and it also might overprovision resources, thereby resulting
in suboptimal use of the resources. Circuit switching is a viable strategy for applications that have constant demands regarding network
resources and would require the resources for long periods of time,
thereby amortizing the initial overheads.

16.6

What are two formidable problems that designers must solve to implement a network-transparent system?
Answer: One such issue is making all the processors and storage
devices seem transparent across the network. In other words, the distributed system should appear as a centralized system to users. The
Andrew file system and NFS provide this feature: the distributed file
system appears to the user as a single file system but in reality it may
be distributed across a network.
Another issue concerns the mobility of users. We want to allow users
to connect to the “system” rather than to a specific machine (although
in reality they may be logging in to a specific machine somewhere in
the distributed system).

16.7

Process migration within a heterogeneous network is usually impossible, given the differences in architectures and operating systems. Describe a method for process migration across different architectures
running:
a. The same operating system
b. Different operating systems
Answer: For the same operating system, process migration is relatively straightforward, as the state of the process needs to migrate from
one processor to another. This involves moving the address space, state
of the CPU registers, and open files from the source system to the destination. However, it is important that identical copies of the operating
system are running on the different systems to ensure compatibility.
If the operating system are the same, but perhaps different versions
are running on the separate systems, then migrating processes must be

Exercises

61

sure to follow programming guidelines that are consistent between the
different versions of the operating system.
Java applets provide a nice example of process migration between different operating systems. To hide differences in the underlying system,
the migrated process (i.e., a Java applet) runs on a virtual machine
rather than a specific operating system. All that is required is for the
virtual machine to be running on the system the process migrates to.
16.8

To build a robust distributed system, you must know what kinds of
failures can occur.
a. List three possible types of failure in a distributed system.
b. Specify which of the entries in your list also are applicable to a
centralized system.
Answer: Three common failures in a distributed system include:
(1) network link failure, (2) host failure, (3) storage medium failure.
Both (2) and (3) are failures that could also occur in a centralized system, whereas a network link failure can occur only in a networkeddistributed system.

16.9

Is it always crucial to know that the message you have sent has arrived
at its destination safely? If your answer is yes, explain why. If your
answer is no, give appropriate examples.
Answer: No. Many status-gathering programs work from the assumption that packets may not be received by the destination system. These
programs generally broadcast a packet and assume that at least some
other systems on their network will receive the information. For instance, a daemon on each system might broadcast the system’s load
average and number of users. This information might be used for process migration target selection. Another example is a program that
determines if a remote site is both running and accessible over the network. If it sends a query and gets no reply it knows the system cannot
currently be reached.

16.10

Present an algorithm for reconstructing a logical ring after a process in
the ring fails.
Answer: Typically distributed systems employ a coordinator process
that performs functions needed by other processes in the system. This
would include enforcing mutual exclusion and —in this case of a ring
—replacing a lost token.
A scheme similar to the ring algorithm presented in Section 18.6.2 can
be used. The algorithm is as follows:
The ring algorithm assumes that the links are unidirectional and that
processes send their messages to the neighbor on their right. The main
data structure used by the algorithm is the active list, a list that contains
the priority numbers of all active processes in the system when the
algorithm ends; each process maintains its own active list.
a. If process Pi detects a coordinator failure, it creates a new active
list that is initially empty. It then sends a message elect(i) to its
right neighbor, and adds the number i to its active list.

62

Chapter 16 Distributed System Structures

b. If Pi receives a message elect(j) from the process on the left, it
must respond in one of three ways:
1. If this is the first elect message it has seen or sent, Pi creates
a new active list with the numbers i and j. It then sends the
message elect(i), followed by the message elect(j).
2. If i = j, that is, the message received does not contain Pi ’s
number, then Pi adds j to its active list and forwards the
message to its right neighbor.
3. If i = j, that is, Pi receives the message elect(i), then the
active list for Pi now contains the numbers of all the active
processes in the system. Process Pi can now determine
the largest number in the active list to identify the new
coordinator process.
16.11

Consider a distributed system with two sites, A and B. Consider whether
site A can distinguish among the following:
a. B goes down.
b. The link between A and B goes down.
c. B is extremely overloaded and its response time is 100 times
longer than normal.
What implications does your answer have for recovery in distributed
systems?
Answer: One technique would be for B to periodically send a I-am-up
message to A indicating it is still alive. If A does not receive an I-amup message, it can assume either B —or the network link—is down.
Note that an I-am-up message does not allow A to distinguish between
each type of failure. One technique that allows A better to determine
if the network is down is to send an Are-you-up message to B using an
alternate route. If it receives a reply, it can determine that indeed the
network link is down and that B is up.
If we assume that A knows B is up and is reachable (via the I-amup mechanism) and that A has some value N that indicates a normal
response time, A could monitor the response time from B and compare
values to N, allowing A to determine if B is overloaded or not.
The implications of both of these techniques are that A could choose
another host—say C—in the system if B is either down, unreachable,
or overloaded.

17

CHAPTER

Distributed File
Systems
No Exercises

63

18

CHAPTER

Distributed
Coordination
No Exercises

65

19

CHAPTER

Real-time
Systems
No Exercises

67

20

CHAPTER

Multimedia
Systems
No Exercises

69

21

CHAPTER

The Linux
System

Exercises
21.1

Dynamically loadable kernel modules give flexibility when drivers are
added to a system, but do they have disadvantages too? Under what
circumstances would a kernel be compiled into a single binary file, and
when would it be better to keep it split into modules? Explain your
answer.
Answer: There are two principal drawbacks with the use of modules.
The first is size: module management consumes unpageable kernel
memory, and a basic kernel with a number of modules loaded will
consume more memory than an equivalent kernel with the drivers
compiled into the kernel image itself. This can be a very significant
issue on machines with limited physical memory.
The second drawback is that modules can increase the complexity
of the kernel bootstrap process. It is hard to load up a set of modules
from disk if the driver needed to access that disk itself a module that
needs to be loaded. As a result, managing the kernel bootstrap with
modules can require extra work on the part of the administrator: the
modules required to bootstrap need to be placed into a ramdisk image
that is loaded alongside the initial kernel image when the system is
initialized.
In certain cases it is better to use a modular kernel, and in other
cases it is better to use a kernel with its device drivers prelinked. Where
minimizing the size of the kernel is important, the choice will depend
on how often the various device drivers are used. If they are in constant use, then modules are unsuitable. This is especially true where
drivers are needed for the boot process itself. On the other hand, if
some drivers are not always needed, then the module mechanism al71

72

Chapter 21 The Linux System

lows those drivers to be loaded and unloaded on demand, potentially
offering a net saving in physical memory.
Where a kernel is to be built that must be usable on a large variety
of very different machines, then building it with modules is clearly
preferable to using a single kernel with dozens of unnecessary drivers
consuming memory. This is particularly the case for commercially distributed kernels, where supporting the widest variety of hardware in
the simplest manner possible is a priority.
However, if a kernel is being built for a single machine whose
configuration is known in advance, then compiling and using modules
may simply be an unnecessary complexity. In cases like this, the use of
modules may well be a matter of taste.
21.2

Multithreading is a commonly used programming technique. Describe
three different ways that threads could be implemented. Explain how
these ways compare to the Linux clone mechanism. When might each
alternative mechanism be better or worse than using clones?
Answer: Thread implementations can be broadly classified into two
groups: kernel-based threads and user-mode threads. User-mode thread
packages rely on some kernel support—they may require timer interrupt facilities, for example —but the scheduling between threads is not
performed by the kernel but by some library of user-mode code. Multiple threads in such an implementation appear to the operating system
as a single execution context. When the multithreaded process is running, it decides for itself which of its threads to execute, using non-local
jumps to switch between threads according to its own preemptive or
non-preemptive scheduling rules.
Alternatively, the operating system kernel may provide support for
threads itself. In this case, the threads may be implemented as separate
processes that happen to share a complete or partial common address
space, or they may be implemented as separate execution contexts
within a single process. Whichever way the threads are organized, they
appear as fully independent execution contexts to the application.
Hybrid implementations are also possible, where a large number of
threads are made available to the application using a smaller number
of kernel threads. Runnable user threads are run by the first available
kernel thread.
In Linux, threads are implemented within the kernel by a clone
mechanism that creates a new process within the same virtual address
space as the parent process. Unlike some kernel-based thread packages,
the Linux kernel does not make any distinction between threads and
processes: a thread is simply a process that did not create a new virtual
address space when it was initialized.
The main advantage of implementing threads in the kernel rather
than in a user-mode library are that:
• kernel-threaded systems can take advantage of multiple
processors if they are available; and
• if one thread blocks in a kernel service routine (for example, a
system call or page fault), other threads are still able to run.

Exercises

73

A lesser advantage is the ability to assign different security attributes
to each thread.
User-mode implementations do not have these advantages. Because
such implementations run entirely within a single kernel execution context, only one thread can ever be running at once, even if multiple CPUs
are available. For the same reason, if one thread enters a system call,
no other threads can run until that system call completes. As a result,
one thread doing a blocking disk read will hold up every thread in the
application. However, user-mode implementations do have their own
advantages. The most obvious is performance: invoking the kernel’s
own scheduler to switch between threads involves entering a new protection domain as the CPU switches to kernel mode, whereas switching
between threads in user mode can be achieved simply by saving and
restoring the main CPU registers. User-mode threads may also consume less system memory: most UNIX systems will reserve at least a
full page for a kernel stack for each kernel thread, and this stack may
not be pageable.
The hybrid approach, implementing multiple user threads over a
smaller number of kernel threads, allows a balance between these tradeoffs to be achieved. The kernel threads will allow multiple threads to
be in blocking kernel calls at once and will permit running on multiple CPUs, and user-mode thread switching can occur within each
kernel thread to perform lightweight threading without the overheads
of having too many kernel threads. The downside of this approach
is complexity: giving control over the tradeoff complicates the thread
library’s user interface.
21.3

The Linux kernel does not allow paging out of kernel memory. What
effect does this restriction have on the kernel’s design? What are two
advantages and two disadvantages of this design decision?
Answer: The primary impact of disallowing paging of kernel memory
in Linux is that the non-preemptability of the kernel is preserved. Any
process taking a page fault, whether in kernel or in user mode, risks
being rescheduled while the required data is paged in from disk. Because the kernel can rely on not being rescheduled during access to its
primary data structures, locking requirements to protect the integrity
of those data structures are very greatly simplified. Although design
simplicity is a benefit in itself, it also provides an important performance advantage on uniprocessor machines due to the fact that it is
not necessary to do additional locking on most internal data structures.
There are a number of disadvantages to the lack of pageable kernel
memory, however. First of all, it imposes constraints on the amount of
memory that the kernel can use. It is unreasonable to keep very large
data structures in non-pageable memory, since that represents physical
memory that absolutely cannot be used for anything else. This has two
impacts: first of all, the kernel must prune back many of its internal data
structures manually, instead of being able to rely on a single virtualmemory mechanism to keep physical memory usage under control.
Second, it makes it infeasible to implement certain features that require
large amounts of virtual memory in the kernel, such as the /tmp-

74

Chapter 21 The Linux System

filesystem (a fast virtual-memory-based file system found on some
UNIX systems).
Note that the complexity of managing page faults while running
kernel code is not an issue here. The Linux kernel code is already able
to deal with page faults: it needs to be able to deal with system calls
whose arguments reference user memory that may be paged out to
disk.
21.4

What are three advantages of dynamic (shared) linkage of libraries
compared to static linkage? What are two cases where static linkage is
preferable?
Answer: The primary advantages of shared libraries are that they
reduce the memory and disk space used by a system, and they enhance
maintainability.
When shared libraries are being used by all running programs,
there is only one instance of each system library routine on disk, and
at most one instance in physical memory. When the library in question
is one used by many applications and programs, then the disk and
memory savings can be quite substantial. In addition, the startup time
for running new programs can be reduced, since many of the common
functions needed by that program are likely to be already loaded into
physical memory.
Maintainability is also a major advantage of dynamic linkage over
static. If all running programs use a shared library to access their system library routines, then upgrading those routines, either to add new
functionality or to fix bugs, can be done simply by replacing that shared
library. There is no need to recompile or relink any applications; any
programs loaded after the upgrade is complete will automatically pick
up the new versions of the libraries.
There are other advantages too. A program that uses shared libraries
can often be adapted for specific purposes simply by replacing one or
more of its libraries, or even (if the system allows it, and most UNIXs
including Linux do) adding a new one at run time. For example, a
debugging library can be substituted for a normal one to trace a problem
in an application. Shared libraries also allow program binaries to be
linked against commercial, proprietary library code without actually
including any of that code in the program’s final executable file. This is
important because on most UNIX systems, many of the standard shared
libraries are proprietary, and licensing issues may prevent including
that code in executable files to be distributed to third parties.
In some places, however, static linkage is appropriate. One example is
in rescue environments for system administrators. If a system administrator makes a mistake while installing any new libraries, or if hardware
develops problems, it is quite possible for the existing shared libraries
to become corrupt. As a result, often a basic set of rescue utilities are
linked statically, so that there is an opportunity to correct the fault
without having to rely on the shared libraries functioning correctly.
There are also performance advantages that sometimes make static
linkage preferable in special cases. For a start, dynamic linkage does
increase the startup time for a program, as the linking must now be

Exercises

75

done at run time rather than at compile time. Dynamic linkage can also
sometimes increase the maximum working set size of a program (the
total number of physical pages of memory required to run the program).
In a shared library, the user has no control over where in the library
binary file the various functions reside. Since most functions do not
precisely fill a full page or pages of the library, loading a function will
usually result in loading in parts of the surrounding functions, too. With
static linkage, absolutely no functions that are not referenced (directly
or indirectly) by the application need to be loaded into memory.
Other issues surrounding static linkage include ease of distribution:
it is easier to distribute an executable file with static linkage than with
dynamic linkage if the distributor is not certain whether the recipient
will have the correct libraries installed in advance. There may also be
commercial restrictions against redistributing some binaries as shared
libraries. For example, the license for the UNIX “Motif” graphical environment allows binaries using Motif to be distributed freely as long
as they are statically linked, but the shared libraries may not be used
without a license.
21.5

Compare the use of networking sockets with the use of shared memory
as a mechanism for communicating data between processes on a single
computer. What are the advantages of each method? When might each
be preferred?
Answer: Using network sockets rather than shared memory for local
communication has a number of advantages. The main advantage is
that the socket programming interface features a rich set of synchronization features. A process can easily determine when new data has
arrived on a socket connection, how much data is present, and who
sent it. Processes can block until new data arrives on a socket, or they
can request that a signal be delivered when data arrives. A socket also
manages separate connections. A process with a socket open for receive can accept multiple connections to that socket and will be told
when new processes try to connect or when old processes drop their
connections.
Shared memory offers none of these features. There is no way
for a process to determine whether another process has delivered or
changed data in shared memory other than by going to look at the
contents of that memory. It is impossible for a process to block and
request a wakeup when shared memory is delivered, and there is no
standard mechanism for other processes to establish a shared memory
link to an existing process.
However, shared memory has the advantage that it is very much
faster than socket communications in many cases. When data is sent
over a socket, it is typically copied from memory to memory multiple
times. Shared memory updates require no data copies: if one process
updates a data structure in shared memory, that update is immediately
visible to all other processes sharing that memory. Sending or receiving
data over a socket requires that a kernel system service call be made
to initiate the transfer, but shared memory communication can be performed entirely in user mode with no transfer of control required.

76

Chapter 21 The Linux System

Socket communication is typically preferred when connection management is important or when there is a requirement to synchronize
the sender and receiver. For example, server processes will usually establish a listening socket to which clients can connect when they want
to use that service. Once the socket is established, individual requests
are also sent using the socket, so that the server can easily determine
when a new request arrives and who it arrived from.
In some cases, however, shared memory is preferred. Shared memory
is often a better solution when either large amounts of data are to
be transferred or when two processes need random access to a large
common data set. In this case, however, the communicating processes
may still need an extra mechanism in addition to shared memory to
achieve synchronization between themselves. The X Window System, a
graphical display environment for UNIX, is a good example of this: most
graphic requests are sent over sockets, but shared memory is offered
as an additional transport in special cases where large bitmaps are to
be displayed on the screen. In this case, a request to display the bitmap
will still be sent over the socket, but the bulk data of the bitmap itself
will be sent via shared memory.
21.6

UNIX systems used to use disk-layout optimizations based on the rotation position of disk data, but modern implementations, including
Linux, simply optimize for sequential data access. Why do they do so?
Of what hardware characteristics does sequential access take advantage? Why is rotational optimization no longer so useful?
Answer: The performance characteristics of disk hardware have
changed substantially in recent years. In particular, many enhancements have been introduced to increase the maximum bandwidth that
can be achieved on a disk. In a modern system, there can be a long
pipeline between the operating system and the disk’s read-write head.
A disk I/O request has to pass through the computer’s local disk controller, over bus logic to the disk drive itself, and then internally to the
disk, where there is likely to be a complex controller that can cache data
accesses and potentially optimize the order of I/O requests.
Because of this complexity, the time taken for one I/O request to be
acknowledged and for the next request to be generated and received
by the disk can far exceed the amount of time between one disk sector
passing under the read-write head and the next sector header arriving.
In order to be able efficiently to read multiple sectors at once, disks
will employ a readahead cache. While one sector is being passed back
to the host computer, the disk will be busy reading the next sectors in
anticipation of a request to read them. If read requests start arriving in
an order that breaks this readahead pipeline, performance will drop.
As a result, performance benefits substantially if the operating system
tries to keep I/O requests in strict sequential order.
A second feature of modern disks is that their geometry can be very
complex. The number of sectors per cylinder can vary according to the
position of the cylinder: more data can be squeezed into the longer
tracks nearer the edge of the disk than at the center of the disk. For an
operating system to optimize the rotational position of data on such

Exercises

77

disks, it would have to have complete understanding of this geometry,
as well as the timing characteristics of the disk and its controller. In general, only the disk’s internal logic can determine the optimal scheduling
of I/Os, and the disk’s geometry is likely to defeat any attempt by the
operating system to perform rotational optimizations.

22

CHAPTER

Windows XP

Exercises
22.1

What type of operating system is Windows XP? Describe two of its
major features.
Answer: A 32/64 bit preemptive multitasking operating system supporting multiple users. (1) The ability automatically to repair application and operating system problems. (2) Better networking and device
experience (including digital photography and video).

22.2

List the design goals of Windows XP. Describe two in detail.
Answer: Design goals include security, reliability, Windows and POSIX
application compatibility, high performance, extensibility, portability
and international support. (1) Reliability was perceived as a stringent
requirement and included extensive driver verification, facilities for
catching programming errors in user-level code, and a rigorous certification process for third-party drivers, applications, and devices. (2)
Achieving high performance required examination of past problem areas such as I/O performance, server CPU bottlenecks, and the scalability
of multithreaded and multiprocessor environments.

22.3

Describe the booting process for a Windows XP system.
Answer: (1) As the hardware powers on, the BIOS begins executing
from ROM and loads and executes the bootstrap loader from the disk. (2)
The NTLDR program is loaded from the root directory of the identified
system device and determines which boot device contains the operating
system. (3) NTLDR loads the HAL library, kernel, and system hive. The
system hive indicates the required boot drivers and loads them. (4)
Kernel execution begins by initializing the system and creating two
processes: the system process containing all internal worker threads,
and the first user-mode initialization process: SMSS. (5) SMSS further
79

80

Chapter 22 Windows XP

initializes the system by establishing paging files and loading device
drivers. (6) SMSS creates two processes: WINLOGON, which brings up
the rest of the system, and CSRSS (the Win32 subsystem process).
22.4

Describe the three main architectural layers of Windows XP.
Answer: (1) The HAL (Hardware Abstraction Layer) creates operating system portability by hiding hardware differences from the upper
layers of the operating system. Administrative details of low-level facilities are provided by HAL interfaces. HAL presents a virtual-machine
interface that is used by the kernel dispatcher, the executive and device
drivers. (2) The kernel layer provides a foundation for the executive
functions and user-mode subsystems. The kernel remains in memory
and is never preempted. Its responsibilities are thread scheduling, interrupt and exception handling, low-level processor synchronization,
and power failure recovery. (3) The executive layer provides a set of services used by all subsystems: object manager, virtual memory manager,
process manager, local procedure call facility, I/O manager, security
monitor, plug-and-play manager, registry, and booting.

22.5

What is the job of the object manager?
Answer: Objects present a generic set of kernel mode interfaces to usermode programs. Objects are manipulated by the executive-layer object
manager. The job of the object manager is to supervise the allocation
and use of all managed objects.

22.6

What types of services does the process manager provide? What is a
local procedure call?
Answer: The process manager provides services for creating, deleting, and using processes, threads and jobs. The process manager also
implements queuing and delivery of asynchronous procedure calls to
threads. The local procedure call (LPC) is a message-passing system.
The operating system uses the LPC to pass requests and results between client and server processes within a single machine, in particular
between Windows XP subsystems.

22.7

What are the responsibilities of the I/O manager?
Answer: The I/O manager is responsible for file systems, device
drivers, and network drivers. The I/O manager keeps track of which
device drivers, filter drivers, and file systems are loaded and manages
buffers for I/O requests. It furthermore assists in providing memorymapped file I/O and controls the cache manager for the whole I/O
system.

22.8

Does Windows XP offer any user-mode processes that enable it to run
programs developed for other operating systems? Describe two of these
subsystems.
Answer: Environmental subsystems are user-mode processes layered
over the native executable services to enable Windows XP to run programs developed for other operating systems. (1) A Win32 application
called the virtual DOS machine (VDM) is provided as a user-mode process to run MS-DOS applications. The VDM can execute or emulate Intel
486 instructions and also provides routines to emulate MS-DOS BIOS

Exercises

81

services and provides virtual drivers for screen, keyboard, and communication ports. (2) Windows-on-windows (WOW32) provides kernel
and stub routines for Windows 3.1 functions. The stub routines call the
appropriate Win32 subroutines, converting the 16-bit addresses into
32-bit addresses.
22.9

What types of networking does Windows XP support? How does Windows XP implement transport protocols? Describe two networking protocols.
Answer: Support is provided for both peer-to-peer and client-server
networking. Transport protocols are implemented as drivers. (1) The
TCP/IP package includes SNMP, DHCP, WINS, and NetBIOS support. (2)
Point-to-point tunneling protocol is provided to communicate between
remote-access modules running on Windows XP servers and other client
systems connected over the internet. Using this scheme, multi-protocol
virtual private networks (VPNs) are supported over the internet.

22.10

How is the NTFS namespace organized? Describe.
Answer: The NTFS namespace is organized as a hierarchy of directories
where each directory uses a B+ tree data structure to store an index of
the file names in that directory. The index root of a directory contains
the top level of the B+ tree. Each entry in the directory contains the
name and file reference of the file as well as the update timestamp and
file size.

22.11

How does NTFS handle data structures? How does NTFS recover from
a system crash? What is guaranteed after a recovery takes place?
Answer: In NTFS, all file-system data structure updates are performed
inside transactions. Before a data structure is altered, the transaction
writes a log record containing redo and undo information. A commit
record is written to the log after a transaction has succeeded. After a
crash the file system can be restored to a consistent state by processing
the log records, first redoing operations for committed transactions and
undoing operations for transactions that did not successfully commit.
This scheme does not guarantee that user file contents are correct after
a recovery, but rather that the file-system data structures (file metadata)
are undamaged and reflect some consistent state that existed before the
crash.

22.12

How does Windows XP allocate user memory?
Answer: User memory can be allocated according to several schemes:
virtual memory, memory-mapped files, heaps, and thread-local storage.

22.13

Describe some of the ways an application can use memory via the
Win32 API.
Answer: (1) Virtual memory provides several functions that allow
an application to reserve and release memory, specifying the virtual
address at which the memory is allocated. (2) A file may be memorymapped into address space, providing a means for two processes to
share memory. (3) When a Win32 process is initialized, it is created
with a default heap. Private heaps can be created that provide regions of

82

Chapter 22 Windows XP

reserved address space for applications. Thread management functions
are provided to allocate and control thread access to private heaps. (4)
A thread-local storage mechanism provides a way for global and static
data to work properly in a multithreaded environment. Thread-lock
storage allocates global storage on a per-thread basis.

Influential
Operating
Systems

23

CHAPTER

No Exercises

83

