LECTURE NOTES ON
DATA STRUCTURES USING C
Revision 4.0
1 December, 2014

L. V. NARASIMHA PRASAD
Professor
Department of Computer Science and Engineering

E. KRISHNA RAO PATRO
Associate Professor
Department of Computer Science and Engineering

INSTITUTE OF AERONAUTICAL ENGINEERING
DUNDIGAL – 500 043, HYDERABAD

2014-2015

CONTENTS
CHAPTER 1 BASIC CONCEPTS
1.1
1.2
1.3.
1.4.
1.5.
1.6.
1.7.
1.8.
1.9.
1.10.
1.11.

Introduction to Data Structures
Data structures: organizations of data
Abstract Data Type (ADT)
Selecting a data structure to match the operation
Algorithm
Practical Algorithm design issues
Performance of a program
Classification of Algorithms
Complexity of Algorithms
Rate of Growth
Analyzing Algorithms
Exercises
Multiple Choice Questions

CHAPTER 2 RECURSION
2.1.
2.2.
2.3.
2.4.
2.5.
2.6.
2.7.
2.8.

Introduction to Recursion
Differences between recursion and iteration
Factorial of a given number
The Towers of Hanoi
Fibonacci Sequence Problem
Program using recursion to calculate the NCR of a given number
Program to calculate the least common multiple of a given number
Program to calculate the greatest common divisor
Exercises
Multiple Choice Questions

CHAPTER 3 LINKED LISTS
3.1.
3.2.
3.3.

Linked List Concepts
Types of Linked Lists
Single Linked List
3.3.1. Source Code for the Implementation of Single Linked List
3.4.
Using a header node
3.5.
Array based linked lists
3.6.
Double Linked List
3.6.1. A Complete Source Code for the Implementation of Double Linked List
3.7.
Circular Single Linked List
3.7.1. Source Code for Circular Single Linked List
3.8.
Circular Double Linked List
3.8.1. Source Code for Circular Double Linked List
3.9.
Comparison of Linked List Variations
3.10. Polynomials
3.10.1. Source code for polynomial creation with help of linked list
3.10.2. Addition of Polynomials
3.10.3. Source code for polynomial addition with help of linked list:
Exercise
Multiple Choice Questions

I

CHAPTER 4 STACK AND QUEUE
4.1.

Stack
4.1.1. Representation of Stack
4.1.2. Program to demonstrate a stack, using array
4.1.3. Program to demonstrate a stack, using linked list
4.2.
Algebraic Expressions
4.3.
Converting expressions using Stack
4.3.1. Conversion from infix to postfix
4.3.2. Program to convert an infix to postfix expression
4.3.3. Conversion from infix to prefix
4.3.4. Program to convert an infix to prefix expression
4.3.5. Conversion from postfix to infix
4.3.6. Program to convert postfix to infix expression
4.3.7. Conversion from postfix to prefix
4.3.8. Program to convert postfix to prefix expression
4.3.9. Conversion from prefix to infix
4.3.10. Program to convert prefix to infix expression
4.3.11. Conversion from prefix to postfix
4.3.12. Program to convert prefix to postfix expression
4.4.
Evaluation of postfix expression
4.5.
Applications of stacks
4.6.
Queue
4.6.1. Representation of Queue
4.6.2. Program to demonstrate a Queue using array
4.6.3. Program to demonstrate a Queue using linked list
4.7.
Applications of Queue
4.8.
Circular Queue
4.8.1. Representation of Circular Queue
4.9.
Deque
4.10. Priority Queue
Exercises
Multiple Choice Questions
CHAPTER 5 BINARY TREES
5.1.
5.2.
5.3.

5.4.
5.5.
5.6.
5.7.
5.8.
5.9.

Trees
Binary Tree
Binary Tree Traversal Techniques
5.3.1. Recursive Traversal Algorithms
5.3.2. Building Binary Tree from Traversal Pairs
5.3.3. Binary Tree Creation and Traversal Using Arrays
5.3.4. Binary Tree Creation and Traversal Using Pointers
5.3.5. Non Recursive Traversal Algorithms
Expression Trees
5.4.1. Converting expressions with expression trees
Threaded Binary Tree
Binary Search Tree
General Trees (m-ary tree)
5.7.1. Converting a m-ary tree (general tree) to a binary tree
Search and Traversal Techniques for m-ary trees
5.8.1. Depth first search
5.8.2. Breadth first search
Sparse Matrices
Exercises
Multiple Choice Questions

II

CHAPTER 6 GRAPHS
6.1.
6.2.
6.3.
6.4.
6.5.

Introduction to Graphs
Representation of Graphs
Minimum Spanning Tree
6.3.1. Kruskal’s Algorithm
6.3.2. Prim’s Algorithm
Reachability Matrix
Traversing a Graph
6.5.1. Breadth first search and traversal
6.5.2. Depth first search and traversal
Exercises
Multiple Choice Questions

CHAPTER 7 SEARCHING AND SORTING
7.1.
7.2.
7.3.
7.4.
7.5.
7.6.

7.7.
7.8.

Linear Search
7.1.1. A non-recursive program for Linear Search
7.1.1. A Recursive program for linear search
Binary Search
7.1.2. A non-recursive program for binary search
7.1.3. A recursive program for binary search
Bubble Sort
7.3.1. Program for Bubble Sort
Selection Sort
7.4.1 Non-recursive Program for selection sort
7.4.2. Recursive Program for selection sort
Quick Sort
7.5.1. Recursive program for Quick Sort
Priority Queue and Heap and Heap Sort
7.6.2. Max and Min Heap data structures
7.6.2. Representation of Heap Tree
7.6.3. Operations on heap tree
7.6.4. Merging two heap trees
7.6.5. Application of heap tree
Heap Sort
7.7.1. Program for Heap Sort
Priority queue implementation using heap tree
Exercises
Multiple Choice Questions

References and Selected Readings
Index

III

Chapter

1

Basic Concepts
The term data structure is used to describe the way data is stored, and the term
algorithm is used to describe the way data is processed. Data structures and
algorithms are interrelated. Choosing a data structure affects the kind of algorithm
you might use, and choosing an algorithm affects the data structures we use.
An Algorithm is a finite sequence of instructions, each of which has a clear meaning
and can be performed with a finite amount of effort in a finite length of time. No
matter what the input values may be, an algorithm terminates after executing a
finite number of instructions.

1.1.

Introduction to Data Structures:

Data structure is a representation of logical relationship existing between individual elements of
data. In other words, a data structure defines a way of organizing all data items that considers
not only the elements stored but also their relationship to each other. The term data structure
is used to describe the way data is stored.
To develop a program of an algorithm we should select an appropriate data structure for that
algorithm. Therefore, data structure is represented as:
Algorithm + Data structure = Program
A data structure is said to be linear if its elements form a sequence or a linear list. The linear
data structures like an array, stacks, queues and linked lists organize data in linear order. A
data structure is said to be non linear if its elements form a hierarchical classification where,
data items appear at various levels.
Trees and Graphs are widely used non-linear data structures. Tree and graph structures
represents hierarchial relationship between individual data elements. Graphs are nothing but
trees with certain restrictions removed.
Data structures are divided into two types:

•
•

Primitive data structures.
Non-primitive data structures.

Primitive Data Structures are the basic data structures that directly operate upon the
machine instructions. They have different representations on different computers. Integers,
floating point numbers, character constants, string constants and pointers come under this
category.
Non-primitive data structures are more complicated data structures and are derived from
primitive data structures. They emphasize on grouping same or different data items with
relationship between each data item. Arrays, lists and files come under this category. Figure
1.1 shows the classification of data structures.

Lecture Notes

1

Dept. of Information Technology

Da t a St r uc t ur e s

No n- Pr i mi t iv e Da t a St r uc t ur e s

Pr i mi t iv e Da t a St r uc t ur e s

I nt e g er

F l o at

C h ar

P o i nt er s

Arr ay s

L i st s

L i n e ar L i st s

St ac k s

File s

No n- L i n e ar L i st s

Queues

Gr a p h s

T re e s

F i g ur e 1. 1. C l a s s if ic at i o n of Da t a St r uc t ur e s

1.2.

Data structures: Organization of data

The collection of data you work with in a program have some kind of structure or organization.
No matte how complex your data structures are they can be broken down into two fundamental
types:
•
Contiguous
•
Non-Contiguous.
In contiguous structures, terms of data are kept together in memory (either RAM or in a file).
An array is an example of a contiguous structure. Since each element in the array is located
next to one or two other elements. In contrast, items in a non-contiguous structure and
scattered in memory, but we linked to each other in some way. A linked list is an example of a
non-contiguous data structure. Here, the nodes of the list are linked together using pointers
stored in each node. Figure 1.2 below illustrates the difference between contiguous and noncontiguous structures.

1

2

3

1

(a) Contiguous

2

3

(b) non-contiguous

Figure 1.2 Contiguous and Non-contiguous structures compared

Contiguous structures:
Contiguous structures can be broken drawn further into two kinds: those that contain data
items of all the same size, and those where the size may differ. Figure 1.2 shows example of
each kind. The first kind is called the array. Figure 1.3(a) shows an example of an array of
numbers. In an array, each element is of the same type, and thus has the same size.
The second kind of contiguous structure is called structure, figure 1.3(b) shows a simple
structure consisting of a person’s name and age. In a struct, elements may be of different data
types and thus may have different sizes.

Lecture Notes

2

Dept. of Information Technology

For example, a person’s age can be represented with a simple integer that occupies two bytes
of memory. But his or her name, represented as a string of characters, may require many
bytes and may even be of varying length.
Couples with the atomic types (that is, the single data-item built-in types such as integer, float
and pointers), arrays and structs provide all the “mortar” you need to built more exotic form of
data structure, including the non-contiguous forms.
int arr[3] = {1, 2, 3};

1

2

struct cust_data
{
int age;
char name[20];
};

3

cust_data bill= {21, “bill the student”};

(a) Array

21

(b) struct

“bill the student”

Figure 1.3 Examples of contiguous structures.

Non-contiguous structures:
Non-contiguous structures are implemented as a collection of data-items, called nodes, where
each node can point to one or more other nodes in the collection. The simplest kind of noncontiguous structure is linked list.
A linked list represents a linear, one-dimension type of non-contiguous structure, where there
is only the notation of backwards and forwards. A tree such as shown in figure 1.4(b) is an
example of a two-dimensional non-contiguous structure. Here, there is the notion of up and
down and left and right.
In a tree each node has only one link that leads into the node and links can only go down the
tree. The most general type of non-contiguous structure, called a graph has no such
restrictions. Figure 1.4(c) is an example of a graph.

A

B

C

A
B

(a) Linked List

C
D

A
E
B

G

C
F

(b) Tree

D

E

F

(c) graph

G

Figure 1.4. Examples of non-contiguous structures

Lecture Notes

3

Dept. of Information Technology

Hybrid structures:
If two basic types of structures are mixed then it is a hybrid form. Then one part contiguous
and another part non-contiguous. For example, figure 1.5 shows how to implement a double–
linked list using three parallel arrays, possibly stored a past from each other in memory.

A

List Head

B

C

(a) Conceptual Structure

D

P

N

1

A

3

4

2

B

4

0

3

C

0

1

4

D

1

2

(b) Hybrid Implementation

Figure 1.5. A double linked list via a hybrid data structure

The array D contains the data for the list, whereas the array P and N hold the previous and
next “pointers’’. The pointers are actually nothing more than indexes into the D array. For
instance, D[i] holds the data for node i and p[i] holds the index to the node previous to i,
where may or may not reside at position i–1. Like wise, N[i] holds the index to the next node in
the list.
1.3.

Abstract Data Type (ADT):

The design of a data structure involves more than just its organization. You also need to plan
for the way the data will be accessed and processed – that is, how the data will be interpreted
actually, non-contiguous structures – including lists, tree and graphs – can be implemented
either contiguously or non- contiguously like wise, the structures that are normally treated as
contiguously - arrays and structures – can also be implemented non-contiguously.
The notion of a data structure in the abstract needs to be treated differently from what ever is
used to implement the structure. The abstract notion of a data structure is defined in terms of
the operations we plan to perform on the data.
Considering both the organization of data and the expected operations on the data, leads to the
notion of an abstract data type. An abstract data type in a theoretical construct that consists of
data as well as the operations to be performed on the data while hiding implementation.
For example, a stack is a typical abstract data type. Items stored in a stack can only be added
and removed in certain order – the last item added is the first item removed. We call these
operations, pushing and popping. In this definition, we haven’t specified have items are stored
on the stack, or how the items are pushed and popped. We have only specified the valid
operations that can be performed.
For example, if we want to read a file, we wrote the code to read the physical file device. That
is, we may have to write the same code over and over again. So we created what is known

Lecture Notes

4

Dept. of Information Technology

today as an ADT. We wrote the code to read a file and placed it in a library for a programmer to
use.
As another example, the code to read from a keyboard is an ADT. It has a data structure,
character and set of operations that can be used to read that data structure.
To be made useful, an abstract data type (such as stack) has to be implemented and this is
where data structure comes into ply. For instance, we might choose the simple data structure
of an array to represent the stack, and then define the appropriate indexing operations to
perform pushing and popping.
1.4.

Selecting a data structure to match the operation:

The most important process in designing a problem involves choosing which data structure to
use. The choice depends greatly on the type of operations you wish to perform.
Suppose we have an application that uses a sequence of objects, where one of the main
operations is delete an object from the middle of the sequence. The code for this is as follows:
void delete (int *seg, int &n, int posn)
// delete the item at position from an array of n elements.
{
if (n)
{
int i=posn;
n--;
while (i < n)
{
seq[i] = seg[i+1];
i++;
}
}
return;
}
This function shifts towards the front all elements that follow the element at position posn. This
shifting involves data movement that, for integer elements, which is too costly. However,
suppose the array stores larger objects, and lots of them. In this case, the overhead for moving
data becomes high. The problem is that, in a contiguous structure, such as an array the logical
ordering (the ordering that we wish to interpret our elements to have) is the same as the
physical ordering (the ordering that the elements actually have in memory).
If we choose non-contiguous representation, however we can separate the logical ordering from
the physical ordering and thus change one without affecting the other. For example, if we store
our collection of elements using a double–linked list (with previous and next pointers), we can
do the deletion without moving the elements, instead, we just modify the pointers in each
node. The code using double linked list is as follows:
void delete (node * beg, int posn)
//delete the item at posn from a list of elements.
{
int i = posn;
node *q = beg;
while (i && q)
{

Lecture Notes

5

Dept. of Information Technology

i--;
q = q Æ next;
}
if (q)
{

/* not at end of list, so detach P by making previous and
next nodes point to each other */
node *p = q -> prev;
node *n = q -> next;
if (p)
p -> next = n;
if (n)
n -> prev = P;

}
return;
}
The process of detecting a node from a list is independent of the type of data stored in the
node, and can be accomplished with some pointer manipulation as illustrated in figure below:

A

X
200

100

Initial List

A

C
300

X

A

Figure 1.6 Detaching a node from a list

Since very little data is moved during this process, the deletion using linked lists will often be
faster than when arrays are used.
It may seem that linked lists are superior to arrays. But is that always true? There are trade
offs. Our linked lists yield faster deletions, but they take up more space because they require
two extra pointers per element.
1.5.

Algorithm

An algorithm is a finite sequence of instructions, each of which has a clear meaning and can be
performed with a finite amount of effort in a finite length of time. No matter what the input
values may be, an algorithm terminates after executing a finite number of instructions. In
addition every algorithm must satisfy the following criteria:
Input: there are zero or more quantities, which are externally supplied;
Output: at least one quantity is produced;

Lecture Notes

6

Dept. of Information Technology

Definiteness: each instruction must be clear and unambiguous;
Finiteness: if we trace out the instructions of an algorithm, then for all cases the algorithm will
terminate after a finite number of steps;
Effectiveness: every instruction must be sufficiently basic that it can in principle be carried out
by a person using only pencil and paper. It is not enough that each operation be definite, but it
must also be feasible.
In formal computer science, one distinguishes between an algorithm, and a program. A
program does not necessarily satisfy the fourth condition. One important example of such a
program for a computer is its operating system, which never terminates (except for system
crashes) but continues in a wait loop until more jobs are entered.
We represent an algorithm using pseudo language that is a combination of the constructs of a
programming language together with informal English statements.
1.6.

Practical Algorithm design issues:

Choosing an efficient algorithm or data structure is just one part of the design process. Next,
will look at some design issues that are broader in scope. There are three basic design goals
that we should strive for in a program:
1.
2.
3.

Try to save time (Time complexity).
Try to save space (Space complexity).
Try to have face.

A program that runs faster is a better program, so saving time is an obvious goal. Like wise, a
program that saves space over a competing program is considered desirable. We want to “save
face” by preventing the program from locking up or generating reams of garbled data.
1.7.

Performance of a program:

The performance of a program is the amount of computer memory and time needed to run a
program. We use two approaches to determine the performance of a program. One is
analytical, and the other experimental. In performance analysis we use analytical methods,
while in performance measurement we conduct experiments.
Time Complexity:
The time needed by an algorithm expressed as a function of the size of a problem is called the
TIME COMPLEXITY of the algorithm. The time complexity of a program is the amount of
computer time it needs to run to completion.
The limiting behavior of the complexity as size increases is called the asymptotic time
complexity. It is the asymptotic complexity of an algorithm, which ultimately determines the
size of problems that can be solved by the algorithm.
Space Complexity:
The space complexity of a program is the amount of memory it needs to run to completion. The
space need by a program has the following components:

Lecture Notes

7

Dept. of Information Technology

Instruction space: Instruction space is the space needed to store the compiled version of the
program instructions.
Data space: Data space is the space needed to store all constant and variable values. Data
space has two components:
•
•

Space needed by constants and simple variables in program.
Space needed by dynamically allocated objects such as arrays and class instances.

Environment stack space: The environment stack is used to save information needed to
resume execution of partially completed functions.
Instruction Space: The amount of instructions space that is needed depends on factors such
as:
• The compiler used to complete the program into machine code.
• The compiler options in effect at the time of compilation
• The target computer.
1.8.

Classification of Algorithms

If ‘n’ is the number of data items to be processed or degree of polynomial or the size of the file
to be sorted or searched or the number of nodes in a graph etc.
1

Next instructions of most programs are executed once or at most only a few times.
If all the instructions of a program have this property, we say that its running time
is a constant.

Log n

When the running time of a program is logarithmic, the program gets slightly
slower as n grows. This running time commonly occurs in programs that solve a big
problem by transforming it into a smaller problem, cutting the size by some
constant fraction., When n is a million, log n is a doubled whenever n doubles, log
n increases by a constant, but log n does not double until n increases to n2.

n

When the running time of a program is linear, it is generally the case that a small
amount of processing is done on each input element. This is the optimal situation
for an algorithm that must process n inputs.

n. log n

This running time arises for algorithms but solve a problem by breaking it up into
smaller sub-problems, solving them independently, and then combining the
solutions. When n doubles, the running time more than doubles.

n2

When the running time of an algorithm is quadratic, it is practical for use only on
relatively small problems. Quadratic running times typically arise in algorithms that
process all pairs of data items (perhaps in a double nested loop) whenever n
doubles, the running time increases four fold.

n3

Similarly, an algorithm that process triples of data items (perhaps in a triple–
nested loop) has a cubic running time and is practical for use only on small
problems. Whenever n doubles, the running time increases eight fold.

2n

Few algorithms with exponential running time are likely to be appropriate for
practical use, such algorithms arise naturally as “brute–force” solutions to
problems. Whenever n doubles, the running time squares.

Lecture Notes

8

Dept. of Information Technology

1.9.

Complexity of Algorithms

The complexity of an algorithm M is the function f(n) which gives the running time and/or
storage space requirement of the algorithm in terms of the size ‘n’ of the input data. Mostly,
the storage space required by an algorithm is simply a multiple of the data size ‘n’. Complexity
shall refer to the running time of the algorithm.
The function f(n), gives the running time of an algorithm, depends not only on the size ‘n’ of
the input data but also on the particular data. The complexity function f(n) for certain cases
are:
1.

Best Case

:

The minimum possible value of f(n) is called the best case.

2.

Average Case

:

The expected value of f(n).

3.

Worst Case

:

The maximum value of f(n) for any key possible input.

The field of computer science, which studies efficiency of algorithms, is known as analysis of
algorithms.
Algorithms can be evaluated by a variety of criteria. Most often we shall be interested in the
rate of growth of the time or space required to solve larger and larger instances of a problem.
We will associate with the problem an integer, called the size of the problem, which is a
measure of the quantity of input data.
1.10. Rate of Growth
Big–Oh (O), Big–Omega (Ω), Big–Theta (Θ) and Little–Oh
1.

T(n) = O(f(n)), (pronounced order of or big oh), says that the growth rate of T(n) is
less than or equal (<) that of f(n)

2.

T(n) = Ω(g(n)) (pronounced omega), says that the growth rate of T(n) is greater than
or equal to (>) that of g(n)

3.

T(n) = Θ(h(n)) (pronounced theta), says that the growth rate of T(n) equals (=) the
growth rate of h(n) [if T(n) = O(h(n)) and T(n) = Ω (h(n)]

4.

T(n) = o(p(n)) (pronounced little oh), says that the growth rate of T(n) is less than the
growth rate of p(n) [if T(n) = O(p(n)) and T(n) ≠ Θ (p(n))].

Some Examples:
2n2
2n2
2n2
2n2

+
+
+
+

5n
5n
5n
5n

–
–
–
–

6
6
6
6

=
=
=
≠

O(2n)
O(n3)
O(n2)
O(n)

2n2
2n2
2n2
2n2

+
+
+
+

5n
5n
5n
5n

–
–
–
–

6
6
6
6

≠
≠
=
≠

Θ(2n)
Θ(n3)
Θ(n2)
Θ(n)

2n2
2n2
2n2
2n2

+
+
+
+

5n
5n
5n
5n

–
–
–
–

6
6
6
6

≠
≠
=
=

Ω(2n)
Ω(n3)
Ω(n2)
Ω(n)

2n2
2n2
2n2
2n2

+
+
+
+

5n
5n
5n
5n

–
–
–
–

6
6
6
6

=
=
≠
≠

o(2n)
o(n3)
o(n2)
o(n)

Lecture Notes

9

Dept. of Information Technology

1.11. Analyzing Algorithms
Suppose ‘M’ is an algorithm, and suppose ‘n’ is the size of the input data. Clearly the
complexity f(n) of M increases as n increases. It is usually the rate of increase of f(n) we want
to examine. This is usually done by comparing f(n) with some standard functions. The most
common computing times are:
O(1), O(log2 n), O(n), O(n. log2 n), O(n2), O(n3), O(2n), n! and nn
Numerical Comparison of Different Algorithms
The execution time for six of the typical functions is given below:
S.No

log n

n

n. log n

n2

n3

2n

1

0

1

1

1

1

2

2

1

2

2

4

8

4

3

2

4

8

16

64

16

4

3

8

24

64

512

256

5

4

16

64

256

4096

65536

Graph of log n, n, n log n, n2, n3, 2n, n! and nn

O(log n) does not depend on the base of the logarithm. To simplify the analysis, the convention
will not have any particular units of time. Thus we throw away leading constants. We will also
throw away low–order terms while computing a Big–Oh running time. Since Big-Oh is an upper
bound, the answer provided is a guarantee that the program will terminate within a certain
time period. The program may stop earlier than this, but never later.

Lecture Notes

10

Dept. of Information Technology

One way to compare the function f(n) with these standard function is to use the functional ‘O’
notation, suppose f(n) and g(n) are functions defined on the positive integers with the property
that f(n) is bounded by some multiple g(n) for almost all ‘n’. Then,
f(n) = O(g(n))
Which is read as “f(n) is of order g(n)”. For example, the order of complexity for:
•
•
•
•

Linear search is O(n)
Binary search is O(log n)
Bubble sort is O(n2)
Quick sort is O(n log n)

For example, if the first program takes 100n2 milliseconds. While the second taken 5n3
milliseconds. Then might not 5n3 program better than 100n2 program?
As the programs can be evaluated by comparing their running time functions, with constants by
proportionality neglected. So, 5n3 program be better than the 100n2 program.
5 n3/100 n2 = n/20
for inputs n < 20, the program with running time 5n3 will be faster those the one with running
time 100 n2.
Therefore, if the program is to be run mainly on inputs of small size, we would indeed prefer
the program whose running time was O(n3)
However, as ‘n’ gets large, the ratio of the running times, which is n/20, gets arbitrarily larger.
Thus, as the size of the input increases, the O(n3) program will take significantly more time
than the O(n2) program. So it is always better to prefer a program whose running time with the
lower growth rate. The low growth rate function’s such as O(n) or O(n log n) are always better.
Exercises

1. Define algorithm.
2. State the various steps in developing algorithms?
3. State the properties of algorithms.
4. Define efficiency of an algorithm?
5. State the various methods to estimate the efficiency of an algorithm.
6. Define time complexity of an algorithm?
7. Define worst case of an algorithm.
8. Define average case of an algorithm.
9. Define best case of an algorithm.
10. Mention the various spaces utilized by a program.

Lecture Notes

11

Dept. of Information Technology

11. Define space complexity of an algorithm.
12. State the different memory spaces occupied by an algorithm.
Multiple Choice Questions
1.

_____ is a step-by-step recipe for solving an instance of problem.
A. Algorithm
B. Complexity
C. Pseudocode
D. Analysis

[

A

]

2.

______ is used to describe the algorithm, in less formal language.
A. Cannot be defined
B. Natural Language
C. Pseudocode
D. None

[

C

]

3.

______ of an algorithm is the amount of time (or the number of steps)
needed by a program to complete its task.
A. Space Complexity
B. Dynamic Programming
C. Divide and Conquer
D. Time Complexity

[

D

]

4.

______ of a program is the amount of memory used at once by the
algorithm until it completes its execution.

[

C

]

[

A

]

A. Divide and Conquer
C. Space Complexity
5.

B. Time Complexity
D. Dynamic Programming

______ is used to define the worst-case running time of an algorithm.
A. Big-Oh notation
B. Cannot be defined
C. Complexity
D. Analysis

Lecture Notes

12

Dept. of Information Technology

Chapter

2

Recursion
Recursion is deceptively simple in statement but exceptionally
complicated in implementation. Recursive procedures work fine in many
problems. Many programmers prefer recursion through simpler
alternatives are available. It is because recursion is elegant to use
through it is costly in terms of time and space. But using it is one thing
and getting involved with it is another.
In this unit we will look at “recursion” as a programmer who not only
loves it but also wants to understand it! With a bit of involvement it is
going to be an interesting reading for you.
2.1.

Introduction to Recursion:

A function is recursive if a statement in the body of the function calls itself. Recursion is
the process of defining something in terms of itself. For a computer language to be
recursive, a function must be able to call itself.
For example, let us consider the function factr() shown below, which computers the
factorial of an integer.
#include <stdio.h>
int factorial (int);
main()
{
int num, fact;
printf (“Enter a positive integer value: ");
scanf (“%d”, &num);
fact = factorial (num);
printf ("\n Factorial of %d =%5d\n", num, fact);
}
int factorial (int n)
{
int result;
if (n == 0)
return (1);
else
result = n * factorial (n-1);
}

return (result);

A non-recursive or iterative version for finding the factorial is as follows:
factorial (int n)
{
int i, result = 1;
if (n == 0)

Lecture Notes

13

Dept. of Information Technology

return (result);
else
{
for (i=1; i<=n; i++)
result = result * i;
}
return (result);
}
The operation of the non-recursive version is clear as it uses a loop starting at 1 and
ending at the target value and progressively multiplies each number by the moving
product.
When a function calls itself, new local variables and parameters are allocated storage
on the stack and the function code is executed with these new variables from the start.
A recursive call does not make a new copy of the function. Only the arguments and
variables are new. As each recursive call returns, the old local variables and
parameters are removed from the stack and execution resumes at the point of the
function call inside the function.
When writing recursive functions, you must have a exit condition somewhere to force
the function to return without the recursive call being executed. If you do not have an
exit condition, the recursive function will recurse forever until you run out of stack
space and indicate error about lack of memory, or stack overflow.
2.2.

Differences between recursion and iteration:
•
•
•

Both involve repetition.
Both involve a termination test.
Both can occur infinitely.
Iteration

Recursion

Iteration explicitly user a repetition
structure.
Iteration terminates when the loop
continuation.
Iteration keeps modifying the counter
until the loop continuation condition
fails.
Iteration normally occurs within a loop
so the extra memory assigned is
omitted.
It reduces the processor’s operating
time.
2.3.

Recursion achieves repetition through
repeated function calls.
Recursion terminates when a base case
is recognized.
Recursion keeps producing simple
versions of the original problem until
the base case is reached.
Recursion causes another copy of the
function and hence a considerable
memory space’s occupied.
It increases the processor’s operating
time.

Factorial of a given number:

The operation of recursive factorial function is as follows:
Start out with some natural number N (in our example, 5). The recursive definition is:
n = 0, 0 ! = 1
n > 0, n ! = n * (n - 1) !

Lecture Notes

Base Case
Recursive Case

14

Dept. of Information Technology

Recursion Factorials:
5! =5 * 4! = 5 *___ = ____

factr(5) = 5 * factr(4) = __

4! = 4 *3! = 4 *___ = ___

factr(4) = 4 * factr(3) = __

3! = 3 * 2! = 3 * ___ = ___
2! = 2 * 1! = 2 * ___ = ___

factr(3) = 3 * factr(2) = __
factr(2) = 2 * factr(1) = __

1! = 1 * 0! = 1 * __ = __ factr(1) = 1 * factr(0) = __
0! = 1

factr(0) = __

5! = 5*4! = 5*4*3! = 5*4*3*2! = 5*4*3*2*1! = 5*4*3*2*1*0! = 5*4*3*2*1*1
=120
We define 0! to equal 1, and we define factorial N (where N > 0), to be N * factorial
(N-1). All recursive functions must have an exit condition, that is a state when it does
not recurse upon itself. Our exit condition in this example is when N = 0.
Tracing of the flow of the factorial () function:
When the factorial function is first called with, say, N = 5, here is what happens:
FUNCTION:
Does N = 0? No
Function Return Value = 5 * factorial (4)
At this time, the function factorial is called again, with N = 4.
FUNCTION:
Does N = 0? No
Function Return Value = 4 * factorial (3)
At this time, the function factorial is called again, with N = 3.
FUNCTION:
Does N = 0? No
Function Return Value = 3 * factorial (2)
At this time, the function factorial is called again, with N = 2.
FUNCTION:
Does N = 0? No
Function Return Value = 2 * factorial (1)
At this time, the function factorial is called again, with N = 1.
FUNCTION:
Does N = 0? No
Function Return Value = 1 * factorial (0)
At this time, the function factorial is called again, with N = 0.
FUNCTION:
Does N = 0? Yes
Function Return Value = 1

Lecture Notes

15

Dept. of Information Technology

Now, we have to trace our way back up! See, the factorial function was called six
times. At any function level call, all function level calls above still exist! So, when we
have N = 2, the function instances where N = 3, 4, and 5 are still waiting for their
return values.
So, the function call where N = 1 gets retraced first, once the final call returns 0. So,
the function call where N = 1 returns 1*1, or 1. The next higher function call, where N
= 2, returns 2 * 1 (1, because that's what the function call where N = 1 returned). You
just keep working up the chain.
When
When
When
When

N
N
N
N

=
=
=
=

2,
3,
4,
5,

2
3
4
5

*
*
*
*

1, or 2 was returned.
2, or 6 was returned.
6, or 24 was returned.
24, or 120 was returned.

And since N = 5 was the first function call (hence the last one to be recalled), the value
120 is returned.
2.4.

The Towers of Hanoi:

In the game of Towers of Hanoi, there are three towers labeled 1, 2, and 3. The game
starts with n disks on tower A. For simplicity, let n is 3. The disks are numbered from 1
to 3, and without loss of generality we may assume that the diameter of each disk is
the same as its number. That is, disk 1 has diameter 1 (in some unit of measure), disk
2 has diameter 2, and disk 3 has diameter 3. All three disks start on tower A in the
order 1, 2, 3. The objective of the game is to move all the disks in tower 1 to entire
tower 3 using tower 2. That is, at no time can a larger disk be placed on a smaller disk.
Figure 3.11.1, illustrates the initial setup of towers of Hanoi. The figure 3.11.2,
illustrates the final setup of towers of Hanoi.
The rules to be followed in moving the disks from tower 1 tower 3 using tower 2 are as
follows:
•
•
•

Only one disk can be moved at a time.
Only the top disc on any tower can be moved to any other tower.
A larger disk cannot be placed on a smaller disk.

T o w er 1

T o w er 2

T o w er 3

F i g. 3. 1 1. 1. I n it i a l s et u p of T o w er s of Ha n o i

Lecture Notes

16

Dept. of Information Technology

T o w er 1

T o w er 2

T o w er 3

F i g 3. 1 1. 2. F i n a l s et u p of T o w er s of Ha n o i

The towers of Hanoi problem can be easily implemented using recursion. To move the
largest disk to the bottom of tower 3, we move the remaining n – 1 disks to tower 2
and then move the largest disk to tower 3. Now we have the remaining n – 1 disks to
be moved to tower 3. This can be achieved by using the remaining two towers. We can
also use tower 3 to place any disk on it, since the disk placed on tower 3 is the largest
disk and continue the same operation to place the entire disks in tower 3 in order.
The program that uses recursion to produce a list of moves that shows how to
accomplish the task of transferring the n disks from tower 1 to tower 3 is as follows:
#include <stdio.h>
#include <conio.h>
void towers_of_hanoi (int n, char *a, char *b, char *c);
int cnt=0;
int main (void)
{
int n;
printf("Enter number of discs: ");
scanf("%d",&n);
towers_of_hanoi (n, "Tower 1", "Tower 2", "Tower 3");
getch();
}
void towers_of_hanoi (int n, char *a, char *b, char *c)
{
if (n == 1)
{
++cnt;
printf ("\n%5d: Move disk 1 from %s to %s", cnt, a, c);
return;
}
else
{
towers_of_hanoi (n-1, a, c, b);
++cnt;
printf ("\n%5d: Move disk %d from %s to %s", cnt, n, a, c);
towers_of_hanoi (n-1, b, a, c);
return;
}
}

Lecture Notes

17

Dept. of Information Technology

Output of the program:
RUN 1:
Enter the number of discs: 3
1:

Move disk 1 from tower 1 to tower 3.

2:

Move disk 2 from tower 1 to tower 2.

3:

Move disk 1 from tower 3 to tower 2.

4:

Move disk 3 from tower 1 to tower 3.

5:

Move disk 1 from tower 2 to tower 1.

6:

Move disk 2 from tower 2 to tower 3.

7:

Move disk 1 from tower 1 to tower 3.

RUN 2:
Enter the number of discs: 4
1:

Move disk 1 from tower 1 to tower 2.

2:

Move disk 2 from tower 1 to tower 3.

3:

Move disk 1 from tower 2 to tower 3.

4:

Move disk 3 from tower 1 to tower 2.

5:

Move disk 1 from tower 3 to tower 1.

6:

Move disk 2 from tower 3 to tower 2.

7:

Move disk 1 from tower 1 to tower 2.

8:

Move disk 4 from tower 1 to tower 3.

9:

Move disk 1 from tower 2 to tower 3.

10:

Move disk 2 from tower 2 to tower 1.

11:

Move disk 1 from tower 3 to tower 1.

12:

Move disk 3 from tower 2 to tower 3.

13:

Move disk 1 from tower 1 to tower 2.

14:

Move disk 2 from tower 1 to tower 3.

15:

Move disk 1 from tower 2 to tower 3.

2.5.

Fibonacci Sequence Problem:

A Fibonacci sequence starts with the integers 0 and 1. Successive elements in this
sequence are obtained by summing the preceding two elements in the sequence. For
example, third number in the sequence is 0 + 1 = 1, fourth number is 1 + 1= 2, fifth
number is 1 + 2 = 3 and so on. The sequence of Fibonacci integers is given below:
0 1 1 2 3 5 8 13 21 . . . . . . . . .

Lecture Notes

18

Dept. of Information Technology

A recursive definition for the Fibonacci sequence of integers may be defined as follows:
Fib (n) = n if n = 0 or n = 1
Fib (n) = fib (n-1) + fib (n-2) for n >=2
We will now use the definition to compute fib(5):

fib(5) = fib(4) + fib(3)
fib(3) + fib(2) + fib(3)
fib(2) + fib(1) + fib(2) + fib(3)
fib(1) + fib(0) + fib(1) + fib(2) + fib(3)
1 + 0 + 1 + fib(1) + fib(0) + fib(3)
1 + 0 + 1 + 1 + 0 + fib(2) + fib(1)
1 + 0 + 1 + 1 + 0 + fib(1) + fib(0) + fib(1)
1+0 +1 +1+0 +1 +0 +1 =5
We see that fib(2) is computed 3 times, and fib(3), 2 times in the above calculations.
We save the values of fib(2) or fib(3) and reuse them whenever needed.
A recursive function to compute the Fibonacci number in the nth position is given below:
main()
{
}
fib(n)
int n;
{

clrscr ();
printf (“=nfib(5) is %d”, fib(5));

int x;
if (n==0 | | n==1)
return n;
x=fib(n-1) + fib(n-2);
return (x);

}
Output:
fib(5) is 5

Lecture Notes

19

Dept. of Information Technology

2.6.

Program using recursion to calculate the NCR of a given number:

#include<stdio.h>
float ncr (int n, int r);
void main()
{
int n, r, result;
printf(“Enter the value of N and R :”);
scanf(“%d %d”, &n, &r);
result = ncr(n, r);
printf(“The NCR value is %.3f”, result);
}
float ncr (int n, int r)
{
if(r == 0)
return 1;
else
return(n * 1.0 / r * ncr (n-1, r-1));
}
Output:
Enter the value of N and R: 5
The NCR value is: 10.00
2.7.

2

Program to calculate the least common multiple of a given number:

#include<stdio.h>
int alone(int a[], int n);
long int lcm(int a[], int n, int prime);
void main()
{
int a[20], status, i, n, prime;
printf (“Enter the limit: “);
scanf(“%d”, &n);
printf (“Enter the numbers : “);
for (i = 0; i < n; i++)
scanf(“%d”, &a[i]);
printf (“The least common multiple is %ld”, lcm(a, n, 2));
}
int alone (int a[], int n);
{
int k;
for (k = 0; k < n; k++)
if (a[k] != 1)
return 0;
return 1;
}

Lecture Notes

20

Dept. of Information Technology

long int lcm (int a[], int n, int prime)
{
int i, status;
status = 0;
if (allone(a, n))
return 1;
for (i = 0; i < n; i++)
if ((a[i] % prime) == 0)
{
status = 1;
a[i] = a[i] / prime;
}
if (status == 1)
return (prime * lcm(a, n, prime));
else
return (lcm (a, n, prime = (prime == 2) ? prime+1 : prime+2));
}
Output:
Enter the limit: 6
Enter the numbers: 6 5 4 3 2 1
The least common multiple is 60
2.8.

Program to calculate the greatest common divisor:

#include<stdio.h>
int check_limit (int a[], int n, int prime);
int check_all (int a[], int n, int prime);
long int gcd (int a[], int n, int prime);
void main()
{
int a[20], stat, i, n, prime;
printf (“Enter the limit: “);
scanf (“%d”, &n);
printf (“Enter the numbers: “);
for (i = 0; i < n; i ++)
scanf (“%d”, &a[i]);
printf (“The greatest common divisor is %ld”, gcd (a, n, 2));
}
int check_limit (int a[], int n, int prime)
{
int i;
for (i = 0; i < n; i++)
if (prime > a[i])
return 1;
return 0;
}

Lecture Notes

21

Dept. of Information Technology

int check_all (int a[], int n, int prime)
{
int i;
for (i = 0; i < n; i++)
if ((a[i] % prime) != 0)
return 0;
for (i = 0; i < n; i++)
a[i] = a[i] / prime;
return 1;
}
long int gcd (int a[], int n, int prime)
{
int i;
if (check_limit(a, n, prime))
return 1;
if (check_all (a, n, prime))
return (prime * gcd (a, n, prime));
else
return (gcd (a, n, prime = (prime == 2) ? prime+1 : prime+2));
}
Output:
Enter the limit: 5
Enter the numbers: 99
55
22
The greatest common divisor is 11

77

121

Exercises
1.

What is the importance of the stopping case in recursive functions?

2.

Write a function with one positive integer parameter called n. The function will
write 2^n-1 integers (where ^ is the exponentiation operation). Here are the
patterns of output for various values of n:
n=1:
n=2:
n=3:
n=4:

Output
Output
Output
Output

is:
is:
is:
is:

1
121
1213121
121312141213121

And so on. Note that the output for n always consists of the output for n-1,
followed by n itself, followed by a second copy of the output for n-1.
3.

Write a recursive function for the mathematical function:
f(n) = 1
if n = 1
f(n) = 2 * f(n-1) if n >= 2

4.

Which method is preferable in general?
a) Recursive method
b) Non-recursive method

5.

Write a function using Recursion to print numbers from n to 0.

6.

Write a function using Recursion to enter and display a string in reverse and
state whether the string contains any spaces. Don't use arrays/strings.

Lecture Notes

22

Dept. of Information Technology

7.

Write a function using Recursion to check if a number n is prime. (You have to
check whether n is divisible by any number below n)

8.

Write a function using Recursion to enter characters one by one until a space is
encountered. The function should return the depth at which the space was
encountered.
Multiple Choice Questions

1.

In a single function declaration, what is the maximum number of
statements that may be recursive calls?
A. 1
B. 2
C. n (where n is the argument)
D. There is no fixed maximum

[

]

2.

What is the maximum depth of recursive calls a function may make?
A. 1
B. 2
C. n (where n is the argument)
D. There is no fixed maximum

[

]

3.

Consider the following function:
void super_write_vertical (int number)
{
if (number < 0)
{
printf(“ - ”);
super_write_vertical(abs(number));
}
else if (number < 10)
printf(“%d\n”, number);
else
{
super_write_vertical(number/10);
printf(“%d\n”, number % 10);
}
}
What values of number are directly handled by the stopping case?
A. number < 0
B. number < 10
C. number >= 0 && number < 10
D. number > 10

[

]

4.

Consider the following function:
void super_write_vertical(int number)
{
if (number < 0)
{
printf(“ - ”);
super_write_vertical (abs(number));
}
else if (number < 10)
printf(“%d\n”, number);
else
{
super_write_vertical(number/10);
printf(“%d\n”, number % 10);
}
}
Which call will result in the most recursive calls?
A. super_write_vertical(-1023)
B. super_write_vertical(0)
C. super_write_vertical(100)
D. super_write_vertical(1023)

[

]

Lecture Notes

23

Dept. of Information Technology

5.

Consider this function declaration:

[

]

void quiz (int i)
{
if (i > 1)
{
quiz(i / 2);
quiz(i / 2);
}
printf(“ * ”);
}
How many asterisks are printed by the function call quiz(5)?
A. 3
B. 4
C. 7
D. 8
6.

In a real computer, what will happen if you make a recursive call without
making the problem smaller?
A. The operating system detects the infinite recursion because of the
"repeated state"
B. The program keeps running until you press Ctrl-C
C. The results are non-deterministic
D. The run-time stack overflows, halting the program

[

]

7.

When the compiler compiles your program, how is a recursive call
treated differently than a non-recursive function call?
A. Parameters are all treated as reference arguments
B. Parameters are all treated as value arguments
C. There is no duplication of local variables
D. None of the above

[

]

8.

When a function call is executed, which information is not saved in the
activation record?
A. Current depth of recursion.
B. Formal parameters.
C. Location where the function should return when done.
D. Local variables

[

]

9.

What technique is often used to prove the correctness of a recursive
function?
A. Communitivity.
B. Diagonalization.
C. Mathematical induction.
D. Matrix Multiplication.

[

]

Lecture Notes

24

Dept. of Information Technology

Chapter

3
LINKED LISTS
In this chapter, the list data structure is presented. This structure can be used
as the basis for the implementation of other data structures (stacks, queues
etc.). The basic linked list can be used without modification in many programs.
However, some applications require enhancements to the linked list design.
These enhancements fall into three broad categories and yield variations on
linked lists that can be used in any combination: circular linked lists, double
linked lists and lists with header nodes.

Linked lists and arrays are similar since they both store collections of data. Array is the
most common data structure used to store collections of elements. Arrays are
convenient to declare and provide the easy syntax to access any element by its index
number. Once the array is set up, access to any element is convenient and fast. The
disadvantages of arrays are:
•

The size of the array is fixed. Most often this size is specified at compile
time. This makes the programmers to allocate arrays, which seems "large
enough" than required.

•

Inserting new elements at the front is potentially expensive because existing
elements need to be shifted over to make room.

•

Deleting an element from an array is not possible.

Linked lists have their own strengths and weaknesses, but they happen to be strong
where arrays are weak. Generally array's allocates the memory for all its elements in
one block whereas linked lists use an entirely different strategy. Linked lists allocate
memory for each element separately and only when necessary.
Here is a quick review of the terminology and rules of pointers. The linked list code will
depend on the following functions:
malloc() is a system function which allocates a block of memory in the "heap" and
returns a pointer to the new block. The prototype of malloc() and other heap functions
are in stdlib.h. malloc() returns NULL if it cannot fulfill the request. It is defined by:
void *malloc (number_of_bytes)
Since a void * is returned the C standard states that this pointer can be converted to
any type. For example,
char *cp;
cp = (char *) malloc (100);
Attempts to get 100 bytes and assigns the starting address to cp. We can also use the
sizeof() function to specify the number of bytes. For example,
int *ip;
ip = (int *) malloc (100*sizeof(int));

Lecture Notes

25

Dept. of Information Technology

free() is the opposite of malloc(), which de-allocates memory. The argument to free()
is a pointer to a block of memory in the heap — a pointer which was obtained by a
malloc() function. The syntax is:
free (ptr);
The advantage of free() is simply memory management when we no longer need a
block.
3.1.

Linked List Concepts:

A linked list is a non-sequential collection of data items. It is a dynamic data structure.
For every data item in a linked list, there is an associated pointer that would give the
memory location of the next data item in the linked list.
The data items in the linked list are not in consecutive memory locations. They may be
anywhere, but the accessing of these data items is easier as each data item contains
the address of the next data item.
Advantages of linked lists:
Linked lists have many advantages. Some of the very important advantages are:
1.
2.
3.
4.

Linked lists are dynamic data structures. i.e., they can grow or shrink during
the execution of a program.
Linked lists have efficient memory utilization. Here, memory is not preallocated. Memory is allocated whenever it is required and it is de-allocated
(removed) when it is no longer needed.
Insertion and Deletions are easier and efficient. Linked lists provide flexibility
in inserting a data item at a specified position and deletion of the data item
from the given position.
Many complex applications can be easily carried out with linked lists.

Disadvantages of linked lists:
1.
2.
3.2.

It consumes more space because every node requires a additional pointer to
store address of the next node.
Searching a particular element in list is difficult and also time consuming.

Types of Linked Lists:

Basically we can put linked lists into the following four items:
1.

Single Linked List.

2.

Double Linked List.

3.

Circular Linked List.

4.

Circular Double Linked List.

A single linked list is one in which all nodes are linked together in some sequential
manner. Hence, it is also called as linear linked list.

Lecture Notes

26

Dept. of Information Technology

A double linked list is one in which all nodes are linked together by multiple links which
helps in accessing both the successor node (next node) and predecessor node
(previous node) from any arbitrary node within the list. Therefore each node in a
double linked list has two link fields (pointers) to point to the left node (previous) and
the right node (next). This helps to traverse in forward direction and backward
direction.
A circular linked list is one, which has no beginning and no end. A single linked list can
be made a circular linked list by simply storing address of the very first node in the link
field of the last node.
A circular double linked list is one, which has both the successor pointer and
predecessor pointer in the circular manner.
Comparison between array and linked list:
ARRAY

LINKED LIST

Size of an array is fixed

Size of a list is not fixed

Memory is allocated from stack

Memory is allocated from heap

It is necessary to specify the number of
elements during declaration (i.e., during
compile time).

It is not necessary to specify the
number of elements during declaration
(i.e., memory is allocated during run
time).
It occupies more memory.

It occupies less memory than a linked
list for the same number of elements.
Inserting new elements at the front is
potentially expensive because existing
elements need to be shifted over to
make room.
Deleting an element from an array is
not possible.

Inserting a new element at any position
can be carried out easily.
Deleting an element is possible.

Trade offs between linked lists and arrays:

FEATURE

ARRAYS

LINKED LISTS

Sequential access

efficient

efficient

Random access

efficient

inefficient

Resigning

inefficient

efficient

Element rearranging

inefficient

efficient

Overhead per elements

none

1 or 2 links

Lecture Notes

27

Dept. of Information Technology

Applications of linked list:
1.

Linked lists are used to represent and manipulate polynomial. Polynomials are
expression containing terms with non zero coefficient and exponents. For
example:
P(x) = a0 Xn + a1 Xn-1 + …… + an-1 X + an

2.

Represent very large numbers and operations of the large number such as
addition, multiplication and division.

3.

Linked lists are to implement stack, queue, trees and graphs.

4.

Implement the symbol table in compiler construction

3.3.

Single Linked List:

A linked list allocates space for each element separately in its own block of memory
called a "node". The list gets an overall structure by using pointers to connect all its
nodes together like the links in a chain. Each node contains two fields; a "data" field to
store whatever element, and a "next" field which is a pointer used to link to the next
node. Each node is allocated in the heap using malloc(), so the node memory
continues to exist until it is explicitly de-allocated using free(). The front of the list is a
pointer to the “start” node.
A single linked list is shown in figure 3.2.1.
STACK

HEAP

100
start
The start
pointer holds
the address
of the first
node of the
list.

10

200

100
Each node stores
the data.

20

300

200

30
300

Stores the next
node address.

400

40

X

400
The next field of the
last node is NULL.

Figure 3.2.1. Single Linked List

The beginning of the linked list is stored in a "start" pointer which points to the first
node. The first node contains a pointer to the second node. The second node contains a
pointer to the third node, ... and so on. The last node in the list has its next field set to
NULL to mark the end of the list. Code can access any node in the list by starting at the
start and following the next pointers.
The start pointer is an ordinary local pointer variable, so it is drawn separately on the
left top to show that it is in the stack. The list nodes are drawn on the right to show
that they are allocated in the heap.

Lecture Notes

28

Dept. of Information Technology

Implementation of Single Linked List:
Before writing the code to build the above list, we need to create a start node, used to
create and access other nodes in the linked list. The following structure definition will
do (see figure 3.2.2):
•

Creating a structure with one data item and a next pointer, which will be
pointing to next node of the list. This is called as self-referential structure.

•

Initialise the start pointer to be NULL.

struct slinklist
{
int data;
struct slinklist* next;
};

node:

data

typedef struct slinklist node;

next

start
Empty list:

node *start = NULL;

NULL

Figure 3.2.2. Structure definition, single link node and empty list

The basic operations in a single linked list are:
•

Creation.

•

Insertion.

•

Deletion.

•

Traversing.

Creating a node for Single Linked List:
Creating a singly linked list starts with creating a node. Sufficient memory has to be
allocated for creating a node. The information is stored in the memory, allocated by
using the malloc() function. The function getnode(), is used for creating a node, after
allocating memory for the structure of type node, the information for the item (i.e.,
data) has to be read from the user, set next field to NULL and finally returns the
address of the node. Figure 3.2.3 illustrates the creation of a node for single linked list.

node* getnode()
{
node* newnode;
newnode = (node *) malloc(sizeof(node));
printf("\n Enter data: ");
scanf("%d", &newnode -> data);
newnode -> next = NULL;
return newnode;
}

newnode

10

X

100

Figure 3.2.3. new node with a value of 10

Lecture Notes

29

Dept. of Information Technology

Creating a Singly Linked List with ‘n’ number of nodes:
The following steps are to be followed to create ‘n’ number of nodes:
•

Get the new node using getnode().
newnode = getnode();

•

If the list is empty, assign new node as start.
start = newnode;

•

If the list is not empty, follow the steps given below:

•

•

The next field of the new node is made to point the first node (i.e.
start node) in the list by assigning the address of the first node.

•

The start pointer is made to point the new node by assigning the
address of the new node.

Repeat the above steps ‘n’ times.

Figure 3.2.4 shows 4 items in a single linked list stored at different locations in
memory.
start
100
10
100

200

20

300

200

30

400

300

40

X

400

Figure 3.2.4. Single Linked List with 4 nodes

The function createlist(), is used to create ‘n’ number of nodes:
vo id c r e at e list( int n)
{
int i;
no d e * ne w no d e;
no d e *t e m p ;
fo r( i = 0; i < n ; i+ + )
{
ne w no d e = g et no d e();
if(st a rt = = N U L L)
{
sta rt = ne w no d e;
}
e ls e
{
te m p = st a rt;
w hile(t e m p - > ne xt ! = N U L L)
te m p = t e m p - > ne xt;
te m p - > ne xt = ne w no d e;
}
}
}

Lecture Notes

30

Dept. of Information Technology

Insertion of a Node:
One of the most primitive operations that can be done in a singly linked list is the
insertion of a node. Memory is to be allocated for the new node (in a similar way that is
done while creating a list) before reading the data. The new node will contain empty
data field and empty next field. The data field of the new node is then stored with the
information read from the user. The next field of the new node is assigned to NULL. The
new node can then be inserted at three different places namely:
•

Inserting a node at the beginning.

•

Inserting a node at the end.

•

Inserting a node at intermediate position.

Inserting a node at the beginning:
The following steps are to be followed to insert a new node at the beginning of the list:
•

Get the new node using getnode().
newnode = getnode();

•

If the list is empty then start = newnode.

•

If the list is not empty, follow the steps given below:
newnode -> next = start;
start = newnode;

Figure 3.2.5 shows inserting a node into the single linked list at the beginning.
start

500
10
100
5

200

20

300

200

30

400

300

40

X

400

100

500

Figure 3.2.5. Inserting a node at the beginning

The function insert_at_beg(), is used for inserting a node at the beginning
void insert_at_beg()
{
node *newnode;
newnode = getnode();
if(start == NULL)
{
start = newnode;
}
else
{
newnode -> next = start;
start = newnode;
}
}
Lecture Notes

31

Dept. of Information Technology

Inserting a node at the end:
The following steps are followed to insert a new node at the end of the list:
•

Get the new node using getnode()
newnode = getnode();

•

If the list is empty then start = newnode.

•

If the list is not empty follow the steps given below:
temp = start;
while(temp -> next != NULL)
temp = temp -> next;
temp -> next = newnode;

Figure 3.2.6 shows inserting a node into the single linked list at the end.
start
100
10
100

200

20

300

200

30

40

400

300

500

400

50

X

500
Figure 3.2.6. Inserting a node at the end.

The function insert_at_end(), is used for inserting a node at the end.
void insert_at_end()
{
node *newnode, *temp;
newnode = getnode();
if(start == NULL)
{
start = newnode;
}
else
{
temp = start;
while(temp -> next != NULL)
temp = temp -> next;
temp -> next = newnode;
}
}

Inserting a node at intermediate position:
The following steps are followed, to insert a new node in an intermediate position in the
list:
•

Get the new node using getnode().
newnode = getnode();

Lecture Notes

32

Dept. of Information Technology

•

Ensure that the specified position is in between first node and last node. If
not, specified position is invalid. This is done by countnode() function.

•

Store the starting address (which is in start pointer) in temp and prev
pointers. Then traverse the temp pointer upto the specified position followed
by prev pointer.

•

After reaching the specified position, follow the steps given below:
prev -> next = newnode;
newnode -> next = temp;

•

Let the intermediate position be 3.

Figure 3.2.7 shows inserting a node into the single linked list at a specified
intermediate position other than beginning and end.
start

prev

temp

100
10
100

200

20

500

200

30

400

300

50
500

40

X

400

300
new node

Figure 3.2.7. Inserting a node at an intermediate position.

The function insert_at_mid(), is used for inserting a node in the intermediate position.
void insert_at_mid()
{
node *newnode, *temp, *prev;
int pos, nodectr, ctr = 1;
newnode = getnode();
printf("\n Enter the position: ");
scanf("%d", &pos);
nodectr = countnode(start);
if(pos > 1 && pos < nodectr)
{
temp = prev = start;
while(ctr < pos)
{
prev = temp;
temp = temp -> next;
ctr++;
}
prev -> next = newnode;
newnode -> next = temp;
}
else
{
printf("position %d is not a middle position", pos);
}
}

Lecture Notes

33

Dept. of Information Technology

Deletion of a node:
Another primitive operation that can be done in a singly linked list is the deletion of a
node. Memory is to be released for the node to be deleted. A node can be deleted from
the list from three different places namely.
•

Deleting a node at the beginning.

•

Deleting a node at the end.

•

Deleting a node at intermediate position.

Deleting a node at the beginning:
The following steps are followed, to delete a node at the beginning of the list:
•

If list is empty then display ‘Empty List’ message.

•

If the list is not empty, follow the steps given below:
temp = start;
start = start -> next;
free(temp);

Figure 3.2.8 shows deleting a node at the beginning of a single linked list.
start

200
10
temp

100

200

20

300

200

30

400

300

40

X

400

Figure 3.2.8. Deleting a node at the beginning.

The function delete_at_beg(), is used for deleting the first node in the list.
void delete_at_beg()
{
node *temp;
if(start == NULL)
{
printf("\n No nodes are exist..");
return ;
}
else
{
temp = start;
start = temp -> next;
free(temp);
printf("\n Node deleted ");
}
}

Lecture Notes

34

Dept. of Information Technology

Deleting a node at the end:
The following steps are followed to delete a node at the end of the list:
•

If list is empty then display ‘Empty List’ message.

•

If the list is not empty, follow the steps given below:
temp = prev = start;
while(temp -> next != NULL)
{
prev = temp;
temp = temp -> next;
}
prev -> next = NULL;
free(temp);

Figure 3.2.9 shows deleting a node at the end of a single linked list.
start

100
10
100

200

20

300

200

X

30
300

40

X

400

Figure 3.2.9. Deleting a node at the end.

The function delete_at_last(), is used for deleting the last node in the list.
void delete_at_last()
{
node *temp, *prev;
if(start == NULL)
{
printf("\n Empty List..");
return ;
}
else
{
temp = start;
prev = start;
while(temp -> next != NULL)
{
prev = temp;
temp = temp -> next;
}
prev -> next = NULL;
free(temp);
printf("\n Node deleted ");
}
}

Lecture Notes

35

Dept. of Information Technology

Deleting a node at Intermediate position:
The following steps are followed, to delete a node from an intermediate position in the
list (List must contain more than two node).
•

If list is empty then display ‘Empty List’ message

•

If the list is not empty, follow the steps given below.
if(pos > 1 && pos < nodectr)
{
temp = prev = start;
ctr = 1;
while(ctr < pos)
{
prev = temp;
temp = temp -> next;
ctr++;
}
prev -> next = temp -> next;
free(temp);
printf("\n node deleted..");
}

Figure 3.2.10 shows deleting a node at a specified intermediate position other than
beginning and end from a single linked list.
start
100
10
100

300

20

300

200

30

400

300

40

X

400

Figure 3.2.10. Deleting a node at an intermediate position.

The function delete_at_mid(), is used for deleting the intermediate node in the list.
void delete_at_mid()
{
int ctr = 1, pos, nodectr;
node *temp, *prev;
if(start == NULL)
{
printf("\n Empty List..");
return ;
}
else
{
printf("\n Enter position of node to delete: ");
scanf("%d", &pos);
nodectr = countnode(start);
if(pos > nodectr)
{
printf("\nThis node doesnot exist");
}
Lecture Notes

36

Dept. of Information Technology

if(pos > 1 && pos < nodectr)
{
temp = prev = start;
while(ctr < pos)
{
prev = temp;
temp = temp -> next;
ctr ++;
}
prev -> next = temp -> next;
free(temp);
printf("\n Node deleted..");
}
else
{
printf("\n Invalid position..");
getch();
}
}

}

Traversal and displaying a list (Left to Right):
To display the information, you have to traverse (move) a linked list, node by node
from the first node, until the end of the list is reached. Traversing a list involves the
following steps:
•

Assign the address of start pointer to a temp pointer.

•

Display the information from the data field of each node.

The function traverse() is used for traversing and displaying the information stored in
the list from left to right.
void traverse()
{
node *temp;
temp = start;
printf("\n The contents of List (Left to Right): \n");
if(start == NULL )
printf("\n Empty List");
else
{
while (temp != NULL)
{
printf("%d ->", temp -> data);
temp = temp -> next;
}
}
printf("X");
}

Alternatively there is another way to traverse and display the information. That is in
reverse order. The function rev_traverse(), is used for traversing and displaying the
information stored in the list from right to left.

Lecture Notes

37

Dept. of Information Technology

vo id r e v_t r a v e rs e( no d e *st)
{
if(st = = N U L L)
{
r et ur n;
}
e ls e
{
r e v_t r a v e rs e(st - > ne xt);
p r intf(" % d - > " , st - > d at a);
}
}

Counting the Number of Nodes:
The following code will count the number of nodes exist in the list using recursion.
int co unt no d e( no d e *st)
{
if(st = = N U L L)
r et ur n 0;
e ls e
r et ur n(1 + co unt no d e(st - > ne xt));
}

3.3.1.

Source Code for the Implementation of Single Linked List:
# include <stdio.h>
# include <conio.h>
# include <stdlib.h>
struct slinklist
{
int data;
struct slinklist *next;
};
typedef struct slinklist node;
node *start = NULL;
int menu()
{
int ch;
clrscr();
printf("\n 1.Create a list ");
printf("\n--------------------------");
printf("\n 2.Insert a node at beginning ");
printf("\n 3.Insert a node at end");
printf("\n 4.Insert a node at middle");
printf("\n--------------------------");
printf("\n 5.Delete a node from beginning");
printf("\n 6.Delete a node from Last");
printf("\n 7.Delete a node from Middle");
printf("\n--------------------------");
printf("\n 8.Traverse the list (Left to Right)");
printf("\n 9.Traverse the list (Right to Left)");

Lecture Notes

38

Dept. of Information Technology

printf("\n--------------------------");
printf("\n 10. Count nodes ");
printf("\n 11. Exit ");
printf("\n\n Enter your choice: ");
scanf("%d",&ch);
return ch;
}
node* getnode()
{
node * newnode;
newnode = (node *) malloc(sizeof(node));
printf("\n Enter data: ");
scanf("%d", &newnode -> data);
newnode -> next = NULL;
return newnode;
}
int countnode(node *ptr)
{
int count=0;
while(ptr != NULL)
{
count++;
ptr = ptr -> next;
}
return (count);
}
void createlist(int n)
{
int i;
node *newnode;
node *temp;
for(i = 0; i < n; i++)
{
newnode = getnode();
if(start == NULL)
{
start = newnode;
}
else
{
temp = start;
while(temp -> next != NULL)
temp = temp -> next;
temp -> next = newnode;
}
}
}
void traverse()
{
node *temp;
temp = start;
printf("\n The contents of List (Left to Right): \n");
if(start == NULL)
{
printf("\n Empty List");
return;
}
else
{
Lecture Notes

39

Dept. of Information Technology

while(temp != NULL)
{
printf("%d-->", temp -> data);
temp = temp -> next;
}

}

}
printf(" X ");

void rev_traverse(node *start)
{
if(start == NULL)
{
return;
}
else
{
rev_traverse(start -> next);
printf("%d -->", start -> data);
}
}
void insert_at_beg()
{
node *newnode;
newnode = getnode();
if(start == NULL)
{
start = newnode;
}
else
{
newnode -> next = start;
start = newnode;
}
}
void insert_at_end()
{
node *newnode, *temp;
newnode = getnode();
if(start == NULL)
{
start = newnode;
}
else
{
temp = start;
while(temp -> next != NULL)
temp = temp -> next;
temp -> next = newnode;
}
}
void insert_at_mid()
{
node *newnode, *temp, *prev;
int pos, nodectr, ctr = 1;
newnode = getnode();
printf("\n Enter the position: ");
scanf("%d", &pos);
nodectr = countnode(start);

Lecture Notes

40

Dept. of Information Technology

}

if(pos > 1 && pos < nodectr)
{
temp = prev = start;
while(ctr < pos)
{
prev = temp;
temp = temp -> next;
ctr++;
}
prev -> next = newnode;
newnode -> next = temp;
}
else
printf("position %d is not a middle position", pos);

void delete_at_beg()
{
node *temp;
if(start == NULL)
{
printf("\n No nodes are exist..");
return ;
}
else
{
temp = start;
start = temp -> next;
free(temp);
printf("\n Node deleted ");
}
}
void delete_at_last()
{
node *temp, *prev;
if(start == NULL)
{
printf("\n Empty List..");
return ;
}
else
{
temp = start;
prev = start;
while(temp -> next != NULL)
{
prev = temp;
temp = temp -> next;
}
prev -> next = NULL;
free(temp);
printf("\n Node deleted ");
}
}
void delete_at_mid()
{
int ctr = 1, pos, nodectr;
node *temp, *prev;
if(start == NULL)
{
printf("\n Empty List..");
Lecture Notes

41

Dept. of Information Technology

}
else
{

}

}

return ;

printf("\n Enter position of node to delete: ");
scanf("%d", &pos);
nodectr = countnode(start);
if(pos > nodectr)
{
printf("\nThis node doesnot exist");
}
if(pos > 1 && pos < nodectr)
{
temp = prev = start;
while(ctr < pos)
{
prev = temp;
temp = temp -> next;
ctr ++;
}
prev -> next = temp -> next;
free(temp);
printf("\n Node deleted..");
}
else
{
printf("\n Invalid position..");
getch();
}

void main(void)
{
int ch, n;
clrscr();
while(1)
{
ch = menu();
switch(ch)
{
case 1:
if(start == NULL)
{
printf("\n Number of nodes you want to create: ");
scanf("%d", &n);
createlist(n);
printf("\n List created..");
}
else
printf("\n List is already created..");
break;
case 2:
insert_at_beg();
break;
case 3:
insert_at_end();
break;
case 4:
insert_at_mid();
break;

Lecture Notes

42

Dept. of Information Technology

case 5:
case 6:
case 7:
case 8:

delete_at_beg();
break;
delete_at_last();
break;
delete_at_mid();
break;
traverse();
break;

case 9:

}

3.4.

}

printf("\n The contents of List (Right to Left): \n");
rev_traverse(start);
printf(" X ");
break;
case 10:
printf("\n No of nodes : %d ", countnode(start));
break;
case 11 :
exit(0);
}
getch();

Using a header node:

A header node is a special dummy node found at the front of the list. The use of header
node is an alternative to remove the first node in a list. For example, the picture below
shows how the list with data 10, 20 and 30 would be represented using a linked list
without and with a header node:

sta rt
100
10

200

100

20

300

200

X

30
300

Si n g l e L i n k e d L i st w it h o ut a h e a d er n o d e

sta rt
400
100
400

10

200

100

20

300

200

30

X

300

Si n g l e L i n k e d L i st w it h h e a d er n o d e

Note that if your linked lists do include a header node, there is no need for the special
case code given above for the remove operation; node n can never be the first node in
the list, so there is no need to check for that case. Similarly, having a header node can
simplify the code that adds a node before a given node n.
Lecture Notes

43

Dept. of Information Technology

Note that if you do decide to use a header node, you must remember to initialize an
empty list to contain one (dummy) node, you must remember not to include the
header node in the count of "real" nodes in the list.
It is also useful when information other than that found in each node of the list is
needed. For example, imagine an application in which the number of items in a list is
often calculated. In a standard linked list, the list function to count the number of
nodes has to traverse the entire list every time. However, if the current length is
maintained in a header node, that information can be obtained very quickly.
3.5.

Array based linked lists:

Another alternative is to allocate the nodes in blocks. In fact, if you know the maximum
size of a list a head of time, you can pre-allocate the nodes in a single array. The result
is a hybrid structure – an array based linked list. Figure 3.5.1 shows an example of null
terminated single linked list where all the nodes are allocated contiguously in an array.
start
a

100
a

200

100

b

300

200

c
300

Conceptual structure

X

b
c
d

Implementation
Figure 3.5.1. An array based linked list

3.6.

Double Linked List:

A double linked list is a two-way list in which all nodes will have two links. This helps in
accessing both successor node and predecessor node from the given node position. It
provides bi-directional traversing. Each node contains three fields:
•
•
•

Left link.
Data.
Right link.

The left link points to the predecessor node and the right link points to the successor
node. The data field stores the required data.
Many applications require searching forward and backward thru nodes of a list. For
example searching for a name in a telephone directory would need forward and
backward scanning thru a region of the whole list.
The basic operations in a double linked list are:
•
•
•
•

Creation.
Insertion.
Deletion.
Traversing.

Lecture Notes

44

Dept. of Information Technology

A double linked list is shown in figure 3.3.1.
STACK
100
start
The start
pointer holds
the address
of the first
node of the
list.

HEAP

Stores the previous
node address.

X

10

200

100

100

20

300

200

200

Stores the data.

X

30

300

Stores the next
node address.

The right field of the
last node is NULL.

Figure 3.3.1. Double Linked List

The beginning of the double linked list is stored in a "start" pointer which points to the
first node. The first node’s left link and last node’s right link is set to NULL.
The following code gives the structure definition:
struct dlinklist
{
struct dlinklist *left;
int data;
struct dlinklist *right;

node:

left

};

data

right

start
Empty list:

typedef struct dlinklist node;
node *start = NULL;

NULL

Figure 3.4.1. Structure definition, double link node and empty list

Creating a node for Double Linked List:
Creating a double linked list starts with creating a node. Sufficient memory has to be
allocated for creating a node. The information is stored in the memory, allocated by
using the malloc() function. The function getnode(), is used for creating a node, after
allocating memory for the structure of type node, the information for the item (i.e.,
data) has to be read from the user and set left field to NULL and right field also set to
NULL (see figure 3.2.2).
node* getnode()
{
node* new node;
newnode = (node *) malloc(sizeof(node));
printf("\n Enter data: ");
scanf("%d", &newnode -> data);
newnode -> left = NULL;
newnode -> right = NULL;
return new node;
}

newnode

X

10

X

100

Figure 3.4.2. new node with a value of 10

Lecture Notes

45

Dept. of Information Technology

Creating a Double Linked List with ‘n’ number of nodes:
The following steps are to be followed to create ‘n’ number of nodes:
•

Get the new node using getnode().
newnode =getnode();

•

If the list is empty then start = newnode.

•

If the list is not empty, follow the steps given below:

•

•

The left field of the new node is made to point the previous node.

•

The previous nodes right field must be assigned with address of the
new node.

Repeat the above steps ‘n’ times.

The function createlist(), is used to create ‘n’ number of nodes:
vo id c r e at e list( int n)
{
int i;
no d e * ne w no d e;
no d e *t e m p ;
fo r( i = 0; i < n; i+ + )
{
ne w no d e = g et no d e();
if(st a rt = = N U L L)
{
sta rt = ne w no d e;
}
e ls e
{
te m p = st a rt;
w hile(t e m p - > r ig ht)
te m p = t e m p - > r ig ht;
te m p - > r ig ht = ne w no d e;
ne w no d e - > left = t e m p ;
}
}
}

Figure 3.4.3 shows 3 items in a double linked list stored at different locations.

start

100

X
100

10

200

100

20

300

200

200

30

X

300

Figure 3.4.3. Double Linked List with 3 nodes

Lecture Notes

46

Dept. of Information Technology

Inserting a node at the beginning:
The following steps are to be followed to insert a new node at the beginning of the list:
•

Get the new node using getnode().
newnode=getnode();

•

If the list is empty then start = newnode.

•

If the list is not empty, follow the steps given below:
newnode -> right = start;
start -> left = newnode;
start = newnode;

The function dbl_insert_beg(), is used for inserting a node at the beginning. Figure
3.4.4 shows inserting a node into the double linked list at the beginning.
start
400
400

10

200

100

X

40

100

20

300

200

200

30

X

300

100

400

Figure 3.4.4. Inserting a node at the beginning

Inserting a node at the end:
The following steps are followed to insert a new node at the end of the list:
•

Get the new node using getnode()
newnode=getnode();

•

If the list is empty then start = newnode.

•

If the list is not empty follow the steps given below:
temp = start;
while(temp -> right != NULL)
temp = temp -> right;
temp -> right = newnode;
newnode -> left = temp;

The function dbl_insert_end(), is used for inserting a node at the end. Figure 3.4.5
shows inserting a node into the double linked list at the end.

Lecture Notes

47

Dept. of Information Technology

start
100

X

10

200

100

100

20

300

200

200

30

400

40

X

300

300
400
Figure 3.4.5. Inserting a node at the end

Inserting a node at an intermediate position:
The following steps are followed, to insert a new node in an intermediate position in the
list:
•

Get the new node using getnode().
newnode=getnode();

•

Ensure that the specified position is in between first node and last node. If
not, specified position is invalid. This is done by countnode() function.

•

Store the starting address (which is in start pointer) in temp and prev
pointers. Then traverse the temp pointer upto the specified position followed
by prev pointer.

•

After reaching the specified position, follow the steps given below:
newnode -> left = temp;
newnode -> right = temp -> right;
temp -> right -> left = newnode;
temp -> right = newnode;

The function dbl_insert_mid(), is used for inserting a node in the intermediate
position. Figure 3.4.6 shows inserting a node into the double linked list at a specified
intermediate position other than beginning and end.
start
100

100

400

X

10

400

40

200

400

20

300

200

100

200

30

X

300

Figure 3.4.6. Inserting a node at an intermediate position

Lecture Notes

48

Dept. of Information Technology

Deleting a node at the beginning:
The following steps are followed, to delete a node at the beginning of the list:
•

If list is empty then display ‘Empty List’ message.

•

If the list is not empty, follow the steps given below:
temp = start;
start = start -> right;
start -> left = NULL;
free(temp);

The function dbl_delete_beg(), is used for deleting the first node in the list. Figure
3.4.6 shows deleting a node at the beginning of a double linked list.

start

200

X

10

200

100

X

20

200

300

200

30

X

300

Figure 3.4.6. Deleting a node at beginning

Deleting a node at the end:
The following steps are followed to delete a node at the end of the list:
•
If list is empty then display ‘Empty List’ message
•

If the list is not empty, follow the steps given below:
temp = start;
while(temp -> right != NULL)
{
temp = temp -> right;
}
temp -> left -> right = NULL;
free(temp);

The function dbl_delete_last(), is used for deleting the last node in the list. Figure 3.4.7
shows deleting a node at the end of a double linked list.

start

100

X
100

10

200

100

20

X

200

200

30

X

300

Figure 3.4.7. Deleting a node at the end

Lecture Notes

49

Dept. of Information Technology

Deleting a node at Intermediate position:
The following steps are followed, to delete a node from an intermediate position in the
list (List must contain more than two nodes).
•

If list is empty then display ‘Empty List’ message.

•

If the list is not empty, follow the steps given below:
•

Get the position of the node to delete.

•

Ensure that the specified position is in between first node and last
node. If not, specified position is invalid.

•

Then perform the following steps:
if(pos > 1 && pos < nodectr)
{
temp = start;
i = 1;
while(i < pos)
{
temp = temp -> right;
i++;
}
temp -> right -> left = temp -> left;
temp -> left -> right = temp -> right;
free(temp);
printf("\n node deleted..");
}

The function delete_at_mid(), is used for deleting the intermediate node in the list.
Figure 3.4.8 shows deleting a node at a specified intermediate position other than
beginning and end from a double linked list.
start
100

X
100

10

300

100

20

300

200

100

30

X

300

Figure 3.4.8 Deleting a node at an intermediate position

Traversal and displaying a list (Left to Right):
To display the information, you have to traverse the list, node by node from the first
node, until the end of the list is reached. The function traverse_left_right() is used for
traversing and displaying the information stored in the list from left to right.
The following steps are followed, to traverse a list from left to right:
•

If list is empty then display ‘Empty List’ message.

•

If the list is not empty, follow the steps given below:

Lecture Notes

50

Dept. of Information Technology

temp = start;
while(temp != NULL)
{
print temp -> data;
temp = temp -> right;
}
Traversal and displaying a list (Right to Left):
To display the information from right to left, you have to traverse the list, node by
node from the first node, until the end of the list is reached. The function
traverse_right_left() is used for traversing and displaying the information stored in the
list from right to left. The following steps are followed, to traverse a list from right to
left:
•

If list is empty then display ‘Empty List’ message.

•

If the list is not empty, follow the steps given below:
temp = start;
while(temp -> right != NULL)
temp = temp -> right;
while(temp != NULL)
{
print temp -> data;
temp = temp -> left;
}

Counting the Number of Nodes:
The following code will count the number of nodes exist in the list (using recursion).
int co unt no d e( no d e *st a rt)
{
if(st a rt = = N U L L)
r et ur n 0;
e ls e
r et ur n(1 + co unt no d e(st a rt - > r ig ht ));
}

3.5.

A Complete Source Code for the Implementation of Double Linked List:
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
struct dlinklist
{
struct dlinklist *left;
int data;
struct dlinklist *right;
};
typedef struct dlinklist node;
node *start = NULL;

Lecture Notes

51

Dept. of Information Technology

node* getnode()
{
node * newnode;
newnode = (node *) malloc(sizeof(node));
printf("\n Enter data: ");
scanf("%d", &newnode -> data);
newnode -> left = NULL;
newnode -> right = NULL;
return newnode;
}
int countnode(node *start)
{
if(start == NULL)
return 0;
else
return 1 + countnode(start -> right);
}
int menu()
{
int ch;
clrscr();
printf("\n 1.Create");
printf("\n------------------------------");
printf("\n 2. Insert a node at beginning ");
printf("\n 3. Insert a node at end");
printf("\n 4. Insert a node at middle");
printf("\n------------------------------");
printf("\n 5. Delete a node from beginning");
printf("\n 6. Delete a node from Last");
printf("\n 7. Delete a node from Middle");
printf("\n------------------------------");
printf("\n 8. Traverse the list from Left to Right ");
printf("\n 9. Traverse the list from Right to Left ");
printf("\n------------------------------");
printf("\n 10.Count the Number of nodes in the list");
printf("\n 11.Exit ");
printf("\n\n Enter your choice: ");
scanf("%d", &ch);
return ch;
}
void createlist(int n)
{
int i;
node *newnode;
node *temp;
for(i = 0; i < n; i++)
{
newnode = getnode();
if(start == NULL)
start = newnode;
else
{
temp = start;
while(temp -> right)
temp = temp -> right;
temp -> right = newnode;
newnode -> left = temp;
}
}
}
Lecture Notes

52

Dept. of Information Technology

void traverse_left_to_right()
{
node *temp;
temp = start;
printf("\n The contents of List: ");
if(start == NULL )
printf("\n Empty List");
else
{
while(temp != NULL)
{
printf("\t %d ", temp -> data);
temp = temp -> right;
}
}
}
void traverse_right_to_left()
{
node *temp;
temp = start;
printf("\n The contents of List: ");
if(start == NULL)
printf("\n Empty List");
else
{
while(temp -> right != NULL)
temp = temp -> right;
}
while(temp != NULL)
{
printf("\t%d", temp -> data);
temp = temp -> left;
}
}
void dll_insert_beg()
{
node *newnode;
newnode = getnode();
if(start == NULL)
start = newnode;
else
{
newnode -> right = start;
start -> left = newnode;
start = newnode;
}
}
void dll_insert_end()
{
node *newnode, *temp;
newnode = getnode();
if(start == NULL)
start = newnode;
else
{
temp = start;
while(temp -> right != NULL)
temp = temp -> right;
temp -> right = newnode;
newnode -> left = temp;
}
}
Lecture Notes

53

Dept. of Information Technology

void dll_insert_mid()
{
node *newnode,*temp;
int pos, nodectr, ctr = 1;
newnode = getnode();
printf("\n Enter the position: ");
scanf("%d", &pos);
nodectr = countnode(start);
if(pos - nodectr >= 2)
{
printf("\n Position is out of range..");
return;
}
if(pos > 1 && pos < nodectr)
{
temp = start;
while(ctr < pos - 1)
{
temp = temp -> right;
ctr++;
}
newnode -> left = temp;
newnode -> right = temp -> right;
temp -> right -> left = newnode;
temp -> right = newnode;
}
else
printf("position %d of list is not a middle position ", pos);
}
void dll_delete_beg()
{
node *temp;
if(start == NULL)
{
printf("\n Empty list");
getch();
return ;
}
else
{
temp = start;
start = start -> right;
start -> left = NULL;
free(temp);
}
}
void dll_delete_last()
{
node *temp;
if(start == NULL)
{
printf("\n Empty list");
getch();
return ;
}
else
{
temp = start;
while(temp -> right != NULL)
Lecture Notes

54

Dept. of Information Technology

}

}

temp = temp -> right;
temp -> left -> right = NULL;
free(temp);
temp = NULL;

void dll_delete_mid()
{
int i = 0, pos, nodectr;
node *temp;
if(start == NULL)
{
printf("\n Empty List");
getch();
return;
}
else
{
printf("\n Enter the position of the node to delete: ");
scanf("%d", &pos);
nodectr = countnode(start);
if(pos > nodectr)
{
printf("\nthis node does not exist");
getch();
return;
}
if(pos > 1 && pos < nodectr)
{
temp = start;
i = 1;
while(i < pos)
{
temp = temp -> right;
i++;
}
temp -> right -> left = temp -> left;
temp -> left -> right = temp -> right;
free(temp);
printf("\n node deleted..");
}
else
{
printf("\n It is not a middle position..");
getch();
}
}
}
void main(void)
{
int ch, n;
clrscr();
while(1)
{
ch = menu();
switch( ch)
{
case 1 :
printf("\n Enter Number of nodes to create: ");
scanf("%d", &n);
createlist(n);
Lecture Notes

55

Dept. of Information Technology

case 2
case 3
case 4
case 5
case 6
case 7
case 8
case 9

printf("\n List created..");
break;
:
dll_insert_beg();
break;
:
dll_insert_end();
break;
:
dll_insert_mid();
break;
:
dll_delete_beg();
break;
:
dll_delete_last();
break;
:
dll_delete_mid();
break;
:
traverse_left_to_right();
break;
:
traverse_right_to_left();
break;

case 10 :
printf("\n Number of nodes: %d", countnode(start));
break;
case 11:
exit(0);

}

3.7.

}

}
getch();

Circular Single Linked List:

It is just a single linked list in which the link field of the last node points back to the
address of the first node. A circular linked list has no beginning and no end. It is
necessary to establish a special pointer called start pointer always pointing to the first
node of the list. Circular linked lists are frequently used instead of ordinary linked list
because many operations are much easier to implement. In circular linked list no null
pointers are used, hence all pointers contain valid address.
A circular single linked list is shown in figure 3.6.1.

start

100
10
100

200

20

300

200

30

400

300

40

100

400

Figure 3.6.1. C ircular Single Linked List

Lecture Notes

56

Dept. of Information Technology

The basic operations in a circular single linked list are:
•
•
•
•

Creation.
Insertion.
Deletion.
Traversing.

Creating a circular single Linked List with ‘n’ number of nodes:
The following steps are to be followed to create ‘n’ number of nodes:
•

Get the new node using getnode().
newnode = getnode();

•

If the list is empty, assign new node as start.
start = newnode;

•

If the list is not empty, follow the steps given below:
temp = start;
while(temp -> next != NULL)
temp = temp -> next;
temp -> next = newnode;

•

Repeat the above steps ‘n’ times.

•

newnode -> next = start;

The function createlist(), is used to create ‘n’ number of nodes:
Inserting a node at the beginning:
The following steps are to be followed to insert a new node at the beginning of the
circular list:
•

Get the new node using getnode().
newnode = getnode();

•

If the list is empty, assign new node as start.
start = newnode;
newnode -> next = start;

•

If the list is not empty, follow the steps given below:
last = start;
while(last -> next != start)
last = last -> next;
newnode -> next = start;
start = newnode;
last -> next = start;

Lecture Notes

57

Dept. of Information Technology

The function cll_insert_beg(), is used for inserting a node at the beginning. Figure
3.6.2 shows inserting a node into the circular single linked list at the beginning.
start

500
10

200

100
5

20

300

200

30

40

400

300

500

400

100

500

Figure 3.6.2. Inserting a node at the beginning

Inserting a node at the end:
The following steps are followed to insert a new node at the end of the list:
•

Get the new node using getnode().
newnode = getnode();

•

If the list is empty, assign new node as start.
start = newnode;
newnode -> next = start;

•

If the list is not empty follow the steps given below:
temp = start;
while(temp -> next != start)
temp = temp -> next;
temp -> next = newnode;
newnode -> next = start;

The function cll_insert_end(), is used for inserting a node at the end.
Figure 3.6.3 shows inserting a node into the circular single linked list at the end.
start
100
10
100

200

20

300

200

30

40

400

300

500

400

50

100

500

Figure 3.6.3 Inserting a node at the end.

Lecture Notes

58

Dept. of Information Technology

Deleting a node at the beginning:
The following steps are followed, to delete a node at the beginning of the list:
•

If the list is empty, display a message ‘Empty List’.

•

If the list is not empty, follow the steps given below:
last = temp = start;
while(last -> next != start)
last = last -> next;
start = start -> next;
last -> next = start;

•

After deleting the node, if the list is empty then start = NULL.

The function cll_delete_beg(), is used for deleting the first node in the list. Figure 3.6.4
shows deleting a node at the beginning of a circular single linked list.
start

200
10
temp

200

100

20

300

200

30

40

400

300

200

400

Figure 3.6.4. Deleting a node at beginning.

Deleting a node at the end:
The following steps are followed to delete a node at the end of the list:
•

If the list is empty, display a message ‘Empty List’.

•

If the list is not empty, follow the steps given below:
temp = start;
prev = start;
while(temp -> next != start)
{
prev = temp;
temp = temp -> next;
}
prev -> next = start;

•

After deleting the node, if the list is empty then start = NULL.

The function cll_delete_last(), is used for deleting the last node in the list.

Lecture Notes

59

Dept. of Information Technology

Figure 3.6.5 shows deleting a node at the end of a circular single linked list.
start

100
10

200

100

20

300

200

30

100

300

40

100

400

Figure 3.6.5. Deleting a node at the end.

Traversing a circular single linked list from left to right:
The following steps are followed, to traverse a list from left to right:
•

If list is empty then display ‘Empty List’ message.

•

If the list is not empty, follow the steps given below:
temp = start;
do
{
printf("%d ", temp -> data);
temp = temp -> next;
} while(temp != start);

3.7.1.

Source Code for Circular Single Linked List:
# include <stdio.h>
# include <conio.h>
# include <stdlib.h>
struct cslinklist
{
int data;
struct cslinklist *next;
};
typedef struct cslinklist node;
node *start = NULL;
int nodectr;
node* getnode()
{
node * newnode;
newnode = (node *) malloc(sizeof(node));
printf("\n Enter data: ");
scanf("%d", &newnode -> data);
newnode -> next = NULL;
return newnode;
}

Lecture Notes

60

Dept. of Information Technology

int menu()
{
int ch;
clrscr();
printf("\n 1. Create a list ");
printf("\n\n--------------------------");
printf("\n 2. Insert a node at beginning ");
printf("\n 3. Insert a node at end");
printf("\n 4. Insert a node at middle");
printf("\n\n--------------------------");
printf("\n 5. Delete a node from beginning");
printf("\n 6. Delete a node from Last");
printf("\n 7. Delete a node from Middle");
printf("\n\n--------------------------");
printf("\n 8. Display the list");
printf("\n 9. Exit");
printf("\n\n--------------------------");
printf("\n Enter your choice: ");
scanf("%d", &ch);
return ch;
}
void createlist(int n)
{
int i;
node *newnode;
node *temp;
nodectr = n;
for(i = 0; i < n ; i++)
{
newnode = getnode();
if(start == NULL)
{
start = newnode;
}
else
{
temp = start;
while(temp -> next != NULL)
temp = temp -> next;
temp -> next = newnode;
}
}
newnode ->next = start;
/* last node is pointing to starting node */
}
void display()
{
node *temp;
temp = start;
printf("\n The contents of List (Left to Right): ");
if(start == NULL )
printf("\n Empty List");
else
{
do
{
printf("\t %d ", temp -> data);
temp = temp -> next;
} while(temp != start);
printf(" X ");
}
}
Lecture Notes

61

Dept. of Information Technology

void cll_insert_beg()
{
node *newnode, *last;
newnode = getnode();
if(start == NULL)
{
start = newnode;
newnode -> next = start;
}
else
{
last = start;
while(last -> next != start)
last = last -> next;
newnode -> next = start;
start = newnode;
last -> next = start;
}
printf("\n Node inserted at beginning..");
nodectr++;
}
void cll_insert_end()
{
node *newnode, *temp;
newnode = getnode();
if(start == NULL )
{
start = newnode;
newnode -> next = start;
}
else
{
temp = start;
while(temp -> next != start)
temp = temp -> next;
temp -> next = newnode;
newnode -> next = start;
}
printf("\n Node inserted at end..");
nodectr++;
}
void cll_insert_mid()
{
node *newnode, *temp, *prev;
int i, pos ;
newnode = getnode();
printf("\n Enter the position: ");
scanf("%d", &pos);
if(pos > 1 && pos < nodectr)
{
temp = start;
prev = temp;
i = 1;
while(i < pos)
{
prev = temp;
temp = temp -> next;
i++;
}
prev -> next = newnode;
newnode -> next = temp;
Lecture Notes

62

Dept. of Information Technology

nodectr++;
printf("\n Node inserted at middle..");
}
else
{
}

printf("position %d of list is not a middle position ", pos);

}

void cll_delete_beg()
{
node *temp, *last;
if(start == NULL)
{
printf("\n No nodes exist..");
getch();
return ;
}
else
{
last = temp = start;
while(last -> next != start)
last = last -> next;
start = start -> next;
last -> next = start;
free(temp);
nodectr--;
printf("\n Node deleted..");
if(nodectr == 0)
start = NULL;
}
}
void cll_delete_last()
{
node *temp,*prev;
if(start == NULL)
{
printf("\n No nodes exist..");
getch();
return ;
}
else
{
temp = start;
prev = start;
while(temp -> next != start)
{
prev = temp;
temp = temp -> next;
}
prev -> next = start;
free(temp);
nodectr--;
if(nodectr == 0)
start = NULL;
printf("\n Node deleted..");
}
}

Lecture Notes

63

Dept. of Information Technology

void cll_delete_mid()
{
int i = 0, pos;
node *temp, *prev;

}

if(start == NULL)
{
printf("\n No nodes exist..");
getch();
return ;
}
else
{
printf("\n Which node to delete: ");
scanf("%d", &pos);
if(pos > nodectr)
{
printf("\nThis node does not exist");
getch();
return;
}
if(pos > 1 && pos < nodectr)
{
temp=start;
prev = start;
i = 0;
while(i < pos - 1)
{
prev = temp;
temp = temp -> next ;
i++;
}
prev -> next = temp -> next;
free(temp);
nodectr--;
printf("\n Node Deleted..");
}
else
{
printf("\n It is not a middle position..");
getch();
}
}

void main(void)
{
int result;
int ch, n;
clrscr();
while(1)
{
ch = menu();
switch(ch)
{
case 1 :
if(start == NULL)
{
printf("\n Enter Number of nodes to create: ");
scanf("%d", &n);
createlist(n);
printf("\nList created..");
}
Lecture Notes

64

Dept. of Information Technology

else

case 2
case 3
case 4
case 5
case 6
case 7
case 8
case 9

}

printf("\n List is already Exist..");
break;
:
cll_insert_beg();
break;
:
cll_insert_end();
break;
:
cll_insert_mid();
break;
:
cll_delete_beg();
break;
:
cll_delete_last();
break;
:
cll_delete_mid();
break;
:
display();
break;
:
exit(0);

}
getch();

}

3.8.

Circular Double Linked List:

A circular double linked list has both successor pointer and predecessor pointer in
circular manner. The objective behind considering circular double linked list is to
simplify the insertion and deletion operations performed on double linked list. In
circular double linked list the right link of the right most node points back to the start
node and left link of the first node points to the last node. A circular double linked list is
shown in figure 3.8.1.

100
start

300
100

10

200

100

20

300

200

200

30

100

300

Figure 3.8.1. C ircular Double Linked List

The basic operations in a circular double linked list are:
•
•
•
•

Creation.
Insertion.
Deletion.
Traversing.

Lecture Notes

65

Dept. of Information Technology

Creating a Circular Double Linked List with ‘n’ number of nodes:
The following steps are to be followed to create ‘n’ number of nodes:
•

Get the new node using getnode().
newnode = getnode();

•

If the list is empty, then do the following
start = newnode;
newnode -> left = start;
newnode ->right = start;

•

If the list is not empty, follow the steps given below:
newnode -> left = start -> left;
newnode -> right = start;
start -> left->right = newnode;
start -> left = newnode;

•

Repeat the above steps ‘n’ times.

The function cdll_createlist(), is used to create ‘n’ number of nodes:
Inserting a node at the beginning:
The following steps are to be followed to insert a new node at the beginning of the list:
•

Get the new node using getnode().
newnode=getnode();

•

If the list is empty, then
start = newnode;
newnode -> left = start;
newnode -> right = start;

•

If the list is not empty, follow the steps given below:
newnode -> left = start -> left;
newnode -> right = start;
start -> left -> right = newnode;
start -> left = newnode;
start = newnode;

The function cdll_insert_beg(), is used for inserting a node at the beginning. Figure
3.8.2 shows inserting a node into the circular double linked list at the beginning.
start
400
400
100

300

40

10

200

100

20

300

200

200

30

400

300

100

400

Figure 3.8.2. Inserting a node at the beginning

Lecture Notes

66

Dept. of Information Technology

Inserting a node at the end:
The following steps are followed to insert a new node at the end of the list:
•

Get the new node using getnode()
newnode=getnode();

•

If the list is empty, then
start = newnode;
newnode -> left = start;
newnode -> right = start;

•

If the list is not empty follow the steps given below:
newnode -> left = start -> left;
newnode -> right = start;
start -> left -> right = newnode;
start -> left = newnode;

The function cdll_insert_end(), is used for inserting a node at the end. Figure 3.8.3
shows inserting a node into the circular linked list at the end.
start

100
400
100

10

200

100

20

200

300

200

30

400

300

300

40

100

400

Figure 3.8.3. Inserting a node at the end

Inserting a node at an intermediate position:
The following steps are followed, to insert a new node in an intermediate position in the
list:
•

Get the new node using getnode().
newnode=getnode();

•

Ensure that the specified position is in between first node and last node. If
not, specified position is invalid. This is done by countnode() function.

•

Store the starting address (which is in start pointer) in temp. Then traverse
the temp pointer upto the specified position.

•

After reaching the specified position, follow the steps given below:
newnode -> left = temp;
newnode -> right = temp -> right;
temp -> right -> left = newnode;
temp -> right = newnode;
nodectr++;

Lecture Notes

67

Dept. of Information Technology

The function cdll_insert_mid(), is used for inserting a node in the intermediate
position. Figure 3.8.4 shows inserting a node into the circular double linked list at a
specified intermediate position other than beginning and end.
start
100

100

40

200

400

300

10

400

400

100

20

300

30

100

200

200
300

Figure 3.8.4. Inserting a node at an intermediate position

Deleting a node at the beginning:
The following steps are followed, to delete a node at the beginning of the list:
•

If list is empty then display ‘Empty List’ message.

•

If the list is not empty, follow the steps given below:
temp = start;
start = start -> right;
temp -> left -> right = start;
start -> left = temp -> left;

The function cdll_delete_beg(), is used for deleting the first node in the list. Figure
3.8.5 shows deleting a node at the beginning of a circular double linked list.

start

200
300

10

100

200

300

20

300

200

200

30

200

300

Figure 3.8.5. Deleting a node at beginning

Deleting a node at the end:
The following steps are followed to delete a node at the end of the list:
•
•

If list is empty then display ‘Empty List’ message
If the list is not empty, follow the steps given below:

Lecture Notes

68

Dept. of Information Technology

temp = start;
while(temp -> right != start)
{
temp = temp -> right;
}
temp -> left -> right = temp -> right;
temp -> right -> left = temp -> left;
The function cdll_delete_last(), is used for deleting the last node in the list. Figure
3.8.6 shows deleting a node at the end of a circular double linked list.
start
100
200
100

10

200

100

20

100

200

200

30

100

300

Figure 3.8.6. Deleting a node at the end

Deleting a node at Intermediate position:
The following steps are followed, to delete a node from an intermediate position in the
list (List must contain more than two node).
•

If list is empty then display ‘Empty List’ message.

•

If the list is not empty, follow the steps given below:
•

Get the position of the node to delete.

•

Ensure that the specified position is in between first node and last
node. If not, specified position is invalid.

•

Then perform the following steps:
if(pos > 1 && pos < nodectr)
{
temp = start;
i = 1;
while(i < pos)
{
temp = temp -> right ;
i++;
}
temp -> right -> left = temp -> left;
temp -> left -> right = temp -> right;
free(temp);
printf("\n node deleted..");
nodectr--;
}

The function cdll_delete_mid(), is used for deleting the intermediate node in the list.
Lecture Notes

69

Dept. of Information Technology

Figure 3.8.7 shows deleting a node at a specified intermediate position other than
beginning and end from a circular double linked list.
start

100
300
100

10

300

100

20

100

300

200

30

100

300

Figure 3.8.7. Deleting a node at an intermediate position

Traversing a circular double linked list from left to right:
The following steps are followed, to traverse a list from left to right:
•

If list is empty then display ‘Empty List’ message.

•

If the list is not empty, follow the steps given below:
temp = start;
Print temp -> data;
temp = temp -> right;
while(temp != start)
{
print temp -> data;
temp = temp -> right;
}

The function cdll_display_left _right(), is used for traversing from left to right.
Traversing a circular double linked list from right to left:
The following steps are followed, to traverse a list from right to left:
•

If list is empty then display ‘Empty List’ message.

•

If the list is not empty, follow the steps given below:
temp = start;
do
{
temp = temp -> left;
print temp -> data;
} while(temp != start);

The function cdll_display_right_left(), is used for traversing from right to left.
3.8.1.

Source Code for Circular Double Linked List:
# include <stdio.h>
# include <stdlib.h>
# include <conio.h>

Lecture Notes

70

Dept. of Information Technology

struct cdlinklist
{
struct cdlinklist *left;
int data;
struct cdlinklist *right;
};
typedef struct cdlinklist node;
node *start = NULL;
int nodectr;
node* getnode()
{
node * newnode;
newnode = (node *) malloc(sizeof(node));
printf("\n Enter data: ");
scanf("%d", &newnode -> data);
newnode -> left = NULL;
newnode -> right = NULL;
return newnode;
}
int menu()
{
int ch;
clrscr();
printf("\n 1. Create ");
printf("\n\n--------------------------");
printf("\n 2. Insert a node at Beginning");
printf("\n 3. Insert a node at End");
printf("\n 4. Insert a node at Middle");
printf("\n\n--------------------------");
printf("\n 5. Delete a node from Beginning");
printf("\n 6. Delete a node from End");
printf("\n 7. Delete a node from Middle");
printf("\n\n--------------------------");
printf("\n 8. Display the list from Left to Right");
printf("\n 9. Display the list from Right to Left");
printf("\n 10.Exit");
printf("\n\n Enter your choice: ");
scanf("%d", &ch);
return ch;
}
void cdll_createlist(int n)
{
int i;
node *newnode, *temp;
if(start == NULL)
{
nodectr = n;
for(i = 0; i < n; i++)
{
newnode = getnode();
if(start == NULL)
{
start = newnode;
newnode -> left = start;
newnode ->right = start;
}
else
{
newnode -> left = start -> left;
Lecture Notes

71

Dept. of Information Technology

}
else
}

}

}

newnode -> right = start;
start -> left->right = newnode;
start -> left = newnode;

printf("\n List already exists..");

void cdll_display_left_right()
{
node *temp;
temp = start;
if(start == NULL)
printf("\n Empty List");
else
{
printf("\n The contents of List: ");
printf(" %d ", temp -> data);
temp = temp -> right;
while(temp != start)
{
printf(" %d ", temp -> data);
temp = temp -> right;
}
}
}
void cdll_display_right_left()
{
node *temp;
temp = start;
if(start == NULL)
printf("\n Empty List");
else
{
printf("\n The contents of List: ");
do
{
temp = temp -> left;
printf("\t%d", temp -> data);
} while(temp != start);
}
}
void cdll_insert_beg()
{
node *newnode;
newnode = getnode();
nodectr++;
if(start == NULL)
{
start = newnode;
newnode -> left = start;
newnode -> right = start;
}
else
{
newnode -> left = start -> left;
newnode -> right = start;
start -> left -> right = newnode;
start -> left = newnode;
Lecture Notes

72

Dept. of Information Technology

}

start = newnode;

}
void cdll_insert_end()
{
node *newnode,*temp;
newnode = getnode();
nodectr++;
if(start == NULL)
{
start = newnode;
newnode -> left = start;
newnode -> right = start;
}
else
{
newnode -> left = start -> left;
newnode -> right = start;
start -> left -> right = newnode;
start -> left = newnode;
}
printf("\n Node Inserted at End");
}
void cdll_insert_mid()
{
node *newnode, *temp, *prev;
int pos, ctr = 1;
newnode = getnode();
printf("\n Enter the position: ");
scanf("%d", &pos);
if(pos - nodectr >= 2)
{
printf("\n Position is out of range..");
return;
}
if(pos > 1 && pos <= nodectr)
{
temp = start;
while(ctr < pos - 1)
{
temp = temp -> right;
ctr++;
}
newnode -> left = temp;
newnode -> right = temp -> right;
temp -> right -> left = newnode;
temp -> right = newnode;
nodectr++;
printf("\n Node Inserted at Middle.. ");
}
else
printf("position %d of list is not a middle position", pos);
}
}
void cdll_delete_beg()
{
node *temp;
if(start == NULL)
{
printf("\n No nodes exist..");
Lecture Notes

73

Dept. of Information Technology

getch();
return ;
}
else
{

}

}

nodectr--;
if(nodectr == 0)
{
free(start);
start = NULL;
}
else
{
temp = start;
start = start -> right;
temp -> left -> right = start;
start -> left = temp -> left;
free(temp);
}
printf("\n Node deleted at Beginning..");

void cdll_delete_last()
{
node *temp;
if(start == NULL)
{
printf("\n No nodes exist..");
getch();
return;
}
else
{
nodectr--;
if(nodectr == 0)
{
free(start);
start = NULL;
}
else
{
temp = start;
while(temp -> right != start)
temp = temp -> right;
temp -> left -> right = temp -> right;
temp -> right -> left = temp -> left;
free(temp);
}
printf("\n Node deleted from end ");
}
}
void cdll_delete_mid()
{
int ctr = 1, pos;
node *temp;
if( start == NULL)
{
printf("\n No nodes exist..");
getch();
return;
}
Lecture Notes

74

Dept. of Information Technology

else
{
printf("\n Which node to delete: ");
scanf("%d", &pos);
if(pos > nodectr)
{
printf("\nThis node does not exist");
getch();
return;
}
if(pos > 1 && pos < nodectr)
{
temp = start;
while(ctr < pos)
{
temp = temp -> right ;
ctr++;
}
temp -> right -> left = temp -> left;
temp -> left -> right = temp -> right;
free(temp);
printf("\n node deleted..");
nodectr--;
}
else
{
printf("\n It is not a middle position..");
getch();
}
}

}

void main(void)
{
int ch,n;
clrscr();
while(1)
{
ch = menu();
switch( ch)
{
case 1 :
printf("\n Enter Number of nodes to create: ");
scanf("%d", &n);
cdll_createlist(n);
printf("\n List created..");
break;
case 2 :
cdll_insert_beg();
break;
case 3 :
cdll_insert_end();
break;
case 4 :
cdll_insert_mid();
break;
case 5 :
cdll_delete_beg();
break;
case 6 :
cdll_delete_last();
break;

Lecture Notes

75

Dept. of Information Technology

case 7 :
cdll_delete_mid();
break;
case 8 :
cdll_display_left_right();
break;
case 9 :
cdll_display_right_left();
break;
case 10:
exit(0);

}

3.9.

}

}
getch();

Comparison of Linked List Variations:

The major disadvantage of doubly linked lists (over singly linked lists) is that they
require more space (every node has two pointer fields instead of one). Also, the code
to manipulate doubly linked lists needs to maintain the prev fields as well as the next
fields; the more fields that have to be maintained, the more chance there is for errors.
The major advantage of doubly linked lists is that they make some operations (like the
removal of a given node, or a right-to-left traversal of the list) more efficient.
The major advantage of circular lists (over non-circular lists) is that they eliminate
some extra-case code for some operations (like deleting last node). Also, some
applications lead naturally to circular list representations. For example, a computer
network might best be modeled using a circular list.

3.10. Polynomials:
A polynomial is of the form:

n

i
∑ ci x

i =0

Where, ci is the coefficient of the ith term and
n is the degree of the polynomial
Some examples are:
5x2 + 3x + 1
12x3 – 4x
5x4 – 8x3 + 2x2 + 4x1 + 9x0
It is not necessary to write terms of the polynomials in decreasing order of degree. In
other words the two polynomials 1 + x and x + 1 are equivalent.
The computer implementation requires implementing polynomials as a list of pairs of
coefficient and exponent. Each of these pairs will constitute a structure, so a polynomial
will be represented as a list of structures. A linked list structure that represents
polynomials 5x4 – 8x3 + 2x2 + 4x1 + 9x0 illustrates in figure 3.10.1.

Lecture Notes

76

Dept. of Information Technology

start

Coefficient

500

5

4

100

500

Exponent

-8
100

3

200

2
200

2 300

4

1

300

400

9

0

X

400

Figure 3.10.1. Single Linked List for the polynomial F(x) = 5x4 – 8x 3 + 2x 2 + 4x 1 + 9x 0

3.10.1.

Source code for polynomial creation with help of linked list:

#include <conio.h>
#include <stdio.h>
#include <malloc.h>
struct link
{
float coef;
int expo;
struct link *next;
};
typedef struct link node;
node * getnode()
{
node *tmp;
tmp =(node *) malloc( sizeof(node) );
printf("\n Enter Coefficient : ");
fflush(stdin);
scanf("%f",&tmp->coef);
printf("\n Enter Exponent : ");
fflush(stdin);
scanf("%d",&tmp->expo);
tmp->next = NULL;
return tmp;
}
node * create_poly (node *p )
{
char ch;
node *temp,*newnode;
while( 1 )
{
printf ("\n Do U Want polynomial node (y/n): ");
ch = getche();
if(ch == 'n')
break;
newnode = getnode();
if( p == NULL )
p = newnode;
else
{
temp = p;
while(temp->next != NULL )
temp = temp->next;
temp->next = newnode;
}

}

Lecture Notes

}
return p;

77

Dept. of Information Technology

void display (node *p)
{
node *t = p;
while (t != NULL)
{
printf("+ %.2f", t -> coef);
printf("X^ %d", t -> expo);
t =t -> next;
}
}
void main()
{

node *poly1 = NULL ,*poly2 = NULL,*poly3=NULL;
clrscr();
printf("\nEnter First Polynomial..(in ascending-order of exponent)");
poly1 = create_poly (poly1);
printf("\nEnter Second Polynomial..(in ascending-order of exponent)");
poly2 = create_poly (poly2);
clrscr();
printf("\n Enter Polynomial 1: ");
display (poly1);
printf("\n Enter Polynomial 2: ");
display (poly2);
getch();

}

3.10.2.

Addition of Polynomials:

To add two polynomials we need to scan them once. If we find terms with the same
exponent in the two polynomials, then we add the coefficients; otherwise, we copy the
term of larger exponent into the sum and go on. When we reach at the end of one of
the polynomial, then remaining part of the other is copied into the sum.
To add two polynomials follow the following steps:
•
•
•

Read two polynomials.
Add them.
Display the resultant polynomial.

3.10.3.

Source code for polynomial addition with help of linked list:

#include <conio.h>
#include <stdio.h>
#include <malloc.h>
struct link
{
float coef;
int expo;
struct link *next;
};
typedef struct link node;
node * getnode()
{
node *tmp;
Lecture Notes

78

Dept. of Information Technology

tmp =(node *) malloc( sizeof(node) );
printf("\n Enter Coefficient : ");
fflush(stdin);
scanf("%f",&tmp->coef);
printf("\n Enter Exponent : ");
fflush(stdin);
scanf("%d",&tmp->expo);
tmp->next = NULL;
return tmp;
}
node * create_poly (node *p )
{
char ch;
node *temp,*newnode;
while( 1 )
{
printf ("\n Do U Want polynomial node (y/n): ");
ch = getche();
if(ch == 'n')
break;
newnode = getnode();
if( p == NULL )
p = newnode;
else
{
temp = p;
while(temp->next != NULL )
temp = temp->next;
temp->next = newnode;
}
}
return p;

}

void display (node *p)
{
node *t = p;
while (t != NULL)
{
printf("+ %.2f", t -> coef);
printf("X^ %d", t -> expo);
t = t -> next;
}
}
void add_poly(node *p1,node *p2)
{
node *newnode;
while(1)
{
if( p1 == NULL || p2 == NULL )
break;
if(p1->expo == p2->expo )
{
printf("+ %.2f X ^%d",p1->coef+p2->coef,p1->expo);
p1 = p1->next; p2 = p2->next;
}
else
{
if(p1->expo < p2->expo)
Lecture Notes

79

Dept. of Information Technology

{
}
else
{
}

printf("+ %.2f X ^%d",p1->coef,p1->expo);
p1 = p1->next;

printf(" + %.2f X ^%d",p2->coef,p2->expo);
p2 = p2->next;

}

}
while(p1 != NULL )
{
printf("+ %.2f X ^%d",p1->coef,p1->expo);
p1 = p1->next;
}
while(p2 != NULL )
{

}

printf("+ %.2f X ^%d",p2->coef,p2->expo);
p2 = p2->next;

}
void main()
{
node *poly1 = NULL ,*poly2 = NULL,*poly3=NULL;
clrscr();
printf("\nEnter First Polynomial..(in ascending-order of exponent)");
poly1 = create_poly (poly1);
printf("\nEnter Second Polynomial..(in ascending-order of exponent)");
poly2 = create_poly (poly2);
clrscr();
printf("\n Enter Polynomial 1: ");
display (poly1);
printf("\n Enter Polynomial 2: ");
display (poly2);
printf( "\n Resultant Polynomial : ");
add_poly(poly1, poly2);
display (poly3);
getch();

}

Exercise
1.

Write a “C” functions to split a given list of integers represented by a single
linked list into two lists in the following way. Let the list be L = (l0, l1, ….., ln).
The resultant lists would be R1 = (l0, l2, l4, …..) and R2 = (l1, l3, l5, …..).

2.

Write a “C” function to insert a node “t” before a node pointed to by “X” in a
single linked list “L”.

3.

Write a “C” function to delete a node pointed to by “p” from a single linked list
“L”.

4.

Suppose that an ordered list L = (l0, l1, …..,ln) is represented by a single linked
list. It is required to append the list L = (ln, l0, l1, ….., ln) after another ordered
list M represented by a single linked list.

Lecture Notes

80

Dept. of Information Technology

5.

Implement the following function as a new function for the linked list
toolkit.
Precondition: head_ptr points to the start of a linked list. The list might
be empty or it might be non-empty.
Postcondition: The return value is the number of occurrences of 42 in
the data field of a node on the linked list. The list itself is unchanged.

6.

Implement the following function as a new function for the linked list
toolkit.
Precondition: head_ptr points to the start of a linked list. The list might
be empty or it might be non-empty.
Postcondition: The return value is true if the list has at least one
occurrence of the number 42 in the data part of a node.

7.

Implement the following function as a new function for the linked list
toolkit.
Precondition: head_ptr points to the start of a linked list. The list might
be empty or it might be non-empty.
Postcondition: The return value is the sum of all the data components of
all the nodes. NOTE: If the list is empty, the function returns 0.

8.

Write a “C” function to concatenate two circular linked lists producing another
circular linked list.

9.

Write “C” functions to compute the following operations on polynomials
represented as singly connected linked list of nonzero terms.
1.
2.

Evaluation of a polynomial
Multiplication of two polynomials.

10.

Write a “C” function to represent a sparse matrix having “m” rows and “n”
columns using linked list.

11.

Write a “C” function to print a sparse matrix, each row in one line of output and
properly formatted, with zero being printed in place of zero elements.

12.

Write “C” functions to:
1.
2.

Add two m X n sparse matrices and
Multiply two m X n sparse matrices.

Where all sparse matrices are to be represented by linked lists.
13.

Consider representing a linked list of integers using arrays. Write a “C” function
to delete the ith node from the list.

Lecture Notes

81

Dept. of Information Technology

Multiple Choice Questions
1.

Which among the following is a linear data structure:
A. Queue
C. Linked List
B. Stack
D. all the above

[

D

]

2.

Which among the following is a dynamic data structure:
A. Double Linked List
C. Stack
B. Queue
D. all the above

[

A

]

3.

The link field in a node contains:
A. address of the next node
B. data of previous node

[

A

]

4.

Memory is allocated dynamically to a data structure during execution
by ------- function.
A. malloc()
C. realloc()
B. Calloc()
D. all the above

[

D

]

5.

How many null pointer/s exist in a circular double linked list?
A. 1
C. 3
B. 2
D. 0

[

D

]

6.

Suppose that p is a pointer variable that contains the NULL pointer.
What happens if your program tries to read or write *p?
A. A syntax error always occurs at compilation time.
B. A run-time error always occurs when *p is evaluated.
C. A run-time error always occurs when the program finishes.
D. The results are unpredictable.

7.

What kind of list is best to answer questions such as: "What is the
item at position n?"
A. Lists implemented with an array.
B. Doubly-linked lists.
C. Singly-linked lists.
D. Doubly-linked or singly-linked lists are equally best.

8.

9.

C. data of next node
D. data of current node

[

]

[

A

]

In a single linked list which operation depends on the length of the list.
A. Delete the last element of the list
B. Add an element before the first element of the list
C. Delete the first element of the list
D. Interchange the first two elements of the list

[

A

]

A double linked list is declared as follows:
struct dllist
{
struct dllist *fwd, *bwd;
int data;
}
Where fwd and bwd represents forward and backward links to adjacent
elements of the list. Which among the following segments of code
deletes the element pointed to by X from the double linked list, if it is
assumed that X points to neither the first nor last element of the list?

[

A

]

Lecture Notes

82

Dept. of Information Technology

A. X -> bwd -> fwd = X -> fwd;
X -> fwd -> bwd = X -> bwd
B. X -> bwd -> fwd = X -> bwd;
X -> fwd -> bwd = X -> fwd
C. X -> bwd -> bwd = X -> fwd;
X -> fwd -> fwd = X -> bwd
D. X -> bwd -> bwd = X -> bwd;
X -> fwd -> fwd = X -> fwd
10.

Which among the following segment of code deletes the element
pointed to by X from the double linked list, if it is assumed that X
points to the first element of the list and start pointer points to
beginning of the list?
A. X -> bwd = X -> fwd;
X -> fwd = X -> bwd
B. start = X -> fwd;
start -> bwd = NULL;
C. start = X -> fwd;
X -> fwd = NULL
D. X -> bwd -> bwd = X -> bwd;
X -> fwd -> fwd = X -> fwd

[

B

]

11.

Which among the following segment of code deletes the element
pointed to by X from the double linked list, if it is assumed that X
points to the last element of the list?
A. X -> fwd -> bwd = NULL;
B. X -> bwd -> fwd = X -> bwd;
C. X -> bwd -> fwd = NULL;
D. X -> fwd -> bwd = X -> bwd;

[

C

]

12.

Which among the following segment of code counts the number of
elements in the double linked list, if it is assumed that X points to the
first element of the list and ctr is the variable which counts the number
of elements in the list?
A. for (ctr=1; X != NULL; ctr++)
X = X -> fwd;
B. for (ctr=1; X != NULL; ctr++)
X = X -> bwd;
C. for (ctr=1; X -> fwd != NULL; ctr++)
X = X -> fwd;
D. for (ctr=1; X -> bwd != NULL; ctr++)
X = X -> bwd;

[

A

]

13.

Which among the following segment of code counts the number of
elements in the double linked list, if it is assumed that X points to the
last element of the list and ctr is the variable which counts the number
of elements in the list?
A. for (ctr=1; X != NULL; ctr++)
X = X -> fwd;
B. for (ctr=1; X != NULL; ctr++)
X = X -> bwd;
C. for (ctr=1; X -> fwd != NULL; ctr++)
X = X -> fwd;
D. for (ctr=1; X -> bwd != NULL; ctr++)
X = X -> bwd;

[

B

]

Lecture Notes

83

Dept. of Information Technology

14.

Which among the following segment of code inserts a new node
pointed by X to be inserted at the beginning of the double linked list.
The start pointer points to beginning of the list?

[

B

]

[

C

]

[

D

]

A. X -> bwd = X -> fwd;
X -> fwd = X -> bwd;
B. X -> fwd = start;
start -> bwd = X;
start = X;
C. X -> bwd = X -> fwd;
X -> fwd = X -> bwd;
start = X;
D. X -> bwd -> bwd = X -> bwd;
X -> fwd -> fwd = X -> fwd
15.

Which among the following segments of inserts a new node pointed by
X to be inserted at the end of the double linked list. The start and last
pointer points to beginning and end of the list respectively?
A. X -> bwd = X -> fwd;
X -> fwd = X -> bwd
B. X -> fwd = start;
start -> bwd = X;
C. last -> fwd = X;
X -> bwd = last;
D. X -> bwd = X -> bwd;
X -> fwd = last;

16.

Which among the following segments of inserts a new node pointed by
X to be inserted at any position (i.e neither first nor last) element of
the double linked list? Assume temp pointer points to the previous
position of new node.
A. X -> bwd -> fwd = X -> fwd;
X -> fwd -> bwd = X -> bwd
B. X -> bwd -> fwd = X -> bwd;
X -> fwd -> bwd = X -> fwd
C. temp -> fwd = X;
temp -> bwd = X -> fwd;
X ->fwd = x
X ->fwd->bwd = temp
D. X -> bwd = temp;
X -> fwd = temp -> fwd;
temp ->fwd = X;
X -> fwd -> bwd = X;

Lecture Notes

84

Dept. of Information Technology

17.

A single linked list is declared as follows:
struct sllist
{
struct sllist *next;
int data;
}
Where next represents links to adjacent elements of the list.

[

A

]

[

B

]

[

C

]

Which among the following segments of code deletes the element
pointed to by X from the single linked list, if it is assumed that X
points to neither the first nor last element of the list? prev pointer
points to previous element.
A. prev -> next = X -> next;
free(X);
B. X -> next = prev-> next;
free(X);
C. prev -> next = X -> next;
free(prev);
D. X -> next = prev -> next;
free(prev);
18.

Which among the following segment of code deletes the element
pointed to by X from the single linked list, if it is assumed that X
points to the first element of the list and start pointer points to
beginning of the list?
A. X = start -> next;
free(X);
B. start = X -> next;
free(X);
C. start = start -> next;
free(start);
D. X = X -> next;
start = X;
free(start);

19.

Which among the following segment of code deletes the element
pointed to by X from the single linked list, if it is assumed that X
points to the last element of the list and prev pointer points to last but
one element?
A. prev -> next = NULL;
free(prev);
B. X -> next = NULL;
free(X);
C. prev -> next = NULL;
free(X);
D X -> next = prev;
free(prev);

Lecture Notes

85

Dept. of Information Technology

20.

Which among the following segment of code counts the number of
elements in the single linked list, if it is assumed that X points to the
first element of the list and ctr is the variable which counts the number
of elements in the list?

[

A

]

[

B

]

[

C

]

[

D

]

A. for (ctr=1; X != NULL; ctr++)
X = X -> next;
B. for (ctr=1; X != NULL; ctr--)
X = X -> next;
C. for (ctr=1; X -> next != NULL; ctr++)
X = X -> next;
D. for (ctr=1; X -> next != NULL; ctr--)
X = X -> next;
21.

Which among the following segment of code inserts a new node
pointed by X to be inserted at the beginning of the single linked list.
The start pointer points to beginning of the list?
A. start -> next = X;
X = start;
B. X -> next = start;
start = X
C. X -> next = start -> next;
start = X
D. X -> next = start;
start = X -> next

22.

Which among the following segments of inserts a new node pointed by
X to be inserted at the end of the single linked list. The start and last
pointer points to beginning and end of the list respectively?
A. last -> next = X;
X -> next = start;
B. X -> next = last;
last ->next = NULL;
C. last -> next = X;
X -> next = NULL;
D. last -> next = X -> next;
X -> next = NULL;

23.

Which among the following segments of inserts a new node pointed by
X to be inserted at any position (i.e neither first nor last) element of
the single linked list? Assume prev pointer points to the previous
position of new node.
A. X -> next = prev -> next;
prev -> next = X -> next;
B. X = prev -> next;
prev -> next = X -> next;
C. X -> next = prev;
prev -> next = X;
D. X -> next = prev -> next;
prev -> next = X;

Lecture Notes

86

Dept. of Information Technology

24.

A circular double linked list is declared as follows:
struct cdllist
{
struct cdllist *fwd, *bwd;
int data;
}
Where fwd and bwd represents forward and backward links to adjacent
elements of the list.

[

A

]

[

D

]

[

B

]

Which among the following segments of code deletes the element
pointed to by X from the circular double linked list, if it is assumed
that X points to neither the first nor last element of the list?
A. X -> bwd -> fwd = X -> fwd;
X -> fwd -> bwd = X -> bwd;
B. X -> bwd -> fwd = X -> bwd;
X -> fwd -> bwd = X -> fwd;
C. X -> bwd -> bwd = X -> fwd;
X -> fwd -> fwd = X -> bwd;
D. X -> bwd -> bwd = X -> bwd;
X -> fwd -> fwd = X -> fwd;
25.

Which among the following segment of code deletes the element
pointed to by X from the circular double linked list, if it is assumed
that X points to the first element of the list and start pointer points to
beginning of the list?
A. start = start -> bwd;
X -> bwd -> bwd = start;
start -> bwd = X -> bwd;
B. start = start -> fwd;
X -> fwd -> fwd = start;
start -> bwd = X -> fwd
C. start = start -> bwd;
X -> bwd -> fwd = X;
start -> bwd = X -> bwd
D. start = start -> fwd;
X -> bwd -> fwd = start;
start -> bwd = X -> bwd;

26.

Which among the following segment of code deletes the element
pointed to by X from the circular double linked list, if it is assumed
that X points to the last element of the list and start pointer points to
beginning of the list?
A. X -> bwd -> fwd = X -> fwd;
X -> fwd -> fwd= X -> bwd;
B. X -> bwd -> fwd = X -> fwd;
X -> fwd -> bwd = X -> bwd;
C. X -> fwd -> fwd = X -> bwd;
X -> fwd -> bwd= X -> fwd;
D. X -> bwd -> bwd = X -> fwd;
X -> bwd -> bwd = X -> bwd;

Lecture Notes

87

Dept. of Information Technology

27.

Which among the following segment of code counts the number of
elements in the circular double linked list, if it is assumed that X and
start points to the first element of the list and ctr is the variable which
counts the number of elements in the list?
A. for (ctr=1; X->fwd != start; ctr++)
X = X -> fwd;
B. for (ctr=1; X != NULL; ctr++)
X = X -> bwd;
C. for (ctr=1; X -> fwd != NULL; ctr++)
X = X -> fwd;
D. for (ctr=1; X -> bwd != NULL; ctr++)
X = X -> bwd;

[

A

]

28.

Which among the following segment of code inserts a new node
pointed by X to be inserted at the beginning of the circular double
linked list. The start pointer points to beginning of the list?
A. X -> bwd = start;
C. X -> fwd = start -> bwd;
X -> bwd = start;
X -> fwd = start -> fwd;
start -> bwd-> fwd = X;
start -> bwd-> fwd = X;
start -> bwd = X;
start -> bwd = X;
start = X
start = X

[

B

]

B. X ->
X ->
start
start
start

bwd = start -> bwd;
fwd = start;
-> bwd-> fwd = X;
-> bwd = X;
=X

D. X -> bwd = start -> bwd;
X -> fwd = start;
start -> fwd-> fwd = X;
start -> fwd = X;
X = start;

29.

Which among the following segment of code inserts a new node
pointed by X to be inserted at the end of the circular double linked list.
The start pointer points to beginning of the list?
A. X -> bwd = start;
C. X -> bwd= start -> bwd;
X -> fwd = start -> fwd;
X-> fwd = start;
start -> bwd -> fwd = X;
start -> bwd -> fwd = X;
start -> bwd = X;
start -> bwd = X;
start = X
D. X -> bwd = start -> bwd;
B. X -> bwd = start -> bwd;
X -> fwd = start;
X -> fwd = start;
start -> fwd-> fwd = X;
start -> bwd -> fwd = X;
start -> fwd = X;
start -> bwd = X;
X = start;
start = X

[

C

]

30.

Which among the following segments of inserts a new node pointed by
X to be inserted at any position (i.e neither first nor last) element of
the circular double linked list? Assume temp pointer points to the
previous position of new node.
A. X -> bwd -> fwd = X -> fwd;
C. temp -> fwd = X;
X -> fwd -> bwd = X -> bwd;
temp -> bwd = X -> fwd;
X -> fwd = X;
B. X -> bwd -> fwd = X -> bwd;
X -> fwd -> bwd = temp;
X -> fwd -> bwd = X -> fwd;
D. X -> bwd = temp;
X -> fwd = temp -> fwd;
temp -> fwd = X;
X -> fwd -> bwd = X;

[

D

]

Lecture Notes

88

Dept. of Information Technology

Chapter

4

Stack and Queue
There are certain situations in computer science that one wants to
restrict insertions and deletions so that they can take place only at the
beginning or the end of the list, not in the middle. Two of such data
structures that are useful are:
•

Stack.

•

Queue.

Linear lists and arrays allow one to insert and delete elements at any
place in the list i.e., at the beginning, at the end or in the middle.
4.1.

STACK:

A stack is a list of elements in which an element may be inserted or deleted only at one
end, called the top of the stack. Stacks are sometimes known as LIFO (last in, first out)
lists.
As the items can be added or removed only from the top i.e. the last item to be added
to a stack is the first item to be removed.
The two basic operations associated with stacks are:
•

Push: is the term used to insert an element into a stack.

•

Pop: is the term used to delete an element from a stack.

“Push” is the term used to insert an element into a stack. “Pop” is the term used to
delete an element from the stack.
All insertions and deletions take place at the same end, so the last element added to
the stack will be the first element removed from the stack. When a stack is created, the
stack base remains fixed while the stack top changes as elements are added and
removed. The most accessible element is the top and the least accessible element is
the bottom of the stack.
4.1.1.

Representation of Stack:

Let us consider a stack with 6 elements capacity. This is called as the size of the stack.
The number of elements to be added should not exceed the maximum size of the stack.
If we attempt to add new element beyond the maximum size, we will encounter a stack
overflow condition. Similarly, you cannot remove elements beyond the base of the
stack. If such is the case, we will reach a stack underflow condition.
When an element is added to a stack, the operation is performed by push(). Figure 4.1
shows the creation of a stack and addition of elements using push().

Lecture Notes

89

Dept. of Information Technology

4

4

4

3

3

3

2

2

1

11

0

TOP
Empty
Stack

22
11

0

Insert
11

3

TOP
33

2

TOP

1

TOP

4

22

1

11

0

Insert
22

2
1
0

Insert
33

Figure 4.1. Push operations on stack

When an element is taken off from the stack, the operation is performed by pop().
Figure 4.2 shows a stack initially with three elements and shows the deletion of
elements using pop().

TOP

33
22
11
Initial
Stack

4

4

4

4

3

3

3

3

2

2

2

1

1

2
1
0

TOP
22

11

1

TOP
11

0

POP

0

TOP

0
POP

POP

Empty
Stack

Figure 4.2. Pop operations on stack

4.1.2.

Source code for stack operations, using array:

# include <stdio.h>
# include <conio.h>
# include <stdlib.h>
# define MAX 6
int stack[MAX];
int top = 0;
int menu()
{
int ch;
clrscr();
printf("\n … Stack operations using ARRAY... ");
printf("\n -----------**********-------------\n");
printf("\n 1. Push ");
printf("\n 2. Pop ");
printf("\n 3. Display");
printf("\n 4. Quit ");
printf("\n Enter your choice: ");
scanf("%d", &ch);
return ch;
}
void display()
{
int i;
if(top == 0)
{
printf("\n\nStack empty..");

Lecture Notes

90

Dept. of Information Technology

}
else
{

}

}

return;

printf("\n\nElements in stack:");
for(i = 0; i < top; i++)
printf("\t%d", stack[i]);

void pop()
{
if(top == 0)
{
printf("\n\nStack Underflow..");
return;
}
else
printf("\n\npopped element is: %d ", stack[--top]);
}
void push()
{
int data;
if(top == MAX)
{
printf("\n\nStack Overflow..");
return;
}
else
{
printf("\n\nEnter data: ");
scanf("%d", &data);
stack[top] = data;
top = top + 1;
printf("\n\nData Pushed into the stack");
}
}
void main()
{
int ch;
do
{

ch = menu();
switch(ch)
{
case 1:
case 2:
case 3:

case 4:

push();
break;
pop();
break;
display();
break;
exit(0);

}
getch();
} while(1);
}

Lecture Notes

91

Dept. of Information Technology

4.1.3.

Linked List Implementation of Stack:

We can represent a stack as a linked list. In a stack push and pop operations are
performed at one end called top. We can perform similar operations at one end of list
using top pointer. The linked stack looks as shown in figure 4.3.
top
400

data

next

40

X

400
30

400

300
20
start
100

300

200
10

200

100
Figure 4.3. Linked stack
representation

4.1.4.

Source code for stack operations, using linked list:
# include <stdio.h>
# include <conio.h>
# include <stdlib.h>
struct stack
{
int data;
struct stack *next;
};
void push();
void pop();
void display();
typedef struct stack node;
node *start=NULL;
node *top = NULL;
node* getnode()
{
node *temp;
temp=(node *) malloc( sizeof(node)) ;
printf("\n Enter data ");
scanf("%d", &temp -> data);
temp -> next = NULL;
return temp;
}
void push(node *newnode)
{
node *temp;
if( newnode == NULL )
{
printf("\n Stack Overflow..");
return;
}

Lecture Notes

92

Dept. of Information Technology

if(start == NULL)
{
start = newnode;
top = newnode;
}
else
{
temp = start;
while( temp -> next != NULL)
temp = temp -> next;
temp -> next = newnode;
top = newnode;
}
printf("\n\n\t Data pushed into stack");

}
void pop()
{
node *temp;
if(top == NULL)
{
printf("\n\n\t Stack underflow");
return;
}
temp = start;
if( start -> next == NULL)
{
printf("\n\n\t Popped element is %d ", top -> data);
start = NULL;
free(top);
top = NULL;
}
else
{
while(temp -> next != top)
{
temp = temp -> next;
}
temp -> next = NULL;
printf("\n\n\t Popped element is %d ", top -> data);
free(top);
top = temp;
}
}
void display()
{
node *temp;
if(top == NULL)
{
printf("\n\n\t\t Stack is empty ");
}
else
{
temp = start;
printf("\n\n\n\t\t Elements in the stack: \n");
printf("%5d ", temp -> data);
while(temp != top)
{
temp = temp -> next;
printf("%5d ", temp -> data);
}
}
}

Lecture Notes

93

Dept. of Information Technology

char menu()
{
char ch;
clrscr();
printf("\n \tStack operations using pointers.. ");
printf("\n -----------**********-------------\n");
printf("\n 1. Push ");
printf("\n 2. Pop ");
printf("\n 3. Display");
printf("\n 4. Quit ");
printf("\n Enter your choice: ");
ch = getche();
return ch;
}
void main()
{
char ch;
node *newnode;
do
{
ch = menu();
switch(ch)
{
case '1' :
newnode = getnode();
push(newnode);
break;
case '2' :
pop();
break;
case '3' :
display();
break;
case '4':
return;
}
getch();
} while( ch != '4' );
}

4.2.

Algebraic Expressions:

An algebraic expression is a legal combination of operators and operands. Operand is
the quantity on which a mathematical operation is performed. Operand may be a
variable like x, y, z or a constant like 5, 4, 6 etc. Operator is a symbol which signifies a
mathematical or logical operation between the operands. Examples of familiar
operators include +, -, *, /, ^ etc.
An algebraic expression can be represented using three different notations. They are
infix, postfix and prefix notations:
Infix:

It is the form of an arithmetic expression in which we fix (place) the
arithmetic operator in between the two operands.
Example: (A + B) * (C - D)

Prefix:

It is the form of an arithmetic notation in which we fix (place) the arithmetic
operator before (pre) its two operands. The prefix notation is called as

Lecture Notes

94

Dept. of Information Technology

polish notation (due to the polish mathematician Jan Lukasiewicz in the
year 1920).
Example: * + A B – C D
Postfix:

It is the form of an arithmetic expression in which we fix (place) the
arithmetic operator after (post) its two operands. The postfix notation is
called as suffix notation and is also referred to reverse polish notation.
Example: A B + C D - *

The three important features of postfix expression are:
1. The operands maintain the same order as in the equivalent infix expression.
2. The parentheses
ambiguously.

are

not

needed

to

designate

the

expression

un-

3. While evaluating the postfix expression the priority of the operators is no
longer relevant.
We consider five binary operations: +, -, *, / and $ or ↑ (exponentiation). For these
binary operations, the following in the order of precedence (highest to lowest):

OPERATOR

PRECEDENCE

VALUE

Highest

3

*, /

Next highest

2

+, -

Lowest

1

Exponentiation ($ or ↑ or ^)

4.3.

Converting expressions using Stack:

Let us convert the expressions from one type to another. These can be done as follows:
1.
2.
3.
4.
5.
6.

Infix to postfix
Infix to prefix
Postfix to infix
Postfix to prefix
Prefix to infix
Prefix to postfix

4.3.1.

Conversion from infix to postfix:

Procedure to convert from infix expression to postfix expression is as follows:
1.

Scan the infix expression from left to right.

2.

a)

If the scanned symbol is left parenthesis, push it onto the stack.

b)

If the scanned symbol is an operand, then place directly in the postfix
expression (output).

Lecture Notes

95

Dept. of Information Technology

c)

If the symbol scanned is a right parenthesis, then go on popping all
the items from the stack and place them in the postfix expression till
we get the matching left parenthesis.

d)

If the scanned symbol is an operator, then go on removing all the
operators from the stack and place them in the postfix expression, if
and only if the precedence of the operator which is on the top of the
stack is greater than (or greater than or equal) to the precedence of
the scanned operator and push the scanned operator onto the stack
otherwise, push the scanned operator onto the stack.

Example 1:
Convert ((A – (B + C)) * D) ↑ (E + F) infix expression to postfix form:
SYMBOL

POSTFIX STRING

STACK

(

(

(

((

REMARKS

A

A

((

-

A

((-

(

A

((-(

B

AB

((-(

+

AB

((-(+

C

ABC

((-(+

)

ABC+

((-

)

ABC+-

(

*

ABC+-

(*

D

ABC+-D

(*

)

ABC+-D*

↑

ABC+-D*

↑

(

ABC+-D*

↑(

E

ABC+-D*E

↑(

+

ABC+-D*E

↑(+

F

ABC+-D*EF

↑(+

)

ABC+-D*EF+

↑

ABC+-D*EF+↑

The input is now empty. Pop the output symbols
from the stack until it is empty.

End of
string

Example 2:
Convert a + b * c + (d * e + f) * g the infix expression into postfix form.
SYMBOL

POSTFIX STRING

a

a

+

a

+

b

ab

+

Lecture Notes

STACK

96

REMARKS

Dept. of Information Technology

*

ab

+*

c

abc

+*

+

abc*+

+

(

abc*+

+(

d

abc*+d

+(

*

abc*+d

+(*

e

abc*+de

+(*

+

abc*+de*

+(+

f

abc*+de*f

+(+

)

abc*+de*f+

+

*

abc*+de*f+

+*

g

abc*+de*f+g

+*

End of
string

abc*+de*f+g*+

The input is now empty. Pop the output symbols
from the stack until it is empty.

Example 3:
Convert the following infix expression A + B * C – D / E * H into its equivalent postfix
expression.
SYMBOL

POSTFIX STRING

STACK

A

A

+

A

+

B

AB

+

*

AB

+*

C

ABC

+*

-

ABC*+

-

D

ABC*+D

-

REMARKS

/

ABC*+D

-/

E

ABC*+DE

-/

*

ABC*+DE/

-*

H
End of
string

ABC*+DE/H

-*
The input is now empty. Pop the output symbols from
the stack until it is empty.

ABC*+DE/H*-

Example 4:
Convert the following infix expression A + (B * C – (D / E ↑ F) * G) * H into its
equivalent postfix expression.
SYMBOL

POSTFIX STRING

A

A

+

A

Lecture Notes

STACK

REMARKS

+

97

Dept. of Information Technology

(

A

+(

B

AB

+(

*

AB

+(*

C

ABC

+(*

-

ABC*

+(-

(

ABC*

+(-(

D

ABC*D

+(-(

/

ABC*D

+(-(/

E

ABC*DE

+(-(/

↑

ABC*DE

+(-(/↑

F

ABC*DEF

+(-(/↑

)

ABC*DEF↑/

+(-

*

ABC*DEF↑/

+(-*

G

ABC*DEF↑/G

+(-*

)

ABC*DEF↑/G*-

+

*

ABC*DEF↑/G*-

+*

H

ABC*DEF↑/G*-H

+*

End of
string

ABC*DEF↑/G*-H*+

The input is now empty. Pop the output
symbols from the stack until it is empty.

4.3.2.

Program to convert an infix to postfix expression:

# include <string.h>
char postfix[50];
char infix[50];
char opstack[50];
int i, j, top = 0;

/* operator stack */

int lesspriority(char op, char op_at_stack)
{
int k;
int pv1;
/* priority value of op */
int pv2;
/* priority value of op_at_stack */
char operators[] = {'+', '-', '*', '/', '%', '^', '(' };
int priority_value[] = {0,0,1,1,2,3,4};
if( op_at_stack == '(' )
return 0;
for(k = 0; k < 6; k ++)
{
if(op == operators[k])
pv1 = priority_value[k];
}
for(k = 0; k < 6; k ++)
{
if(op_at_stack == operators[k])
pv2 = priority_value[k];
}
if(pv1 < pv2)
return 1;
else
return 0;
}

Lecture Notes

98

Dept. of Information Technology

void push(char op)
/* op - operator */
{
if(top == 0)
/* before pushing the operator
{
'op' into the stack check priority
opstack[top] = op;
of op with top of opstack if less
top++;
then pop the operator from stack
}
then push into postfix string else
else
push op onto stack itself */
{
if(op != '(' )
{
while(lesspriority(op, opstack[top-1]) == 1 && top > 0)
{
postfix[j] = opstack[--top];
j++;
}
}
opstack[top] = op;
/* pushing onto stack */
top++;
}
}
pop()
{

while(opstack[--top] != '(' )
{
postfix[j] = opstack[top];
j++;
}

/* pop until '(' comes

*/

}
void main()
{
char ch;
clrscr();
printf("\n Enter Infix Expression : ");
gets(infix);
while( (ch=infix[i++]) != ‘\0’)
{
switch(ch)
{
case ' ' : break;
case '(' :
case '+' :
case '-' :
case '*' :
case '/' :
case '^' :
case '%' :
push(ch);
break;
case ')' :
pop();
break;
default :
postfix[j] = ch;
j++;
}
}
while(top >= 0)
{
postfix[j] = opstack[--top];
j++;

Lecture Notes

/* check priority and push */

99

Dept. of Information Technology

}
postfix[j] = '\0';
printf("\n Infix Expression : %s ", infix);
printf("\n Postfix Expression : %s ", postfix);
getch();

}

4.3.3.

Conversion from infix to prefix:

The precedence rules for converting an expression from infix to prefix are identical. The
only change from postfix conversion is that traverse the expression from right to left
and the operator is placed before the operands rather than after them. The prefix form
of a complex expression is not the mirror image of the postfix form.
Example 1:
Convert the infix expression A + B - C into prefix expression.
SYMBOL

PREFIX
STRING

STACK

C

C

-

C

-

B

BC

-

+

BC

-+

A

ABC

-+

End of
string

-+ABC

REMARKS

The input is now empty. Pop the output symbols from the
stack until it is empty.

Example 2:
Convert the infix expression (A + B) * (C - D) into prefix expression.
SYMBOL

PREFIX
STRING

STACK

)

REMARKS
)

D

D

)

-

D

)-

C

CD

)-

(

-CD

*

-CD

*

)

-CD

*)

B

B-CD

*)

+

B-CD

*)+

A

AB-CD

*)+

(

+AB–CD

*

End of
string

Lecture Notes

*+AB–CD

The input is now empty. Pop the output symbols from the
stack until it is empty.

100

Dept. of Information Technology

Example 3:
Convert the infix expression A ↑ B * C – D + E / F / (G + H) into prefix expression.
SYMBOL

PREFIX STRING

STACK

)

)

H

H

)

+

H

)+

G

GH

)+

(

+GH

/

+GH

/

F

F+GH

/

/

F+GH

//

E

EF+GH

//

+

//EF+GH

+

D

D//EF+GH

+

-

D//EF+GH

+-

C

CD//EF+GH

+-

*

CD//EF+GH

+-*

B

BCD//EF+GH

+-*

↑

BCD//EF+GH

+-*↑

A

ABCD//EF+GH

+-*↑

End of
string

4.3.4.

REMARKS

+-*↑ABCD//EF+GH

The input is now empty. Pop the output
symbols from the stack until it is empty.

Program to convert an infix to prefix expression:

# include <conio.h>
# include <string.h>
char prefix[50];
char infix[50];
char opstack[50];
int j, top = 0;

/* operator stack */

void insert_beg(char ch)
{
int k;
if(j == 0)
prefix[0] = ch;
else
{
for(k = j + 1; k > 0; k--)
prefix[k] = prefix[k - 1];
prefix[0] = ch;
}
j++;
}

Lecture Notes

101

Dept. of Information Technology

int lesspriority(char op, char op_at_stack)
{
int k;
int pv1;
/* priority value of op */
int pv2;
/* priority value of op_at_stack */
char operators[] = {'+', '-', '*', '/', '%', '^', ')'};
int priority_value[] = {0, 0, 1, 1, 2, 3, 4};
if(op_at_stack == ')' )
return 0;
for(k = 0; k < 6; k ++)
{
if(op == operators[k])
pv1 = priority_value[k];
}
for(k = 0; k < 6; k ++)
{
if( op_at_stack == operators[k] )
pv2 = priority_value[k];
}
if(pv1 < pv2)
return 1;
else
return 0;
}
void push(char op)
/* op – operator */
{
if(top == 0)
{
opstack[top] = op;
top++;
}
else
{
if(op != ')')
{
/* before pushing the operator 'op' into the stack check priority of op
with top of operator stack if less pop the operator from stack then push into
postfix string else push op onto stack itself */
while(lesspriority(op, opstack[top-1]) == 1 && top > 0)
{
insert_beg(opstack[--top]);
}

}

}

}
opstack[top] = op;
top++;

/* pushing onto stack

void pop()
{
while(opstack[--top] != ')')
insert_beg(opstack[top]);
}

*/

/* pop until ')' comes; */

void main()
{
char ch;
int l, i = 0;
clrscr();
printf("\n Enter Infix Expression : ");

Lecture Notes

102

Dept. of Information Technology

}

gets(infix);
l = strlen(infix);
while(l > 0)
{
ch = infix[--l];
switch(ch)
{
case ' ' : break;
case ')' :
case '+' :
case '-' :
case '*' :
case '/' :
case '^' :
case '%' :
push(ch);
break;
case '(' :
pop();
break;
default :
insert_beg(ch);
}
}
while( top > 0 )
{
insert_beg( opstack[--top] );
j++;
}
prefix[j] = '\0';
printf("\n Infix Expression : %s ", infix);
printf("\n Prefix Expression : %s ", prefix);
getch();

4.3.5.

/* check priority and push */

Conversion from postfix to infix:

Procedure to convert postfix expression to infix expression is as follows:
1.

Scan the postfix expression from left to right.

2.

If the scanned symbol is an operand, then push it onto the stack.

3.

If the scanned symbol is an operator, pop two symbols from the stack
and create it as a string by placing the operator in between the operands
and push it onto the stack.

4.

Repeat steps 2 and 3 till the end of the expression.

Example:
Convert the following postfix expression A B C * D E F ^ / G * - H * + into its
equivalent infix expression.

Lecture Notes

103

Dept. of Information Technology

Symbol

Stack

Remarks

A

A

B

A

B

C

A

B

*

A

(B*C)

D

A

(B*C)

D

E

A

(B*C)

D

E

F

A

(B*C)

D

E

^

A

(B*C)

D

(E^F)

/

A

(B*C)

(D/(E^F))

G

A

(B*C)

(D/(E^F))

*

A

(B*C)

((D/(E^F))*G)

-

A

((B*C) – ((D/(E^F))*G))

H

A

((B*C) – ((D/(E^F))*G))

*

A

(((B*C) – ((D/(E^F))*G)) * H)

+

(A + (((B*C) – ((D/(E^F))*G)) * H))

End of
string

Push B
C

Push C
Pop two operands and place the
operator in between the operands and
push the string.
Push D
Push E
F

Push F
Pop two operands and place the
operator in between the operands and
push the string.
Pop two operands and place the
operator in between the operands and
push the string.
G

Push G
Pop two operands and place the
operator in between the operands and
push the string.
Pop two operands and place the
operator in between the operands and
push the string.
H

Push H
Pop two operands and place the
operator in between the operands and
push the string.

The input is now empty. The string formed is infix.

4.3.6.
#
#
#
#

Push A

Program to convert postfix to infix expression:

include <stdio.h>
include <conio.h>
include <string.h>
define MAX 100

void pop (char*);
void push(char*);
char stack[MAX] [MAX];
int top = -1;

Lecture Notes

104

Dept. of Information Technology

void main()
{
char s[MAX], str1[MAX], str2[MAX], str[MAX];
char s1[2],temp[2];
int i=0;
clrscr( ) ;
printf("\Enter the postfix expression; ");
gets(s);
while (s[i]!='\0')
{
if(s[i] == ' ' )
/*skip whitespace, if any*/
i++;
if (s[i] == '^' || s[i] == '*'|| s[i] == '-' || s[i] == '+' || s[i] == '/')
{
pop(str1);
pop(str2);
temp[0] ='(';
temp[1] ='\0';
strcpy(str, temp);
strcat(str, str2);
temp[0] = s[i];
temp[1] = '\0';
strcat(str,temp);
strcat(str, str1);
temp[0] =')';
temp[1] ='\0';
strcat(str,temp);
push(str);
}
else
{
temp[0]=s[i];
temp[1]='\0';
strcpy(s1, temp);
push(s1);
}
i++;
}
printf("\nThe Infix expression is: %s", stack[0]);
}
void pop(char *a1)
{
strcpy(a1,stack[top]);
top--;
}
void push (char*str)
{
if(top == MAX - 1)
printf("\nstack is full");
else
{
top++;
strcpy(stack[top], str);
}
}

Lecture Notes

105

Dept. of Information Technology

4.3.7.

Conversion from postfix to prefix:

Procedure to convert postfix expression to prefix expression is as follows:
1.

Scan the postfix expression from left to right.

2.

If the scanned symbol is an operand, then push it onto the stack.

3.

If the scanned symbol is an operator, pop two symbols from the stack
and create it as a string by placing the operator in front of the operands
and push it onto the stack.

5.

Repeat steps 2 and 3 till the end of the expression.

Example:
Convert the following postfix expression A B C * D E F ^ / G * - H * + into its
equivalent prefix expression.
Symbol

Stack

A

A

B

A

B

C

A

B

*

A

*BC

D

A

*BC

D

E

A

*BC

D

E

F

A

*BC

D

E

^

A

*BC

D

/

A

*BC

/D^EF

G

A

*BC

/D^EF

*

A

*BC

*/D^EFG

-

A

- *BC*/D^EFG

H

A

- *BC*/D^EFG

*

A

*- *BC*/D^EFGH

+

+A*-*BC*/D^EFGH

End of
string

Remarks
Push A
Push B

C

Push C
Pop two operands and place the operator in
front the operands and push the string.
Push D
Push E
F

Push F
Pop two operands and place the operator in
front the operands and push the string.

^EF

Pop two operands and place the operator in
front the operands and push the string.
G

Push G
Pop two operands and place the operator in
front the operands and push the string.
Pop two operands and place the operator in
front the operands and push the string.
H

Push H
Pop two operands and place the operator in
front the operands and push the string.

The input is now empty. The string formed is prefix.

Lecture Notes

106

Dept. of Information Technology

4.3.8.

Program to convert postfix to prefix expression:

# include <conio.h>
# include <string.h>
#define MAX 100
void pop (char *a1);
void push(char *str);
char stack[MAX][MAX];
int top =-1;
main()
{

}

char s[MAX], str1[MAX], str2[MAX], str[MAX];
char s1[2], temp[2];
int i = 0;
clrscr();
printf("Enter the postfix expression; ");
gets (s);
while(s[i]!='\0')
{
/*skip whitespace, if any */
if (s[i] == ' ')
i++;
if(s[i] == '^' || s[i] == '*' || s[i] == '-' || s[i]== '+' || s[i] == '/')
{
pop (str1);
pop (str2);
temp[0] = s[i];
temp[1] = '\0';
strcpy (str, temp);
strcat(str, str2);
strcat(str, str1);
push(str);
}
else
{
temp[0] = s[i];
temp[1] = '\0';
strcpy (s1, temp);
push (s1);
}
i++;
}
printf("\n The prefix expression is: %s", stack[0]);

void pop(char*a1)
{
if(top == -1)
{
printf("\nStack is empty");
return ;
}
else
{
strcpy (a1, stack[top]);
top--;
}
}

Lecture Notes

107

Dept. of Information Technology

void push (char *str)
{
if(top == MAX - 1)
printf("\nstack is full");
else
{
top++;
strcpy(stack[top], str);
}
}

4.3.9.

Conversion from prefix to infix:

Procedure to convert prefix expression to infix expression is as follows:
1.

Scan the prefix expression from right to left (reverse order).

2.

If the scanned symbol is an operand, then push it onto the stack.

3.

If the scanned symbol is an operator, pop two symbols from the stack
and create it as a string by placing the operator in between the operands
and push it onto the stack.

4.

Repeat steps 2 and 3 till the end of the expression.

Example:
Convert the following prefix expression + A * - * B C * / D ^ E F G H into its equivalent
infix expression.
Symbol

Stack

Remarks

H

H

G

H

G

F

H

G

F

E

H

G

F

^

H

G

(E^F)

D

H

G

(E^F)

/

H

G

(D/(E^F))

*

H

((D/(E^F))*G)

C

H

((D/(E^F))*G)

C

B

H

((D/(E^F))*G)

C

*

H

((D/(E^F))*G)

(B*C)

-

H

((B*C)-((D/(E^F))*G))

Lecture Notes

Push H
Push G
Push F
E

Push E
Pop two operands and place the operator
in between the operands and push the
string.
D

Push D
Pop two operands and place the operator
in between the operands and push the
string.
Pop two operands and place the operator
in between the operands and push the
string.
Push C
B

Push B
Pop two operands and place the operator
in front the operands and push the
string.
Pop two operands and place the operator
in front the operands and push the

108

Dept. of Information Technology

string.
Pop two operands and place the operator
in front the operands and push the
string.

*

(((B*C)-((D/(E^F))*G))*H)

A

(((B*C)-((D/(E^F))*G))*H)

+

(A+(((B*C)-((D/(E^F))*G))*H))

End of
string

A

Push A
Pop two operands and place the operator
in front the operands and push the
string.

The input is now empty. The string formed is infix.

4.3.10.

Program to convert prefix to infix expression:

# include <string.h>
# define MAX 100
void pop (char*);
void push(char*);
char stack[MAX] [MAX];
int top = -1;
void main()
{
char s[MAX], str1[MAX], str2[MAX], str[MAX];
char s1[2],temp[2];
int i=0;
clrscr( ) ;
printf("\Enter the prefix expression; ");
gets(s);
strrev(s);
while (s[i]!='\0')
{
/*skip whitespace, if any*/
if(s[i] == ' ' )
i++;
if (s[i] == '^' || s[i] == '*'|| s[i] == '-' || s[i] == '+' || s[i] == '/')
{
pop(str1);
pop(str2);
temp[0] ='(';
temp[1] ='\0';
strcpy(str, temp);
strcat(str, str1);
temp[0] = s[i];
temp[1] = '\0';
strcat(str,temp);
strcat(str, str2);
temp[0] =')';
temp[1] ='\0';
strcat(str,temp);
push(str);
}
else
{
temp[0]=s[i];
temp[1]='\0';
strcpy(s1, temp);
push(s1);

Lecture Notes

109

Dept. of Information Technology

}
i++;
}

}
printf("\nThe infix expression is: %s", stack[0]);

void pop(char *a1)
{
strcpy(a1,stack[top]);
top--;
}
void push (char*str)
{
if(top == MAX - 1)
printf("\nstack is full");
else
{
top++;
strcpy(stack[top], str);
}
}

4.3.11.

Conversion from prefix to postfix:

Procedure to convert prefix expression to postfix expression is as follows:
1.

Scan the prefix expression from right to left (reverse order).

2.

If the scanned symbol is an operand, then push it onto the stack.

3.

If the scanned symbol is an operator, pop two symbols from the stack
and create it as a string by placing the operator after the operands and
push it onto the stack.

4.

Repeat steps 2 and 3 till the end of the expression.

Example:
Convert the following prefix expression + A * - * B C * / D ^ E F G H into its equivalent
postfix expression.
Symbol

Stack

H

H

G

H

G

F

H

G

F

E

H

G

F

^

H

G

EF^

D

H

G

EF^

Lecture Notes

Remarks
Push H
Push G
Push F

E

Push E
Pop two operands and place the operator
after the operands and push the string.
D

Push D

110

Dept. of Information Technology

Pop two operands and place the operator
after the operands and push the string.

/

H

G

*

H

DEF^/G*

C

H

DEF^/G*

C

B

H

DEF^/G*

C

*

H

DEF^/G*

BC*

-

H

BC*DEF^/G*-

*

BC*DEF^/G*-H*

A

BC*DEF^/G*-H*

+

ABC*DEF^/G*-H*+

End of
string

DEF^/

Pop two operands and place the operator
after the operands and push the string.
Push C
B

Push B
Pop two operands and place the operator
after the operands and push the string.
Pop two operands and place the operator
after the operands and push the string.
Pop two operands and place the operator
after the operands and push the string.

A

Push A
Pop two operands and place the operator
after the operands and push the string.

The input is now empty. The string formed is postfix.

4.3.12.

Program to convert prefix to postfix expression:

# include <stdio.h>
# include <conio.h>
# include <string.h>
#define MAX 100
void pop (char *a1);
void push(char *str);
char stack[MAX][MAX];
int top =-1;
void main()
{
char s[MAX], str1[MAX], str2[MAX], str[MAX];
char s1[2], temp[2];
int i = 0;
clrscr();
printf("Enter the prefix expression; ");
gets (s);
strrev(s);
while(s[i]!='\0')
{
if (s[i] == ' ')
/*skip whitespace, if any */
i++;
if(s[i] == '^' || s[i] == '*' || s[i] == '-' || s[i]== '+' || s[i] == '/')
{
pop (str1);
pop (str2);
temp[0] = s[i];
temp[1] = '\0';
strcat(str1,str2);
strcat (str1, temp);
strcpy(str, str1);
push(str);
}

Lecture Notes

111

Dept. of Information Technology

else
{
temp[0] = s[i];
temp[1] = '\0';
strcpy (s1, temp);
push (s1);
}
i++;

}
printf("\nThe postfix expression is: %s", stack[0]);

}
void pop(char*a1)
{
if(top == -1)
{
printf("\nStack is empty");
return ;
}
else
{
strcpy (a1, stack[top]);
top--;
}
}
void push (char *str)
{
if(top == MAX - 1)
printf("\nstack is full");
else
{
top++;
strcpy(stack[top], str);
}
}

4.4.

Evaluation of postfix expression:

The postfix expression is evaluated easily by the use of a stack. When a number is
seen, it is pushed onto the stack; when an operator is seen, the operator is applied to
the two numbers that are popped from the stack and the result is pushed onto the
stack. When an expression is given in postfix notation, there is no need to know any
precedence rules; this is our obvious advantage.
Example 1:
Evaluate the postfix expression: 6 5 2 3 + 8 * + 3 + *
SYMBOL

OPERAND
1

OPERAND 2

VALUE

STACK

6

6

5

6, 5

2

6, 5, 2

3

6, 5, 2, 3

+

Lecture Notes

2

3

5

6, 5, 5

112

REMARKS

The first four symbols are placed on
the stack.
Next a ‘+’ is read, so 3 and 2 are
popped from the stack and their
sum 5, is pushed

Dept. of Information Technology

8

2

3

5

6, 5, 5, 8

*

5

8

40

6, 5, 40

+

5

40

45

6, 45

3

5

40

45

6, 45, 3

+

45

3

48

6, 48

*

6

48

288

288

Next 8 is pushed
Now a ‘*’ is seen, so 8 and 5 are
popped as 8 * 5 = 40 is pushed
Next, a ‘+’ is seen, so 40 and 5 are
popped and 40 + 5 = 45 is pushed
Now, 3 is pushed
Next, ‘+’ pops 3 and 45 and pushes
45 + 3 = 48 is pushed
Finally, a ‘*’ is seen and 48 and 6
are popped, the result 6 * 48 =
288 is pushed

Example 2:
Evaluate the following postfix expression: 6 2 3 + - 3 8 2 / + * 2 ↑ 3 +
SYMBOL

4.4.1.

OPERAND 1

OPERAND 2

VALUE

STACK

6

6

2

6, 2

3

6, 2, 3

+

2

3

5

6, 5

-

6

5

1

1

3

6

5

1

1, 3

8

6

5

1

1, 3, 8

2

6

5

1

1, 3, 8, 2

/

8

2

4

1, 3, 4

+

3

4

7

1, 7

*

1

7

7

7

2

1

7

7

7, 2

↑

7

2

49

49

3

7

2

49

49, 3

+

49

3

52

52

Program to evaluate a postfix expression:

# include <conio.h>
# include <math.h>
# define MAX 20
int isoperator(char ch)
{
if(ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '^')
return 1;
else
return 0;
}

Lecture Notes

113

Dept. of Information Technology

void main(void)
{
char postfix[MAX];
int val;
char ch;
int i = 0, top = 0;
float val_stack[MAX], val1, val2, res;
clrscr();
printf("\n Enter a postfix expression: ");
scanf("%s", postfix);
while((ch = postfix[i]) != '\0')
{
if(isoperator(ch) == 1)
{
val2 = val_stack[--top];
val1 = val_stack[--top];
switch(ch)
{
case '+':
res = val1 + val2;
break;
case '-':
res = val1 - val2;
break;
case '*':
res = val1 * val2;
break;
case '/':
res = val1 / val2;
break;
case '^':
res = pow(val1, val2);
break;
}
val_stack[top] = res;
}
else
val_stack[top] = ch-48; /*convert character digit to integer digit */
top++;
i++;
}
printf("\n Values of %s is : %f ",postfix, val_stack[0] );
getch();
}

4.5.

Applications of stacks:

1.

Stack is used by compilers to check for balancing of parentheses, brackets
and braces.

2.

Stack is used to evaluate a postfix expression.

3.

Stack is used to convert an infix expression into postfix/prefix form.

4.

In recursion, all intermediate arguments and return values are stored on the
processor’s stack.

5.

During a function call the return address and arguments are pushed onto a
stack and on return they are popped off.

Lecture Notes

114

Dept. of Information Technology

4.6.

Queue:

A queue is another special kind of list, where items are inserted at one end called the
rear and deleted at the other end called the front. Another name for a queue is a
“FIFO” or “First-in-first-out” list.
The operations for a queue are analogues to those for a stack, the difference is that the
insertions go at the end of the list, rather than the beginning. We shall use the
following operations on queues:
•

enqueue: which inserts an element at the end of the queue.

•

dequeue: which deletes an element at the start of the queue.

4.6.1.

Representation of Queue:

Let us consider a queue, which can hold maximum of five elements. Initially the queue
is empty.
0

1

2

3

4
Q u e u e E mp t y
F RO NT = RE A R = 0

F R

Now, insert 11 to the queue. Then queue status will be:
0

1

2

3

4
RE A R = RE A R + 1 = 1
F RO NT = 0

11

F

R

Next, insert 22 to the queue. Then the queue status is:
0

1

11

22

F

2

3

4
RE A R = RE A R + 1 = 2
F RO NT = 0

R

Again insert another element 33 to the queue. The status of the queue is:
0

1

2

11

22

33

F

Lecture Notes

3

4
RE A R = RE A R + 1 = 3
F RO NT = 0

R

115

Dept. of Information Technology

Now, delete an element. The element deleted is the element at the front of the queue.
So the status of the queue is:
0

1

2

22

33

F

3

4
RE A R = 3
F RO NT = F R O NT + 1 = 1

R

Again, delete an element. The element to be deleted is always pointed to by the FRONT
pointer. So, 22 is deleted. The queue status is as follows:
0

1

2

3

4
RE A R = 3
F RO NT = F R O NT + 1 = 2

33

F

R

Now, insert new elements 44 and 55 into the queue. The queue status is:
0

1

2
33

3

4

44

55

F

RE A R = 5
F RO NT = 2

R

Next insert another element, say 66 to the queue. We cannot insert 66 to the queue as
the rear crossed the maximum size of the queue (i.e., 5). There will be queue full
signal. The queue status is as follows:
0

1

2
33

3

4

44

55

F

RE A R = 5
F RO NT = 2

R

Now it is not possible to insert an element 66 even though there are two vacant
positions in the linear queue. To over come this problem the elements of the queue are
to be shifted towards the beginning of the queue so that it creates vacant position at
the rear end. Then the FRONT and REAR are to be adjusted properly. The element 66
can be inserted at the rear end. After this operation, the queue status is as follows:
0

1

2

33

44

55

F

3

4
RE A R = 4
F RO NT = 0

66

R

This difficulty can overcome if we treat queue position with index 0 as a position that
comes after position with index 4 i.e., we treat the queue as a circular queue.

Lecture Notes

116

Dept. of Information Technology

4.6.2.

Source code for Queue operations using array:

In order to create a queue we require a one dimensional array Q(1:n) and two
variables front and rear. The conventions we shall adopt for these two variables are
that front is always 1 less than the actual front of the queue and rear always points to
the last element in the queue. Thus, front = rear if and only if there are no elements in
the queue. The initial condition then is front = rear = 0. The various queue operations
to perform creation, deletion and display the elements in a queue are as follows:
1.

insertQ(): inserts an element at the end of queue Q.

2.

deleteQ(): deletes the first element of Q.

3.

displayQ(): displays the elements in the queue.

# include <conio.h>
# define MAX 6
int Q[MAX];
int front, rear;
void insertQ()
{
int data;
if(rear == MAX)
{
printf("\n Linear Queue is full");
return;
}
else
{
printf("\n Enter data: ");
scanf("%d", &data);
Q[rear] = data;
rear++;
printf("\n Data Inserted in the Queue ");
}
}
void deleteQ()
{
if(rear == front)
{
printf("\n\n Queue is Empty..");
return;
}
else
{
printf("\n Deleted element from Queue is %d", Q[front]);
front++;
}
}
void displayQ()
{
int i;
if(front == rear)
{
printf("\n\n\t Queue is Empty");
return;
}
else
{
printf("\n Elements in Queue are: ");
for(i = front; i < rear; i++)

Lecture Notes

117

Dept. of Information Technology

{

printf("%d\t", Q[i]);

}

}
}
int menu()
{
int ch;
clrscr();
printf("\n \tQueue operations using ARRAY..");
printf("\n -----------**********-------------\n");
printf("\n 1. Insert ");
printf("\n 2. Delete ");
printf("\n 3. Display");
printf("\n 4. Quit ");
printf("\n Enter your choice: ");
scanf("%d", &ch);
return ch;
}
void main()
{
int ch;
do
{
ch = menu();
switch(ch)
{
case 1:
insertQ();
break;
case 2:
deleteQ();
break;
case 3:
displayQ();
break;
case 4:
return;
}
getch();
} while(1);
}

4.6.3.

Linked List Implementation of Queue:

We can represent a queue as a linked list. In a queue data is deleted from the front end
and inserted at the rear end. We can perform similar operations on the two ends of a
list. We use two pointers front and rear for our linked queue implementation.
The linked queue looks as shown in figure 4.4:
front

rear

100

400

10
100

200

20

300

200

30

400

300

40

X

400

Figure 4.4. Linked Queue representation

Lecture Notes

118

Dept. of Information Technology

4.6.4.

Source code for queue operations using linked list:
# include <stdlib.h>
# include <conio.h>
struct queue
{
int data;
struct queue *next;
};
typedef struct queue node;
node *front = NULL;
node *rear = NULL;
node* getnode()
{
node *temp;
temp = (node *) malloc(sizeof(node)) ;
printf("\n Enter data ");
scanf("%d", &temp -> data);
temp -> next = NULL;
return temp;
}
void insertQ()
{
node *newnode;
newnode = getnode();
if(newnode == NULL)
{
printf("\n Queue Full");
return;
}
if(front == NULL)
{
front = newnode;
rear = newnode;
}
else
{
rear -> next = newnode;
rear = newnode;
}
printf("\n\n\t Data Inserted into the Queue..");
}
void deleteQ()
{
node *temp;
if(front == NULL)
{
printf("\n\n\t Empty Queue..");
return;
}
temp = front;
front = front -> next;
printf("\n\n\t Deleted element from queue is %d ", temp -> data);
free(temp);
}

Lecture Notes

119

Dept. of Information Technology

void displayQ()
{
node *temp;
if(front == NULL)
{
printf("\n\n\t\t Empty Queue ");
}
else
{
temp = front;
printf("\n\n\n\t\t Elements in the Queue are: ");
while(temp != NULL )
{
printf("%5d ", temp -> data);
temp = temp -> next;
}
}
}
char menu()
{
char ch;
clrscr();
printf("\n \t..Queue operations using pointers.. ");
printf("\n\t -----------**********-------------\n");
printf("\n 1. Insert ");
printf("\n 2. Delete ");
printf("\n 3. Display");
printf("\n 4. Quit ");
printf("\n Enter your choice: ");
ch = getche();
return ch;
}
void main()
{
char ch;
do
{
ch = menu();
switch(ch)
{
case '1' :
insertQ();
break;
case '2' :
deleteQ();
break;
case '3' :
displayQ();
break;
case '4':
return;
}
getch();
} while(ch != '4');
}

Lecture Notes

120

Dept. of Information Technology

4.7.

Applications of Queue:

1.

It is used to schedule the jobs to be processed by the CPU.

2.

When multiple users send print jobs to a printer, each printing job is kept in
the printing queue. Then the printer prints those jobs according to first in
first out (FIFO) basis.

3.

Breadth first search uses a queue data structure to find an element from a
graph.

4.8.

Circular Queue:

A more efficient queue representation is obtained by regarding the array Q[MAX] as
circular. Any number of items could be placed on the queue. This implementation of a
queue is called a circular queue because it uses its storage array as if it were a circle
instead of a linear list.
There are two problems associated with linear queue. They are:
•

Time consuming: linear time to be spent in shifting the elements to the
beginning of the queue.

•

Signaling queue full: even if the queue is having vacant position.

For example, let us consider a linear queue status as follows:
0

1

2
33

3

4

44

55

F

RE A R = 5
F RO NT = 2

R

Next insert another element, say 66 to the queue. We cannot insert 66 to the queue as
the rear crossed the maximum size of the queue (i.e., 5). There will be queue full
signal. The queue status is as follows:
0

1

2
33

F

3

4

44

55

RE A R = 5
F RO NT = 2

R

This difficulty can be overcome if we treat queue position with index zero as a position
that comes after position with index four then we treat the queue as a circular queue.
In circular queue if we reach the end for inserting elements to it, it is possible to insert
new elements if the slots at the beginning of the circular queue are empty.

Lecture Notes

121

Dept. of Information Technology

4.8.1.

Representation of Circular Queue:

Let us consider a circular queue, which can hold maximum (MAX) of six elements.
Initially the queue is empty.
F

R
0

5

Queue
MAX =
F RO NT
C O U NT

1

4

E mp t y
6
= RE A R = 0
= 0

2

3

C irc u l ar Q u e u e

Now, insert 11 to the circular queue. Then circular queue status will be:
F
0

5

R

11

F RO NT = 0
RE A R = ( RE A R + 1) % 6 = 1
C O U NT = 1

1

4

2

3

C irc u l ar Q u e u e

Insert new elements 22, 33, 44 and 55 into the circular queue. The circular queue
status is:
F
R
0

5
11

4

22

55

44

1

FRONT = 0
REAR = (REAR + 1) % 6 = 5
COUNT = 5

33

3

2

Circular Queue

Lecture Notes

122

Dept. of Information Technology

Now, delete an element. The element deleted is the element at the front of the circular
queue. So, 11 is deleted. The circular queue status is as follows:
R
0

5

F

4

22

55

44

F RO NT = (F R O NT + 1) % 6 = 1
RE A R = 5
C O U NT = C O U NT - 1 = 4

1

33
2

3

C irc u l ar Q u e u e

Again, delete an element. The element to be deleted is always pointed to by the FRONT
pointer. So, 22 is deleted. The circular queue status is as follows:
R
0

5

4

F RO NT = (F R O NT + 1) % 6 = 2
RE A R = 5
C O U NT = C O U NT - 1 = 3

1

55

44

33
F

2

3

C irc u l ar Q u e u e

Again, insert another element 66 to the circular queue. The status of the circular queue
is:
R
0

5
66

4

1

55

44
3

F RO NT = 2
RE A R = ( RE A R + 1) % 6 = 0
C O U NT = C O U NT + 1 = 4

33
2

F

C irc u l ar Q u e u e

Lecture Notes

123

Dept. of Information Technology

Now, insert new elements 77 and 88 into the circular queue. The circular queue status
is:
0

5
66

4

77
88

55

44
3

1

F RO NT = 2, RE A R = 2
RE A R = RE A R % 6 = 2
C O U NT = 6

33
2

R
F

C irc u l ar Q u e u e

Now, if we insert an element to the circular queue, as COUNT = MAX we cannot add
the element to circular queue. So, the circular queue is full.
4.8.2.

Source code for Circular Queue operations, using array:

# include <stdio.h>
# include <conio.h>
# define MAX 6
int
int
int
int

CQ[MAX];
front = 0;
rear = 0;
count = 0;

void insertCQ()
{
int data;
if(count == MAX)
{
printf("\n Circular Queue is Full");
}
else
{
printf("\n Enter data: ");
scanf("%d", &data);
CQ[rear] = data;
rear = (rear + 1) % MAX;
count ++;
printf("\n Data Inserted in the Circular Queue ");
}
}
void deleteCQ()
{
if(count == 0)
{
printf("\n\nCircular Queue is Empty..");
}
else
{
printf("\n Deleted element from Circular Queue is %d ", CQ[front]);
front = (front + 1) % MAX;
count --;
}
}

Lecture Notes

124

Dept. of Information Technology

void displayCQ()
{
int i, j;
if(count == 0)
{
printf("\n\n\t Circular Queue is Empty ");
}
else
{
printf("\n Elements in Circular Queue are: ");
j = count;
for(i = front; j != 0; j--)
{
printf("%d\t", CQ[i]);
i = (i + 1) % MAX;
}
}
}
int menu()
{
int ch;
clrscr();
printf("\n \t Circular Queue Operations using ARRAY..");
printf("\n -----------**********-------------\n");
printf("\n 1. Insert ");
printf("\n 2. Delete ");
printf("\n 3. Display");
printf("\n 4. Quit ");
printf("\n Enter Your Choice: ");
scanf("%d", &ch);
return ch;
}
void main()
{
int ch;
do
{
ch = menu();
switch(ch)
{
case 1:
case 2:
case 3:
case 4:
default:

}

}
getch();
} while(1);

Lecture Notes

insertCQ();
break;
deleteCQ();
break;
displayCQ();
break;
return;
printf("\n Invalid Choice ");

125

Dept. of Information Technology

4.9.

Deque:

In the preceding section we saw that a queue in which we insert items at one end and
from which we remove items at the other end. In this section we examine an extension
of the queue, which provides a means to insert and remove items at both ends of the
queue. This data structure is a deque. The word deque is an acronym derived from
double-ended queue. Figure 4.5 shows the representation of a deque.
Deletion

36

16

56

62

Insertion

19

Insertion

Deletion
front

rear

Figure 4.5. Representation of a deque.

A deque provides four operations. Figure 4.6 shows the basic operations on a deque.
•

enqueue_front: insert an element at front.

•

dequeue_front: delete an element at front.

•

enqueue_rear: insert element at rear.

•

dequeue_rear: delete element at rear.

11 22

enqueue_front(33)

33 11

22

enqueue_rear(44)

33 11 22 44

dequeue_front(33)

55 11 22

enqueue_front(55)

11 22

dequeue_rear(44)

11 22 44

Figure 4.6. Basic operations on deque

There are two variations of deque. They are:
•

Input restricted deque (IRD)

•

Output restricted deque (ORD)

An Input restricted deque is a deque, which allows insertions at one end but allows
deletions at both ends of the list.
An output restricted deque is a deque, which allows deletions at one end but allows
insertions at both ends of the list.

Lecture Notes

126

Dept. of Information Technology

4.10. Priority Queue:
A priority queue is a collection of elements such that each element has been assigned a
priority and such that the order in which elements are deleted and processed comes
from the following rules:
1.

An element of higher priority is processed before any element of lower
priority.

2.

two elements with same priority are processed
which they were added to the queue.

according to the order in

A prototype of a priority queue is time sharing system: programs of high priority are
processed first, and programs with the same priority form a standard queue. An
efficient implementation for the Priority Queue is to use heap, which in turn can be
used for sorting purpose called heap sort.
Exercises
1.

What is a linear data structure? Give two examples of linear data structures.

2.

Is it possible to have two designs for the same data structure that provide the
same functionality but are implemented differently?

3.

What is the difference between the logical representation of a data structure and
the physical representation?

4.

Transform the following infix expressions to reverse polish notation:
a) A ↑ B * C – D + E / F / (G + H)
b) ((A + B) * C – (D – E)) ↑ (F + G)
c) A – B / (C * D ↑ E)
d) (a + b ↑ c ↑ d) * (e + f / d))
f) 3 – 6 * 7 + 2 / 4 * 5 – 8
g) (A – B) / ((D + E) * F)
h) ((A + B) / D) ↑ ((E – F) * G)

5.

Evaluate the following postfix expressions:
a) P1: 5, 3, +, 2, *, 6, 9, 7, -, /, b) P2: 3, 5, +, 6, 4, -, *, 4, 1, -, 2, ↑, +
c) P3 : 3, 1, +, 2, ↑, 7, 4, -, 2, *, +, 5, -

6.

Consider the usual algorithm to convert an infix expression to a postfix
expression. Suppose that you have read 10 input characters during a conversion
and that the stack now contains these symbols:

bottom

+
(
*

Now, suppose that you read and process the 11th symbol of the input. Draw the
stack for the case where the 11th symbol is:
A. A number:
B. A left parenthesis:
C. A right parenthesis:
D. A minus sign:
E. A division sign:

Lecture Notes

127

Dept. of Information Technology

7.

Write a program using stack for parenthesis matching. Explain what modifications
would be needed to make the parenthesis matching algorithm check expressions
with different kinds of parentheses such as (), [] and {}'s.

8.

Evaluate the following prefix expressions:
a) + * 2 + / 14 2 5 1
b) - * 6 3 – 4 1
c) + + 2 6 + - 13 2 4

9.

Convert the following infix expressions to prefix notation:
a) ((A + 2) * (B + 4)) -1
b) Z – ((((X + 1) * 2) – 5) / Y)
c) ((C * 2) + 1) / (A + B)
d) ((A + B) * C – (D - E)) ↑ (F + G)
e) A – B / (C * D ↑ E)

10.

Write a “C” function to copy one stack to another assuming
a) The stack is implemented using array.
b) The stack is implemented using linked list.

11.

Write an algorithm to construct a fully parenthesized infix expression from its
postfix equivalent. Write a “C” function for your algorithm.

12.

How can one convert a postfix expression to its prefix equivalent and vice-versa?

13.

A double-ended queue (deque) is a linear list where additions and deletions can
be performed at either end. Represent a deque using an array to store the
elements of the list and write the “C” functions for additions and deletions.

14.

In a circular queue represented by an array, how can one specify the number of
elements in the queue in terms of “front”, “rear” and MAX-QUEUE-SIZE? Write a
“C” function to delete the K-th element from the “front” of a circular queue.

15.

Can a queue be represented by a circular linked list with only one pointer pointing
to the tail of the queue? Write “C” functions for the “add” and “delete” operations
on such a queue

16.

Write a “C” function to test whether a string of opening and closing parenthesis is
well formed or not.

17.

Represent N queues in a single one-dimensional array. Write functions for “add”
and “delete” operations on the ith queue

18.

Represent a stack and queue in a single one-dimensional array. Write functions
for “push”, “pop” operations on the stack and “add”, “delete” functions on the
queue.

Lecture Notes

128

Dept. of Information Technology

Multiple Choice Questions
1.

Which among the following is a linear data structure:
A. Queue
B. Stack
C. Linked List
D. all the above

[

D ]

2.

Which among the following is a Dynamic data structure:
A. Double Linked List
C. Stack
B. Queue
D. all the above
Stack is referred as:
A. Last in first out list
C. both A and B
B. First in first out list
D. none of the above

[

A ]

[

A ]

4.

A stack is a data structure in which all insertions and deletions of entries
are made at:
A. One end
C. Both the ends
B. In the middle
D. At any position

[

A ]

5.

A queue is a data structure in which all insertions and deletions are made
respectively at:
A. rear and front
C. front and rear
B. front and front
D. rear and rear

[

A ]

6.

Transform the following infix expression to postfix form:
(A + B) * (C – D) / E
A. A B * C + D / C. A B + C D * - / E
B. A B C * C D / - +
D. A B + C D - * E /

[

D ]

7.

Transform the following infix expression to postfix form:
A - B / (C * D)
A. A B * C D - /
C. / - D C * B A
B. A B C D * / D. - / * A B C D

[

B ]

8.

Evaluate the following prefix expression: * - + 4 3 5 / + 2 4 3

[

A ]

3.

A. 4
B. 8

C. 1
D. none of the above

9.

Evaluate the following postfix expression: 1 4 18 6 / 3 + + 5 / +
A. 8
C. 3
B. 2
D. none of the above

[

C ]

10.

Transform the following infix expression to prefix form:
((C * 2) + 1) / (A + B)
A. A B + 1 2 C * + /
C. / * + 1 2 C A B +
B. / + * C 2 1 + A B
D. none of the above

[

B ]

11.

Transform the following infix expression to prefix form:
Z – ((((X + 1) * 2) – 5) / Y)
A. / - * + X 1 2 5 Y
C. / * - + X 1 2 5 Y
B. Y 5 2 1 X + * - /
D. none of the above

[

D ]

12.

Queue is also known as:
A. Last in first out list
B. First in first out list

[

B ]

Lecture Notes

C. both A and B
D. none of the above

129

Dept. of Information Technology

13.

One difference between a queue and a stack is:
A. Queues require dynamic memory, but stacks do not.
B. Stacks require dynamic memory, but queues do not.
C. Queues use two ends of the structure; stacks use only one.
D. Stacks use two ends of the structure, queues use only one.

[

C ]

14.

If the characters 'D', 'C', 'B', 'A' are placed in a queue (in that order), and
then removed one at a time, in what order will they be removed?
A. ABCD
C. DCAB
B. ABDC
D. DCBA

[

D ]

15.

Suppose we have a circular array implementation of the queue class,
with ten items in the queue stored at data[2] through data[11]. The
CAPACITY is 42. Where does the push member function place the new
entry in the array?
A. data[1]
C. data[11]
B. data[2]
D. data[12]

[

D ]

16.

Consider the implementation of the queue using a circular array. What
goes wrong if we try to keep all the items at the front of a partially-filled
array (so that data[0] is always the front).
A. The constructor would require linear time.
B. The get_front function would require linear time.
C. The insert function would require linear time.
D. The is_empty function would require linear time.

[

B ]

17.

In the linked list implementation of the queue class, where does the push
member function place the new entry on the linked list?
A. At the head
B. At the tail
C. After all other entries that are greater than the new entry.
D. After all other entries that are smaller than the new entry.

[

A ]

18.

In the circular array version of the queue class (with a fixed-sized array),
which operations require linear time for their worst-case behavior?
A. front
C. empty
B. push
D. None of these.

[

]

19.

In the linked-list version of the queue class, which operations require
linear time for their worst-case behavior?
A. front
C. empty
B. push
D. None of these operations.

[

]

20.

To implement the queue with a linked list, keeping track of a front
pointer and a rear pointer. Which of these pointers will change during an
insertion into a NONEMPTY queue?
A. Neither changes
C. Only rear_ptr changes.
B. Only front_ptr changes.
D. Both change.

[

B ]

21.

To implement the queue with a linked list, keeping track of a front
pointer and a rear pointer. Which of these pointers will change during an
insertion into an EMPTY queue?
A. Neither changes
C. Only rear_ptr changes.
B. Only front_ptr changes.
D. Both change.

[

D ]

Lecture Notes

130

Dept. of Information Technology

22.

Suppose top is called on a priority queue that has exactly two entries
with equal priority. How is the return value of top selected?
A. The implementation gets to choose either one.
B. The one which was inserted first.
C. The one which was inserted most recently.
D. This can never happen (violates the precondition)

[

B ]

23.

Entries in a stack are "ordered". What is the meaning of this statement?
A. A collection of stacks can be sorted.
B. Stack entries may be compared with the '<' operation.
C. The entries must be stored in a linked list.
D. There is a first entry, a second entry, and so on.

[

D ]

24.

The operation for adding an entry to a stack is traditionally called:
A. add
C. insert
B. append
D. push

[

D ]

25.

The operation for removing an entry from a stack is traditionally called:
A. delete
C. pop
B. peek
D. remove
Which of the following stack operations could result in stack underflow?
A. is_empty
C. push
B. pop
D. Two or more of the above answers

[

C ]

[

A ]

26.

27.

Which of the following applications may use a stack?
A. A parentheses balancing program.
B. Keeping track of local variables at run time.
C. Syntax analyzer for a compiler.
D. All of the above.

[

D ]

28.

Here is an infix expression: 4 + 3 * (6 * 3 - 12). Suppose that we are
using the usual stack algorithm to convert the expression from infix to
postfix notation. What is the maximum number of symbols that will
appear on the stack AT ONE TIME during the conversion of this
expression?
A. 1
C. 3
B. 2
D. 4

[

D ]

29.

What is the value of the postfix expression 6 3 2 4 + - *
A. Something between -15 and -100
B. Something between -5 and -15
C. Something between 5 and -5
D. Something between 5 and 15
E. Something between 15 and 100

[

A ]

30.

If the expression ((2 + 3) * 4 + 5 * (6 + 7) * 8) + 9 is evaluated with *
having precedence over +, then the value obtained is same as the value
of which of the following prefix expressions?
A. + + * + 2 3 4 * * 5 + 6 7 8 9
C. * + + + 2 3 4 * * 5 + 6 7 8 9
B. + * + + 2 3 4 * * 5 + 6 7 8 9
D. + * + + 2 3 4 + + 5 * 6 7 8 9

[

A ]

31.

Evaluate the following prefix expression:
+ * 2 + / 14 2 5 1
A. 50
C. 40
B. 25
D. 15

[

B ]

Lecture Notes

131

Dept. of Information Technology

32

Parenthesis are never needed prefix or postfix expression:
A. True
C. Cannot be expected
B. False
D. None of the above

[ A

]

33

A postfix expression is merely the reverse of the prefix expression:
A. True
C. Cannot be expected
B. False
D. None of the above

[ B

]

34

Which among the following data structure may give overflow error, even
though the current number of elements in it, is less than its size:
A. Simple Queue
C. Stack
B. Circular Queue
D. None of the above

[

A ]

35.

Which among the following types of expressions does not require
precedence rules for evaluation:
A. Fully parenthesized infix expression
B. Prefix expression
C. both A and B
D. none of the above

[

C ]

36.

Conversion of infix arithmetic expression to postfix expression uses:
A. Stack
C. linked list
B. circular queue
D. Queue

[ D

Lecture Notes

132

]

Dept. of Information Technology

Chapter

5

Binary Trees
A data structure is said to be linear if its elements form a sequence or a
linear list. Previous linear data structures that we have studied like an
array, stacks, queues and linked lists organize data in linear order. A data
structure is said to be non linear if its elements form a hierarchical
classification where, data items appear at various levels.
Trees and Graphs are widely used non-linear data structures. Tree and
graph structures represents hierarchial relationship between individual
data elements. Graphs are nothing but trees with certain restrictions
removed.
In this chapter in particular, we will explain special type of trees known as
binary trees, which are easy to maintain in the computer.
5.1.

TREES:

A tree is hierarchical collection of nodes. One of the nodes, known as the root, is at the
top of the hierarchy. Each node can have at most one link coming into it. The node
where the link originates is called the parent node. The root node has no parent. The
links leaving a node (any number of links are allowed) point to child nodes. Trees are
recursive structures. Each child node is itself the root of a subtree. At the bottom of
the tree are leaf nodes, which have no children.
Trees represent a special case of more general structures known as graphs. In a graph,
there is no restrictions on the number of links that can enter or leave a node, and
cycles may be present in the graph. The figure 5.1.1 shows a tree and a non-tree.
a

a
b
d

c
e

b
f

c
d

A Tree

e

Not a Tree
Figure 5.1.1 A Tree and a not a tree

In a tree data structure, there is no distinction between the various children of a node
i.e., none is the "first child" or "last child". A tree in which such distinctions are made is
called an ordered tree, and data structures built on them are called ordered tree
data structures. Ordered trees are by far the commonest form of tree data structure.

Lecture Notes

133

Dept. of Information Technology

5.2.

BINARY TREE:

In general, tree nodes can have any number of children. In a binary tree, each node
can have at most two children. A binary tree is either empty or consists of a node
called the root together with two binary trees called the left subtree and the right
subtree.
A tree with no nodes is called as a null tree. A binary tree is shown in figure 5.2.1.

A
left child

B

H

F

E

D

left subtree

C

right child
right subtree

G

I

Figure 5.2.1. Binary Tree

Binary trees are easy to implement because they have a small, fixed number of child
links. Because of this characteristic, binary trees are the most common types of trees
and form the basis of many important data structures.
Tree Terminology:
Leaf node
A node with no children is called a leaf (or external node). A node which is not
a leaf is called an internal node.
Path
A sequence of nodes n1, n2, . . ., nk, such that ni is the parent of ni + 1 for i = 1,
2,. . ., k - 1. The length of a path is 1 less than the number of nodes on the
path. Thus there is a path of length zero from a node to itself.
For the tree shown in figure 5.2.1, the path between A and I is A, B, D, I.
Siblings
The children of the same parent are called siblings.
For the tree shown in figure 5.2.1, F and G are the siblings of the parent node C
and H and I are the siblings of the parent node D.
Ancestor and Descendent
If there is a path from node A to node B, then A is called an ancestor of B and
B is called a descendent of A.
Subtree
Any node of a tree, with all of its descendants is a subtree.

Lecture Notes

134

Dept. of Information Technology

Level
The level of the node refers to its distance from the root. The root of the tree
has level O, and the level of any other node in the tree is one more than the
level of its parent. For example, in the binary tree of Figure 5.2.1 node F is at
level 2 and node H is at level 3. The maximum number of nodes at any level is
2n.
Height
The maximum level in a tree determines its height. The height of a node in a
tree is the length of a longest path from the node to a leaf. The term depth is
also used to denote height of the tree. The height of the tree of Figure 5.2.1 is
3.
Depth

The depth of a node is the number of nodes along the path from the root to that
node. For instance, node ‘C’ in figure 5.2.1 has a depth of 1.

Assigning level numbers and Numbering of nodes for a binary tree:
The nodes of a binary tree can be numbered in a natural way, level by level, left
to right. The nodes of a complete binary tree can be numbered so that the root
is assigned the number 1, a left child is assigned twice the number assigned its
parent, and a right child is assigned one more than twice the number assigned
its parent. For example, see Figure 5.2.2.
Level 0

1

4

8

Level 1

3

2
5

6

Level 2

7

Level 3

9

Figure 5.2.2. Level by level numbering of binary tree

Properties of binary trees:
Some of the important properties of a binary tree are as follows:
1. If h = height of a binary tree, then
a. Maximum number of leaves = 2h
b. Maximum number of nodes = 2h + 1 - 1
2. If a binary tree contains m nodes at level l, it contains at most 2m nodes at
level l + 1.
3. Since a binary tree can contain at most one node at level 0 (the root), it can
contain at most 2l node at level l.
4. The total number of edges in a full binary tree with n node is n - 1.

Lecture Notes

135

Dept. of Information Technology

Strictly Binary tree:
If every non-leaf node in a binary tree has nonempty left and right subtrees, the
tree is termed as strictly binary tree. Thus the tree of figure 5.2.3(a) is strictly
binary. A strictly binary tree with n leaves always contains 2n - 1 nodes.
Full Binary tree:
A full binary tree of height h has all its leaves at level h. Alternatively; All non
leaf nodes of a full binary tree have two children, and the leaf nodes have no
children.
A full binary tree with height h has 2h + 1 - 1 nodes. A full binary tree of height h
is a strictly binary tree all of whose leaves are at level h. Figure 5.2.3(d)
illustrates the full binary tree containing 15 nodes and of height 3.
A full binary tree of height h contains 2h leaves and, 2h - 1 non-leaf nodes.
h

Thus by induction, total number of nodes ( tn) = ∑ 2 l = 2 h + 1 − 1 .
l =0

For example, a full binary tree of height 3 contains 23+1 – 1 = 15 nodes.

1

1

Strict Binary Tree
(a)

2
6
12

7

4

13

8

9

7

Strictly Complete
binary tree

(b)

1

2

2

3
5

6

5
9

8

1

4

3

2

3

6

4

7
8

10

Complete binary tree

3
5

9

10

6
11

12

7
13

Full binary tree

(c)

14

15

(d)

Figure 5.2.3. Examples of binary trees

Complete Binary tree:
A binary tree with n nodes is said to be complete if it contains all the first n
nodes of the above numbering scheme. Figure 5.2.4 shows examples of
complete and incomplete binary trees.
A complete binary tree of height h looks like a full binary tree down to level h-1,
and the level h is filled from left to right.

Lecture Notes

136

Dept. of Information Technology

A complete binary tree with n leaves that is not strictly binary has 2n nodes. For
example, the tree of Figure 5.2.3(c) is a complete binary tree having 5 leaves
and 10 nodes.

1

1
3

2
4

5

1

2

6

3

4

Complete Binary Tree
but not strict
(a)

5

2
7

4

Not C omplete and not
strict
(b)

Not C omplete and not
strict
(c)

Figure 5.2.4. Examples of complete and incomplete binary trees

Internal and external nodes:
We define two terms: Internal nodes and external nodes. An internal node is a tree
node having at least one–key and possibly some children. It is some times convenient
to have another types of nodes, called an external node, and pretend that all null child
links point to such a node. An external node doesn’t exist, but serves as a conceptual
place holder for nodes to be inserted.
We draw internal nodes using circles, with letters as labels. External nodes are denoted
by squares. The square node version is sometimes called an extended binary tree. A
binary tree with n internal nodes has n+1 external nodes. Figure 5.2.6 shows a sample
tree illustrating both internal and external nodes.

c
a

d
b

1
2

4

Internal Nodes: a, b, c, d
External Nodes: 1, 2, 3, 4, 5
5

3

Figure 5.2.6. Internal and external nodes

Data Structures for Binary Trees:
1.

Arrays; especially suited for complete and full binary trees.

2.

Pointer-based.

Array-based Implementation:
Binary trees can also be stored in arrays, and if the tree is a complete binary tree, this
method wastes no space. In this compact arrangement, if a node has an index i, its
children are found at indices 2i+1 and 2i+2, while its parent (if any) is found at index
floor((i-1)/2) (assuming the root of the tree stored in the array at an index zero).

Lecture Notes

137

Dept. of Information Technology

This method benefits from more compact storage and better locality of reference,
particularly during a preorder traversal. However, it requires contiguous memory,
expensive to grow and wastes space proportional to 2h - n for a tree of height h with n
nodes.

0

1

2

3

4

5

6

Linked Representation (Pointer based):
Array representation is good for complete binary tree, but it is wasteful for many other
binary trees. The representation suffers from insertion and deletion of node from the
middle of the tree, as it requires the moment of potentially many nodes to reflect the
change in level number of this node. To overcome this difficulty we represent the
binary tree in linked representation.
In linked representation each node in a binary has three fields, the left child field
denoted as LeftChild, data field denoted as data and the right child field denoted as
RightChild. If any sub-tree is empty then the corresponding pointer’s LeftChild and
RightChild will store a NULL value. If the tree itself is empty the root pointer will store a
NULL value.
The advantage of using linked representation of binary tree is that:
•

Insertion and deletion involve no data movement and no movement of nodes
except the rearrangement of pointers.

The disadvantages of linked representation of binary tree includes:
•

Given a node structure, it is difficult to determine its parent node.

•

Memory spaces are wasted for storing NULL pointers for the nodes, which
have no subtrees.

The structure definition, node representation empty binary tree is shown in figure 5.2.6
and the linked representation of binary tree using this node structure is given in figure
5.2.7.
struct binarytree
{
struct binarytree *LeftChild;
int data;
struct binarytree *RightChild;
};

node:
LeftC hild

Empty Tree:

typedef struct binarytree node;

data RightChild

root
NULL

node *root = NULL;
Figure 5.2.6. Structure definition, node representation and empty tree

Lecture Notes

138

Dept. of Information Technology

A

root

B
D

C
E

F

A
G
B

H

C

I
D

X

H

X

X

I

X

E

X

X

F

X

X

G

X

X

Figure 5.2.7. Linked representation for the binary tree

5.3.

Binary Tree Traversal Techniques:

A tree traversal is a method of visiting every node in the tree. By visit, we mean that
some type of operation is performed. For example, you may wish to print the contents
of the nodes.
There are four common ways to traverse a binary tree:
1.

Preorder

2.

Inorder

3.

Postorder

4.

Level order

In the first three traversal methods, the left subtree of a node is traversed before the
right subtree. The difference among them comes from the difference in the time at
which a root node is visited.
5.3.1. Recursive Traversal Algorithms:
Inorder Traversal:
In the case of inorder traversal, the root of each subtree is visited after its left subtree
has been traversed but before the traversal of its right subtree begins. The steps for
traversing a binary tree in inorder traversal are:
1. Visit the left subtree, using inorder.
2. Visit the root.
3. Visit the right subtree, using inorder.
The algorithm for inorder traversal is as follows:
void inorder(node *root)
{
if(root != NULL)
{
inorder(root->lchild);

Lecture Notes

139

Dept. of Information Technology

}

print root -> data;
inorder(root->rchild);

}
Preorder Traversal:
In a preorder traversal, each root node is visited before its left and right subtrees are
traversed. Preorder search is also called backtracking. The steps for traversing a binary
tree in preorder traversal are:
1. Visit the root.
2. Visit the left subtree, using preorder.
3. Visit the right subtree, using preorder.
The algorithm for preorder traversal is as follows:
void preorder(node *root)
{
if( root != NULL )
{
print root -> data;
preorder (root -> lchild);
preorder (root -> rchild);
}
}
Postorder Traversal:
In a postorder traversal, each root is visited after its left and right subtrees have been
traversed. The steps for traversing a binary tree in postorder traversal are:
1. Visit the left subtree, using postorder.
2. Visit the right subtree, using postorder
3. Visit the root.
The algorithm for postorder traversal is as follows:
void postorder(node *root)
{
if( root != NULL )
{
postorder (root -> lchild);
postorder (root -> rchild);
print (root -> data);
}
}
Level order Traversal:
In a level order traversal, the nodes are visited level by level starting from the root,
and going from left to right. The level order traversal requires a queue data structure.
So, it is not possible to develop a recursive procedure to traverse the binary tree in
level order. This is nothing but a breadth first search technique.

Lecture Notes

140

Dept. of Information Technology

The algorithm for level order traversal is as follows:
void levelorder()
{
int j;
for(j = 0; j < ctr; j++)
{
if(tree[j] != NULL)
print tree[j] -> data;
}
}
Example 1:
Traverse the following binary tree in pre, post, inorder and level order.

A
B

C
E

D

•

P r eo r d e r t r a v e rs a l y ie lds:
A , B , D, C , E , G , F , H , I

•

Po sto r d e r t r a v e rs a l y ie lds:
D, B , G , E , H , I, F , C , A

•

Ino r d e r t r a v e rs a l y ie lds:
D, B , A , E , G , C , H , F , I

•

L e v e l o r d e r t r a v e rs a l y ie lds:
A , B , C , D, E , F , G , H , I

F
H

G

I

Bi n a ry T r e e

Pr e, P o st , I n or d er a n d l ev e l or d er T r av er s i n g

Example 2:
Traverse the following binary tree in pre, post, inorder and level order.

P
F
B

S
H

R

G

Lecture Notes

P r eo r d e r t r a v e rs a l y ie lds:
P, F , B, H, G , S, R, Y, T, W , Z

•

Po sto r d e r t r a v e rs a l y ie lds:
B, G , H, F , R, W , T, Z, Y, S, P

•

Ino r d e r t r a v e rs a l y ie lds:
B, F , G , H, P, R, S, T, W , Y, Z

•

L e v e l o r d e r t r a v e rs a l y ie lds:
P, F , S, B, H, R, Y, G , T, Z, W

Y
T

Z
W

Bi n a ry T r e e

•

Pr e, P o st , I n or d er a n d l ev e l or d er T r av er s i n g

141

Dept. of Information Technology

Example 3:
Traverse the following binary tree in pre, post, inorder and level order.

2
7
2

5
6

P r eo r d e r t r a v e rs a l y ie lds:
2, 7 , 2 , 6 , 5 , 11 , 5 , 9 , 4

•

Po sto r d e r t r a v a rs a l y ie lds:
2, 5 , 11 , 6 , 7 , 4 , 9 , 5 , 2

•

Ino r d e r t r a v a rs a l y ie lds:
2, 7 , 5 , 6 , 11 , 2 , 5 , 4 , 9

•

L e v e l o r d e r t r a v e rs a l y ie lds:
2, 7 , 5 , 2 , 6 , 9 , 5 , 11 , 4

9
11

5

•

4

Bi n a ry T r e e

Pr e, P o st , I n or d er a n d l ev e l or d er T r av er s i n g

Example 4:
Traverse the following binary tree in pre, post, inorder and level order.

A
B

C

H

K

L

M
Bi n a ry T r e e

5.3.2.

P r eo r d e r t r a v e rs a l y ie lds:
A , B , D, G , K , H , L , M , C , E

•

Po sto r d e r t r a v a rs a l y ie lds:
K , G , L , M , H , D, B , E , C , A

•

Ino r d e r t r a v a rs a l y ie lds:
K , G , D, L , H , M , B , A , E , C

•

L e v e l o r d e r t r a v e rs a l y ie lds:
A , B , C , D, E , G , H , K , L , M

E

D
G

•

Pr e, P o st , I n or d er a n d l ev e l or d er T r av er s i n g

Building Binary Tree from Traversal Pairs:

Sometimes it is required to construct a binary tree if its traversals are known. From a
single traversal it is not possible to construct unique binary tree. However any of the
two traversals are given then the corresponding tree can be drawn uniquely:
•
•
•

Inorder and preorder
Inorder and postorder
Inorder and level order

The basic principle for formulation is as follows:
If the preorder traversal is given, then the first node is the root node. If the postorder
traversal is given then the last node is the root node. Once the root node is identified,
all the nodes in the left sub-trees and right sub-trees of the root node can be identified
using inorder.
Same technique can be applied repeatedly to form sub-trees.

Lecture Notes

142

Dept. of Information Technology

It can be noted that, for the purpose mentioned, two traversal are essential out of
which one should be inorder traversal and another preorder or postorder; alternatively,
given preorder and postorder traversals, binary tree cannot be obtained uniquely.
Example 1:
Construct a binary tree from a given preorder and inorder sequence:
Preorder: A B D G C E H I F
Inorder: D G B A H E I C F
Solution:
From Preorder sequence A B D G C E H I F, the root is: A
From Inorder sequence D G B A H E I C F, we get the left and right sub trees:
Left sub tree is: D G B
Right sub tree is: H E I C F
The Binary tree upto this point looks like:
A

D G B

H E I C F

To find the root, left and right sub trees for D G B:
From the preorder sequence B D G, the root of tree is: B
From the inorder sequence D G B, we can find that D and G are to the left of B.
The Binary tree upto this point looks like:
A

B

H E I C F

D G

To find the root, left and right sub trees for D G:
From the preorder sequence D G, the root of the tree is: D
From the inorder sequence D G, we can find that there is no left node to D and G is at
the right of D.

Lecture Notes

143

Dept. of Information Technology

The Binary tree upto this point looks like:
A

B

H E I C F

D

G

To find the root, left and right sub trees for H E I C F:
From the preorder sequence C E H I F, the root of the left sub tree is: C
From the inorder sequence H E I C F, we can find that H E I are at the left of C and F is
at the right of C.
The Binary tree upto this point looks like:
A

B

C

D

F

H E I
G

To find the root, left and right sub trees for H E I:
From the preorder sequence E H I, the root of the tree is: E
From the inorder sequence H E I, we can find that H is at the left of E and I is at the
right of E.
The Binary tree upto this point looks like:
A

B

C
E

D

G

H

F

I

Example 2:
Construct a binary tree from a given postorder and inorder sequence:
Inorder: D G B A H E I C F
Postorder: G D B H I E F C A

Lecture Notes

144

Dept. of Information Technology

Solution:
From Postorder sequence G D B H I E F C A, the root is: A
From Inorder sequence D G B A H E I C F, we get the left and right sub trees:
Left sub tree is: D G B
Right sub tree is: H E I C F
The Binary tree upto this point looks like:
A

D G B

H E I C F

To find the root, left and right sub trees for D G B:
From the postorder sequence G D B, the root of tree is: B
From the inorder sequence D G B, we can find that D G are to the left of B and there is
no right subtree for B.
The Binary tree upto this point looks like:
A

B

H E I C F

D G

To find the root, left and right sub trees for D G:
From the postorder sequence G D, the root of the tree is: D
From the inorder sequence D G, we can find that is no left subtree for D and G is to the
right of D.
The Binary tree upto this point looks like:
A

B

H E I C F

D
G

To find the root, left and right sub trees for H E I C F:
From the postorder sequence H I E F C, the root of the left sub tree is: C
From the inorder sequence H E I C F, we can find that H E I are to the left of C and F is
the right subtree for C.

Lecture Notes

145

Dept. of Information Technology

The Binary tree upto this point looks like:
A

C

B

D

F

H E I
G

To find the root, left and right sub trees for H E I:
From the postorder sequence H I E, the root of the tree is: E
From the inorder sequence H E I, we can find that H is left subtree for E and I is to the
right of E.
The Binary tree upto this point looks like:
A

B

C

D

F

E

G

H

I

Example 3:
Construct a binary tree from a given preorder and inorder sequence:
Inorder: n1 n2 n3 n4 n5 n6 n7 n8 n9
Preorder: n6 n2 n1 n4 n3 n5 n9 n7 n8
Solution:
From Preorder sequence n6 n2 n1 n4 n3 n5 n9 n7 n8, the root is: n6
From Inorder sequence n1 n2 n3 n4 n5 n6 n7 n8 n9, we get the left and right sub
trees:
Left sub tree is: n1 n2 n3 n4 n5
Right sub tree is: n7 n8 n9
The Binary tree upto this point looks like:
n6

n1 n2 n3 n4 n5

Lecture Notes

n7 n8 n9

146

Dept. of Information Technology

To find the root, left and right sub trees for n1 n2 n3 n4 n5:
From the preorder sequence n2 n1 n4 n3 n5, the root of tree is: n2
From the inorder sequence n1 n2 n3 n4 n5, we can find that n1 is to the left of n2 and
n3 n4 n5 are to the right of n2. The Binary tree upto this point looks like:
n6

n2

n1

n7 n8 n9

n3 n4 n5

To find the root, left and right sub trees for n3 n4 n5:
From the preorder sequence n4 n3 n5, the root of the tree is: n4
From the inorder sequence n3 n4 n5, we can find that n3 is to the left of n4 and n5 is
at the right of n4.
The Binary tree upto this point looks like:
n6

n2

n1

n7 n8 n9

n4

n3

n5

To find the root, left and right sub trees for n7 n8 n9:
From the preorder sequence n9 n7 n8, the root of the left sub tree is: n9
From the inorder sequence n7 n8 n9, we can find that n7 and n8 are at the left of n9
and no right subtree of n9.
The Binary tree upto this point looks like:
n6
n9

n2

n4

n1

n3

n7 n8

n5

To find the root, left and right sub trees for n7 n8:
From the preorder sequence n7 n8, the root of the tree is: n7

Lecture Notes

147

Dept. of Information Technology

From the inorder sequence n7 n8, we can find that is no left subtree for n7 and n8 is at
the right of n7.
The Binary tree upto this point looks like:
n6
n9

n2

n4

n1

n3

n7

n5

n8

Example 4:
Construct a binary tree from a given postorder and inorder sequence:
Inorder: n1 n2 n3 n4 n5 n6 n7 n8 n9
Postorder: n1 n3 n5 n4 n2 n8 n7 n9 n6
Solution:
From Postorder sequence n1 n3 n5 n4 n2 n8 n7 n9 n6, the root is: n6
From Inorder sequence n1 n2 n3 n4 n5 n6 n7 n8 n9, we get the left and right sub
trees:
Left sub tree is: n1 n2 n3 n4 n5
Right sub tree is: n7 n8 n9
The Binary tree upto this point looks like:
n6
n1 n2 n3 n4 n5

n7 n8 n9

To find the root, left and right sub trees for n1 n2 n3 n4 n5:
From the postorder sequence n1 n3 n5 n4 n2, the root of tree is: n2
From the inorder sequence n1 n2 n3 n4 n5, we can find that n1 is to the left of n2 and
n3 n4 n5 are to the right of n2.
The Binary tree upto this point looks like:
n6
n2

n1

Lecture Notes

n7 n8 n9

n3 n4 n5

148

Dept. of Information Technology

To find the root, left and right sub trees for n3 n4 n5:
From the postorder sequence n3 n5 n4, the root of the tree is: n4
From the inorder sequence n3 n4 n5, we can find that n3 is to the left of n4 and n5 is
to the right of n4. The Binary tree upto this point looks like:
n6
n2

n1

n7 n8 n9

n4
n3

n5

To find the root, left and right sub trees for n7 n8 and n9:
From the postorder sequence n8 n7 n9, the root of the left sub tree is: n9
From the inorder sequence n7 n8 n9, we can find that n7 and n8 are to the left of n9
and no right subtree for n9.
The Binary tree upto this point looks like:
n6
n2

n1

n9
n7 n8

n4
n3

n5

To find the root, left and right sub trees for n7 and n8:
From the postorder sequence n8 n7, the root of the tree is: n7
From the inorder sequence n7 n8, we can find that there is no left subtree for n7 and
n8 is to the right of n7. The Binary tree upto this point looks like:
n6
n2

n1

n7

n4
n3

Lecture Notes

n9

n5

n8

149

Dept. of Information Technology

5.3.3.

Binary Tree Creation and Traversal Using Arrays:

This program performs the following operations:
1.
2.
3.
4.
5.
6.
7.

Creates a complete Binary Tree
Inorder traversal
Preorder traversal
Postorder traversal
Level order traversal
Prints leaf nodes
Finds height of the tree created

# include <stdio.h>
# include <stdlib.h>
struct tree
{
struct tree* lchild;
char data[10];
struct tree* rchild;
};
typedef struct tree node;
int ctr;
node *tree[100];
node* getnode()
{
node *temp ;
temp = (node*) malloc(sizeof(node));
printf("\n Enter Data: ");
scanf("%s",temp->data);
temp->lchild = NULL;
temp->rchild = NULL;
return temp;
}
void create_fbinarytree()
{
int j, i=0;
printf("\n How many nodes you want: ");
scanf("%d",&ctr);
tree[0] = getnode();
j = ctr;
j--;
do
{
if( j > 0 )
{
tree[ i * 2 + 1 ] = getnode();
tree[i]->lchild = tree[i * 2 + 1];
j--;
}
if( j > 0 )
{
tree[i * 2 + 2] = getnode();
j--;
tree[i]->rchild = tree[i * 2 + 2];
}
i++;
} while( j > 0);
}

Lecture Notes

150

/* left child */

/* right child */

Dept. of Information Technology

void inorder(node *root)
{
if( root != NULL )
{
inorder(root->lchild);
printf("%3s",root->data);
inorder(root->rchild);
}
}
void preorder(node *root)
{
if( root != NULL )
{
printf("%3s",root->data);
preorder(root->lchild);
preorder(root->rchild);
}
}
void postorder(node *root)
{
if( root != NULL )
{
postorder(root->lchild);
postorder(root->rchild);
printf("%3s",root->data);
}
}

void levelorder()
{
int j;
for(j = 0; j < ctr; j++)
{
if(tree[j] != NULL)
printf("%3s",tree[j]->data);
}
}

void print_leaf(node *root)
{
if(root != NULL)
{
if(root->lchild == NULL && root->rchild == NULL)
printf("%3s ",root->data);
print_leaf(root->lchild);
print_leaf(root->rchild);
}
}
int height(node *root)
{
if(root == NULL)
{
return 0;
}

Lecture Notes

151

Dept. of Information Technology

if(root->lchild == NULL && root->rchild == NULL)
return 0;
else
return (1 + max(height(root->lchild), height(root->rchild)));

}

void main()
{
int i;
create_fbinarytree();
printf("\n Inorder Traversal: ");
inorder(tree[0]);
printf("\n Preorder Traversal: ");
preorder(tree[0]);
printf("\n Postorder Traversal: ");
postorder(tree[0]);
printf("\n Level Order Traversal: ");
levelorder();
printf("\n Leaf Nodes: ");
print_leaf(tree[0]);
printf("\n Height of Tree: %d ", height(tree[0]));
}

5.3.4.

Binary Tree Creation and Traversal Using Pointers:

This program performs the following operations:
1.
2.
3.
4.
5.
6.
7.
8.
9.

Creates a complete Binary Tree
Inorder traversal
Preorder traversal
Postorder traversal
Level order traversal
Prints leaf nodes
Finds height of the tree created
Deletes last node
Finds height of the tree created

# include <stdio.h>
# include <stdlib.h>
struct tree
{
struct tree* lchild;
char data[10];
struct tree* rchild;
};
typedef struct tree node;
node *Q[50];
int node_ctr;
node* getnode()
{
node *temp ;
temp = (node*) malloc(sizeof(node));
printf("\n Enter Data: ");
fflush(stdin);
scanf("%s",temp->data);
temp->lchild = NULL;
temp->rchild = NULL;
return temp;
}

Lecture Notes

152

Dept. of Information Technology

void create_binarytree(node *root)
{
char option;
node_ctr = 1;
if( root != NULL )
{
printf("\n Node %s has Left SubTree(Y/N)",root->data);
fflush(stdin);
scanf("%c",&option);
if( option=='Y' || option == 'y')
{
root->lchild = getnode();
node_ctr++;
create_binarytree(root->lchild);
}
else
{
root->lchild = NULL;
create_binarytree(root->lchild);
}

}

printf("\n Node %s has Right SubTree(Y/N) ",root->data);
fflush(stdin);
scanf("%c",&option);
if( option=='Y' || option == 'y')
{
root->rchild = getnode();
node_ctr++;
create_binarytree(root->rchild);
}
else
{
root->rchild = NULL;
create_binarytree(root->rchild);
}

}
void make_Queue(node *root,int parent)
{
if(root != NULL)
{
node_ctr++;
Q[parent] = root;
make_Queue(root->lchild,parent*2+1);
make_Queue(root->rchild,parent*2+2);
}
}
delete_node(node *root, int parent)
{
int index = 0;
if(root == NULL)
printf("\n Empty TREE ");
else
{
node_ctr = 0;
make_Queue(root,0);
index = node_ctr-1;
Q[index] = NULL;
parent = (index-1) /2;
if( 2* parent + 1 == index )
Q[parent]->lchild = NULL;

Lecture Notes

153

Dept. of Information Technology

else

}

Q[parent]->rchild = NULL;
}
printf("\n Node Deleted ..");

void inorder(node *root)
{
if(root != NULL)
{
inorder(root->lchild);
printf("%3s",root->data);
inorder(root->rchild);
}
}
void preorder(node *root)
{
if( root != NULL )
{
printf("%3s",root->data);
preorder(root->lchild);
preorder(root->rchild);
}
}
void postorder(node *root)
{
if( root != NULL )
{
postorder(root->lchild);
postorder(root->rchild);
printf("%3s", root->data);
}
}
void print_leaf(node *root)
{
if(root != NULL)
{
if(root->lchild == NULL && root->rchild == NULL)
printf("%3s ",root->data);
print_leaf(root->lchild);
print_leaf(root->rchild);
}
}
int height(node *root)
{
if(root == NULL)
return -1;
else
return (1 + max(height(root->lchild), height(root->rchild)));
}
void print_tree(node *root, int line)
{
int i;
if(root != NULL)
{
print_tree(root->rchild,line+1);
printf("\n");
for(i=0;i<line;i++)

Lecture Notes

154

Dept. of Information Technology

}

}

printf(" ");
printf("%s", root->data);
print_tree(root->lchild,line+1);

void level_order(node *Q[],int ctr)
{
int i;
for( i = 0; i < ctr ; i++)
{
if( Q[i] != NULL )
printf("%5s",Q[i]->data);
}
}
int menu()
{
int ch;
clrscr();
printf("\n 1. Create Binary Tree ");
printf("\n 2. Inorder Traversal ");
printf("\n 3. Preorder Traversal ");
printf("\n 4. Postorder Traversal ");
printf("\n 5. Level Order Traversal");
printf("\n 6. Leaf Node ");
printf("\n 7. Print Height of Tree ");
printf("\n 8. Print Binary Tree ");
printf("\n 9. Delete a node ");
printf("\n 10. Quit ");
printf("\n Enter Your choice: ");
scanf("%d", &ch);
return ch;
}
void main()
{
int i,ch;
node *root = NULL;
do
{
ch = menu();
switch( ch)
{
case 1 :
if( root == NULL )
{
root = getnode();
create_binarytree(root);
}
else
{
printf("\n Tree is already Created ..");
}
break;
case 2 :
printf("\n Inorder Traversal: ");
inorder(root);
break;
case 3 :
printf("\n Preorder Traversal: ");
preorder(root);
break;

Lecture Notes

155

Dept. of Information Technology

case 4 :
printf("\n Postorder Traversal: ");
postorder(root);
break;
case 5:
printf("\n Level Order Traversal ..");
make_Queue(root,0);
level_order(Q,node_ctr);
break;
case 6 :
printf("\n Leaf Nodes: ");
print_leaf(root);
break;
case 7 :
printf("\n Height of Tree: %d ", height(root));
break;
case 8 :
printf("\n Print Tree \n");
print_tree(root, 0);
break;
case 9 :
delete_node(root,0);
break;
case 10 :
exit(0);

}
getch();
}while(1);

}

5.3.5.

Non Recursive Traversal Algorithms:

At first glance, it appears that we would always want to use the flat traversal functions
since they use less stack space. But the flat versions are not necessarily better. For
instance, some overhead is associated with the use of an explicit stack, which may
negate the savings we gain from storing only node pointers. Use of the implicit function
call stack may actually be faster due to special machine instructions that can be used.
Inorder Traversal:
Initially push zero onto stack and then set root as vertex. Then repeat the following
steps until the stack is empty:
1. Proceed down the left most path rooted at vertex, pushing each vertex onto the
stack and stop when there is no left son of vertex.
2. Pop and process the nodes on stack if zero is popped then exit. If a vertex with
right son exists, then set right son of vertex as current vertex and return to step
one.
Algorithm inorder()
{
stack[1] = 0
vertex = root
top: while(vertex ≠ 0)
{
push the vertex into the stack
vertex = leftson(vertex)

Lecture Notes

156

Dept. of Information Technology

}
pop the element from the stack and make it as vertex
while(vertex ≠ 0)
{
print the vertex node
if(rightson(vertex) ≠ 0)
{
vertex = rightson(vertex)
goto top
}
pop the element from the stack and made it as vertex
}
}
Preorder Traversal:
Initially push zero onto stack and then set root as vertex. Then repeat the following
steps until the stack is empty:
1. Proceed down the left most path by pushing the right son of vertex onto stack, if
any and process each vertex. The traversing ends after a vertex with no left
child exists.
2. Pop the vertex from stack, if vertex ≠ 0 then return to step one otherwise exit.
Algorithm preorder( )
{
stack[1] = 0
vertex = root.
while(vertex ≠ 0)
{
print vertex node
if(rightson(vertex) ≠ 0)
push the right son of vertex into the stack.
if(leftson(vertex) ≠ 0)
vertex = leftson(vertex)
else
pop the element from the stack and made it as vertex
}
}
Postorder Traversal:
Initially push zero onto stack and then set root as vertex. Then repeat the following
steps until the stack is empty:
1. Proceed down the left most path rooted at vertex. At each vertex of path push
vertex on to stack and if vertex has a right son push –(right son of vertex) onto
stack.
2. Pop and process the positive nodes (left nodes). If zero is popped then exit. If a
negative node is popped, then ignore the sign and return to step one.

Lecture Notes

157

Dept. of Information Technology

Algorithm postorder( )
{
stack[1] = 0
vertex = root
top: while(vertex ≠ 0)
{
push vertex onto stack
if(rightson(vertex) ≠ 0)
push – (vertex) onto stack
vertex = leftson(vertex)
}
pop from stack and make it as vertex
while(vertex > 0)
{
print the vertex node
pop from stack and make it as vertex
}
if(vertex < 0)
{
vertex = - (vertex)
goto top
}
}
Example 1:
Traverse the following binary tree in pre, post and inorder using non-recursive
traversing algorithm.

A
C

B
E

D
G
K

H
L

M
Bi n a ry T r e e

•

P r eo r d e r t r a v e rs a l y ie lds:
A , B , D, G , K , H , L , M , C , E

•

Po sto r d e r t r a v a rs a l y ie lds:
K , G , L , M , H , D, B , E , C , A

•

Ino r d e r t r a v a rs a l y ie lds:
K , G , D, L , H , M , B , A , E , C
Pr e, P o st a n d I n or d er T r av er s i n g

Inorder Traversal:
Initially push zero onto stack and then set root as vertex. Then repeat the following
steps until the stack is empty:
1. Proceed down the left most path rooted at vertex, pushing each vertex onto the
stack and stop when there is no left son of vertex.
2. Pop and process the nodes on stack if zero is popped then exit. If a vertex with
right son exists, then set right son of vertex as current vertex and return to step
one.

Lecture Notes

158

Dept. of Information Technology

CURRENT
VERTEX

STACK

A

0

PUSH 0

0ABDGK

PUSH the left most path of A

PROCESSED NODES

REMARKS

K

0ABDG

K

POP K

G

0ABD

KG

POP G since K has no right son

D

0AB

KGD

POP D since G has no right son

H

0AB

KGD

Make the right son of D as vertex

0ABHL

KGD

PUSH the leftmost path of H

L

0ABH

KGDL

POP L

H

0AB

KGDLH

POP H since L has no right son

M

0AB

KGDLH

Make the right son of H as vertex

0ABM

KGDLH

PUSH the left most path of M

M

0AB

KGDLHM

POP M

B

0A

KGDLHMB

POP B since M has no right son

A

0

KGDLHMBA

Make the right son of A as vertex

C

0CE

KGDLHMBA

PUSH the left most path of C

E

0C

KGDLHMBAE

POP E

C

0

KGDLHMBAEC

Stop since stack is empty

Postorder Traversal:
Initially push zero onto stack and then set root as vertex. Then repeat the following
steps until the stack is empty:
1. Proceed down the left most path rooted at vertex. At each vertex of path push
vertex on to stack and if vertex has a right son push –(right son of vertex) onto
stack.
2. Pop and process the positive nodes (left nodes). If zero is popped then exit. If a
negative node is popped, then ignore the sign and return to step one.
CURRENT
VERTEX

STACK

A

0

PUSH 0

0 A –C B D –H G K

PUSH the left most path of A with a
-ve for right sons

H

Lecture Notes

PROCESSED NODES

REMARKS

0 A –C B D –H

KG

POP all +ve nodes K and G

0 A –C B D

KG

Pop H

159

Dept. of Information Technology

0 A –C B D H –M L

KG

PUSH the left most path of H with a
-ve for right sons

L

0 A –C B D H –M

KGL

POP all +ve nodes L

M

0 A –C B D H

KGL

Pop M

0 A –C B D H M

KGL

PUSH the left most path of M with a
-ve for right sons

0 A –C

KGLMHDB

POP all +ve nodes M, H, D and B

0A

KGLMHDB

Pop C

0ACE

KGLMHDB

PUSH the left most path of C with a
-ve for right sons

0

KGLMHDBECA

POP all +ve nodes E, C and A

0

KGLMHDBECA

Stop since stack is empty

C

Preorder Traversal:
Initially push zero onto stack and then set root as vertex. Then repeat the following
steps until the stack is empty:
1. Proceed down the left most path by pushing the right son of vertex onto stack, if
any and process each vertex. The traversing ends after a vertex with no left
child exists.
2. Pop the vertex from stack, if vertex ≠ 0 then return to step one otherwise exit.

CURRENT
VERTEX

STACK

A

0

H

M

C

PROCESSED NODES

REMARKS
PUSH 0

0CH

ABDGK

PUSH the right son of each vertex onto stack and
process each vertex in the left most path

0C

ABDGK

POP H

0CM

ABDGKHL

PUSH the right son of each vertex onto stack and
process each vertex in the left most path

0C

ABDGKHL

POP M

0C

ABDGKHLM

PUSH the right son of each vertex onto stack and
process each vertex in the left most path; M has
no left path

0

ABDGKHLM

Pop C

0

ABDGKHLMCE

PUSH the right son of each vertex onto stack and
process each vertex in the left most path; C has
no right son on the left most path

0

ABDGKHLMCE

Stop since stack is empty

Lecture Notes

160

Dept. of Information Technology

Example 2:
Traverse the following binary tree in pre, post and inorder using non-recursive
traversing algorithm.

2
7
2

P r eo r d e r t r a v e rs a l y ie lds:
2, 7 , 2 , 6 , 5 , 11 , 5 , 9 , 4

•

Po sto r d e r t r a v a rs a l y ie lds:
2, 5 , 11 , 6 , 7 , 4 , 9 , 5 , 2

•

Ino r d e r t r a v a rs a l y ie lds:
2, 7 , 5 , 6 , 11 , 2 , 5 , 4 , 9

5
6

5

•

9
11

4

Bi n a ry T r e e

Pr e, P o st a n d I n or d er T r av er s i n g

Inorder Traversal:
Initially push zero onto stack and then set root as vertex. Then repeat the following
steps until the stack is empty:
1. Proceed down the left most path rooted at vertex, pushing each vertex onto the
stack and stop when there is no left son of vertex.
2. Pop and process the nodes on stack if zero is popped then exit. If a vertex with
right son exists, then set right son of vertex as current vertex and return to step
one.
CURRENT VERTEX

STACK

2

0

PROCESSED NODES

REMARKS

0272
2

027

2

7

02

27

6

0265

27

5

026

275

6

02

2756

11

0 2 11

2756

11

02

2 7 5 6 11

2

0

2 7 5 6 11 2

5

05

2 7 5 6 11 2

5

0

2 7 5 6 11 2 5

9

094

2 7 5 6 11 2 5

4

09

2 7 5 6 11 2 5 4

9

0

2 7 5 6 11 2 5 4 9

Lecture Notes

161

Stop since stack is empty

Dept. of Information Technology

Postorder Traversal:
Initially push zero onto stack and then set root as vertex. Then repeat the following
steps until the stack is empty:
1. Proceed down the left most path rooted at vertex. At each vertex of path push
vertex on to stack and if vertex has a right son push –(right son of vertex) onto
stack.
2. Pop and process the positive nodes (left nodes). If zero is popped then exit. If a
negative node is popped, then ignore the sign and return to step one.

CURRENT VERTEX

STACK

2

0

PROCESSED NODES

REMARKS

0 2 –5 7 –6 2
2

0 2 –5 7 –6

2

6

0 2 –5 7

2

0 2 –5 7 6 –11 5

2

5

0 2 –5 7 6 –11

25

11

0 2 –5 7 6 11

25

0 2 –5

2 5 11 6 7

5

0 2 5 –9

2 5 11 6 7

9

02594

2 5 11 6 7

0

2 5 11 6 7 4 9 5 2

Stop since stack is empty

Preorder Traversal:
Initially push zero onto stack and then set root as vertex. Then repeat the following
steps until the stack is empty:
1. Proceed down the left most path by pushing the right son of vertex onto stack, if
any and process each vertex. The traversing ends after a vertex with no left
child exists.
2. Pop the vertex from stack, if vertex ≠ 0 then return to step one otherwise exit.
CURRENT VERTEX

STACK

2

0

PROCESSED NODES

056

272

6

0 5 11

27265

11

05

2 7 2 6 5 11

05

2 7 2 6 5 11

5

09

2 7 2 6 5 11 5

9

0

2 7 2 6 5 11 5 9 4

0

2 7 2 6 5 11 5 9 4

Lecture Notes

162

REMARKS

Stop since stack is empty

Dept. of Information Technology

5.4.

Expression Trees:

Expression tree is a binary tree, because all of the operations are binary. It is also
possible for a node to have only one child, as is the case with the unary minus
operator. The leaves of an expression tree are operands, such as constants or variable
names, and the other (non leaf) nodes contain operators.
Once an expression tree is constructed we can traverse it in three ways:
•
•
•

Inorder Traversal
Preorder Traversal
Postorder Traversal

Figure 5.4.1 shows some more expression trees that represent arithmetic expressions
given in infix form.

+

+

+
a

/
b

d

+

c

d

+

(a) (a + b) + (c / d)

c

a

(b) ((a + b) + c) + d

b

/
+

*

-

+
a

x

+
y

*
b

c

a

(c) ((-a) + (x + y)) / ((+b) * (c * a))
Figure 5.4.1 Expression Trees

An expression tree can be generated for the infix and postfix expressions.
An algorithm to convert a postfix expression into an expression tree is as follows:
1.

Read the expression one symbol at a time.

2.

If the symbol is an operand, we create a one-node tree and push a pointer
to it onto a stack.

3.

If the symbol is an operator, we pop pointers to two trees T1 and T2 from
the stack (T1 is popped first) and form a new tree whose root is the operator
and whose left and right children point to T2 and T1 respectively. A pointer
to this new tree is then pushed onto the stack.

Lecture Notes

163

Dept. of Information Technology

Example 1:
Construct an expression tree for the postfix expression: a b + c d e + * *
Solution:
The first two symbols are operands, so we create one-node trees and push pointers to
them onto a stack.

a

b

Next, a ‘+’ is read, so two pointers to trees are popped, a new tree is formed, and a
pointer to it is pushed onto the stack.

+
a

b

Next, c, d, and e are read, and for each one–node tree is created and a pointer to the
corresponding tree is pushed onto the stack.

+
a

b

c

d

e

Now a ‘+’ is read, so two trees are merged.

+
c

+
a

Lecture Notes

+

bb

d

164

e

Dept. of Information Technology

Continuing, a ‘*’ is read, so we pop two tree pointers and form a new tree with a ‘*’ as
root.

+
+

a

*
b

c

+

d

ee

Finally, the last symbol is read, two trees are merged, and a pointer to the final tree is
left on the stack.

+
*
*

+

a

b

c

+

d

e
e

For the above tree:
Inorder form of the expression: a + b * c * d + e
Preorder form of the expression: * + a b * c + d e
Postorder form of the expression: a b + c d e + * *

Example 2:
Construct an expression tree for the arithmetic expression:
(A + B * C) – ((D * E + F) / G)
Solution:
First convert the infix expression into postfix notation. Postfix notation of the arithmetic
expression is: A B C * + D E * F + G / The first three symbols are operands, so we create one-node trees and pointers to
three nodes pushed onto the stack.

Lecture Notes

165

Dept. of Information Technology

A

B

C

Next, a ‘*’ is read, so two pointers to trees are popped, a new tree is formed, and a
pointer to it is pushed onto the stack.

A

*
C

B

Next, a ‘+’ is read, so two pointers to trees are popped, a new tree is formed, and a
pointer to it is pushed onto the stack.

+
A

*
B

C

Next, D and E are read, and for each one–node tree is created and a pointer to the
corresponding tree is pushed onto the stack.

D

+
A

E

*
B

C

Continuing, a ‘*’ is read, so we pop two tree pointers and form a new tree with a ‘*’ as
root.

+
A

D

*
B

Lecture Notes

*
E

C

166

Dept. of Information Technology

Proceeding similar to the previous steps, finally, when the last symbol is read, the
expression tree is as follows:

+
+

A

/

+

*

B

C

5.4.1.

F

*

D

G

E

Converting expressions with expression trees:

Let us convert the following expressions from one type to another. These can be as
follows:
1.
2.
3.
4.
1.

Postfix to infix
Postfix to prefix
Prefix to infix
Prefix to postfix

Postfix to Infix:

The following algorithm works for the expressions whose infix form does not require
parenthesis to override conventional precedence of operators.
A. Create the expression tree from the postfix expression
B. Run inorder traversal on the tree.
2.

Postfix to Prefix:
The following algorithm works for the expressions to convert postfix to prefix:
A. Create the expression tree from the postfix expression
B. Run preorder traversal on the tree.

3.

Prefix to Infix:

The following algorithm works for the expressions whose infix form does not require
parenthesis to override conventional precedence of operators.
A. Create the expression tree from the prefix expression
B. Run inorder traversal on the tree.

Lecture Notes

167

Dept. of Information Technology

4.

Prefix to postfix:
The following algorithm works for the expressions to convert postfix to prefix:
A. Create the expression tree from the prefix expression
B. Run postorder traversal on the tree.

5.5.

Threaded Binary Tree:

The linked representation of any binary tree has more null links than actual pointers. If
there are 2n total links, there are n+1 null links. A clever way to make use of these null
links has been devised by A.J. Perlis and C. Thornton.
Their idea is to replace the null links by pointers called Threads to other nodes in the
tree.
If the RCHILD(p) is normally equal to zero, we will replace it by a pointer to the node
which would be printed after P when traversing the tree in inorder.
A null LCHILD link at node P is replaced by a pointer to the node which immediately
precedes node P in inorder. For example, Let us consider the tree:
A
C

B
E

D

G

F

I

H

The Threaded Tree corresponding to the above tree is:
A
B
F

E

D
H

C
G

I

The tree has 9 nodes and 10 null links which have been replaced by Threads. If we
traverse T in inorder the nodes will be visited in the order H D I B E A F C G.
For example, node ‘E’ has a predecessor Thread which points to ‘B’ and a successor
Thread which points to ‘A’. In memory representation Threads and normal pointers are
distinguished between as by adding two extra one bit fields LBIT and RBIT.
LBIT(P) = 1
LBIT(P) = 0

if LCHILD(P) is a normal pointer
if LCHILD(P) is a Thread

RBIT(P) = 1
RBIT(P) = 0

if RCHILD(P) is a normal pointer
if RCHILD(P) is a Thread

Lecture Notes

168

Dept. of Information Technology

In the above figure two threads have been left dangling in LCHILD(H) and RCHILD(G).
In order to have no loose Threads we will assume a head node for all threaded binary
trees. The Complete memory representation for the tree is as follows. The tree T is the
left sub-tree of the head node.
LBIT LCHILD DATA RCHILD RBIT
1

1

1

1

0

5.6.

B

D

H

A

1

1

1

1

0

0

1

-

E

0

I

0

0

F

C

0

1

0

G

0

0

Binary Search Tree:

A binary search tree is a binary tree. It may be empty. If it is not empty then it
satisfies the following properties:
1.

Every element has a key and no two elements have the same key.

2.

The keys in the left subtree are smaller than the key in the root.

3.

The keys in the right subtree are larger than the key in the root.

4.

The left and right subtrees are also binary search trees.

Figure 5.2.5(a) is a binary search tree, whereas figure 5.2.5(b) is not a binary search
tree.
16

16

12
11

20
14

12

19

11

13

14
13

Binary Search Tree

20
19
17
17

Not a Binary Search Tree

(a)

(b)

Figure 5.2.5. Examples of binary search trees

Lecture Notes

169

Dept. of Information Technology

5.7.

General Trees (m-ary tree):

If in a tree, the outdegree of every node is less than or equal to m, the tree is called
general tree. The general tree is also called as an m-ary tree. If the outdegree of every
node is exactly equal to m or zero then the tree is called a full or complete m-ary tree.
For m = 2, the trees are called binary and full binary trees.
Differences between trees and binary trees:

TREE

BINARY TREE

Each element in a tree can have any
number of subtrees.

Each element in a binary tree has at most
two subtrees.

The subtrees in a tree are unordered.

The subtrees of each element in a binary
tree are ordered (i.e. we distinguish
between left and right subtrees).

5.7.1.

Converting a m-ary tree (general tree) to a binary tree:

There is a one-to-one mapping between general ordered trees and binary trees. So,
every tree can be uniquely represented by a binary tree. Furthermore, a forest can also
be represented by a binary tree.
Conversion from general tree to binary can be done in two stages.
Stage 1:
•

As a first step, we delete all the branches originating in every node except
the left most branch.

•

We draw edges from a node to the node on the right, if any, which is
situated at the same level.

Stage 2:
•

Once this is done then for any particular node, we choose its left and right
sons in the following manner:
•

Lecture Notes

The left son is the node, which is immediately below the given node,
and the right son is the node to the immediate right of the given node
on the same horizontal line. Such a binary tree will not have a right
subtree.

170

Dept. of Information Technology

Example 1:
Convert the following ordered tree into a binary tree:
1

2

3

6

7

4

8

5

9

10

11

Solution:
Stage 1 tree by using the above mentioned procedure is as follows:
1

2

6

3

7

4

8

5

9

10

11

Stage 2 tree by using the above mentioned procedure is as follows:
1
2
6

3
7

8

4
5
9
10
11

Example 2:
Construct a unique binary tree from the given forest.
1

2

4

Lecture Notes

5

7

3

8

6

11

171

9

10

12

13
0

Dept. of Information Technology

Solution:
Stage 1 tree by using the above mentioned procedure is as follows:
1

2

4

5

7

3

8

9

6

11

10

12

13

Stage 2 tree by using the above mentioned procedure is as follows (binary tree
representation of forest):
1
2

7

3

4

5

8

6

11
9

9

10

12
13

Example 3:
For the general tree shown below:
1.

Find the corresponding binary tree T’.

2.

Find the preorder traversal and the postorder traversal of T.

3.

Find the preorder, inorder and postorder traversals of T’.

4.

Compare them with the preorder and postorder traversals obtained for T’
with the general tree T.
A

B

C

D

F

E

J

G

H

Ge n e r a l t r e e T

Lecture Notes

172

K

L

M

P

N

Q

Dept. of Information Technology

Solution:
1.

Stage 1:
The tree by using the above-mentioned procedure is as follows:
A

B

C

F

D

E

G

J

H
B
5

K

L

M

P

N

Q

Stage 2:
The binary tree by using the above-mentioned procedure is as follows:
A
B

C

F

D

G

1E0

J

H

K

L
Bi n a rt t r e e T ’
M

P

N

Q

2.

Suppose T is a general tree with root R and subtrees T1, T2, ………., TM.
preorder traversal and the postorder traversal of T are:
Preorder:

1) Process the root R.
2) Traverse the subtree T1, T2, ……., TM in preorder.

Postorder:

1) Traverse the subtree T1, T2, ……., TM in postorder.
2) Process the root R.

The

The tree T has the root A and subtrees T1, T2 and T3 such that:
T1 consists of nodes B, C, D and E.
T2 consists of nodes F, G and H.
T3 consists of nodes J, K, L, M, N, P and Q.

Lecture Notes

173

Dept. of Information Technology

A.

The preorder traversal of T consists of the following steps:
(i)

Process root A.

(ii)

Traverse T1 in preorder: Process nodes B, C, D, E.

(iii)

Traverse T2 in preorder: Process nodes F, G, H.

(iv)

Traverse T3 in preorder: Process nodes J, K, L, M, P, Q, N.

The preorder traversal of T is as follows:
A, B, C, D, E, F, G, H, J, K, L, M, P, Q, N
B.

The postorder traversal of T consists of the following steps:
(i)

Traverse T1 in postorder: Process nodes C, D, E, B.

(ii)

Traverse T2 in postorder: Process nodes G, H, F.

(iii)

Traverse T3 in postorder: Process nodes K, L, P, Q, M, N, J.

(iv)

Process root A.

The postorder traversal of T is as follows:
C, D, E, B, G, H, F, K, L, P, Q, M, N, J, A
3.

The preorder, inorder and postorder traversals of the binary tree T’ are as
follows:

4.

Preorder:

A, B, C, D, E, F, G, H, J, K, M, P, Q, N

Inorder:

C, D, E, B, G, H, F, K, L, P, Q, M, N, J, A

Postorder:

E, D, C, H, G, Q, P, N, M, L, K, J, F, B, A

Comparing the preorder and postorder traversals of T’ with the general tree T:
We can observer that the preorder of the binary tree T’ is identical to the
preorder of the general T.
The inorder traversal of the binary tree T’ is identical to the postorder traversal
of the general tree T.
There is no natural traversal of the general tree T which corresponds to the
postorder traversal of its corresponding binary tree T’.

5.8.

Search and Traversal Techniques for m-ary trees:

Search involves visiting nodes in a tree in a systematic manner, and may or may not
result into a visit to all nodes. When the search necessarily involved the examination of
every vertex in the tree, it is called the traversal. Traversing of a tree can be done in
two ways.
1. Depth first search or traversal.
2. Breadth first search or traversal.

Lecture Notes

174

Dept. of Information Technology

5.8.1.

Depth first search:

In Depth first search, we begin with root as a start state, then some successor of the
start state, then some successor of that state, then some successor of that and so on,
trying to reach a goal state. One simple way to implement depth first search is to use a
stack data structure consisting of root node as a start state.
If depth first search reaches a state S without successors, or if all the successors of a
state S have been chosen (visited) and a goal state has not get been found, then it
“backs up” that means it goes to the immediately previous state or predecessor
formally, the state whose successor was ‘S’ originally.
To illustrate this let us consider the tree shown below.
D
A
E
ST A RT

J
B

S

H
C

F

G

GOAL

K
I

Suppose S is the start and G is the only goal state. Depth first search will first visit S,
then A, then D. But D has no successors, so we must back up to A and try its second
successor, E. But this doesn’t have any successors either, so we back up to A again.
But now we have tried all the successors of A and haven’t found the goal state G so we
must back to ‘S’. Now ‘S’ has a second successor, B. But B has no successors, so we
back up to S again and choose its third successor, C. C has one successor, F. The first
successor of F is H, and the first of H is J. J doesn’t have any successors, so we back up
to H and try its second successor. And that’s G, the only goal state.
So the solution path to the goal is S, C, F, H and G and the states considered were in
order S, A, D, E, B, C, F, H, J, G.
Disadvantages:
1.

It works very fine when search graphs are trees or lattices, but can get
struck in an infinite loop on graphs. This is because depth first search can
travel around a cycle in the graph forever.
To eliminate this keep a list of states previously visited, and never permit
search to return to any of them.

2.

We cannot come up with shortest solution to the problem.

5.8.2.

Breadth first search:

Breadth-first search starts at root node S and “discovers" which vertices are reachable
from S. Breadth-first search discovers vertices in increasing order of distance. Breadthfirst search is named because it visits vertices across the entire breadth.

Lecture Notes

175

Dept. of Information Technology

To illustrate this let us consider the following tree:
D
A
E
ST A RT

J
B

S

H
C

F

G

GOAL

K
I

Breadth first search finds states level by level. Here we first check all the immediate
successors of the start state. Then all the immediate successors of these, then all the
immediate successors of these, and so on until we find a goal node. Suppose S is the
start state and G is the goal state. In the figure, start state S is at level 0; A, B and C
are at level 1; D, e and F at level 2; H and I at level 3; and J, G and K at level 4.
So breadth first search, will consider in order S, A, B, C, D, E, F, H, I, J and G and then
stop because it has reached the goal node.
Breadth first search does not have the danger of infinite loops as we consider states in
order of increasing number of branches (level) from the start state.
One simple way to implement breadth first search is to use a queue data structure
consisting of just a start state.
5.9.

Sparse Matrices:

A sparse matrix is a two–dimensional array having the value of majority elements as
null. The density of the matrix is the number of non-zero elements divided by the total
number of matrix elements. The matrices with very low density are often good for use
of the sparse format. For example,

A =

⎛0
⎜
⎜0
⎜1
⎜⎜
⎝0

0

0

2

0

3

0

0

4

5⎞
⎟
0⎟
0⎟
⎟
0 ⎟⎠

As far as the storage of a sparse matrix is concerned, storing of null elements is
nothing but wastage of memory. So we should devise technique such that only non-null
elements will be stored. The matrix A produces:
(3, 1) 1
(2, 2) 2
S=
(3, 2) 3
(4, 3) 4
(1, 4) 5
The printed output lists the non-zero elements of S, together with their row and column
indices. The elements are sorted by columns, reflecting the internal data structure.
In large number of applications, sparse matrices are involved. One approach is to use
the linked list.

Lecture Notes

176

Dept. of Information Technology

The program to represent sparse matrix:
/*

Check whether the given matrix is sparse matrix or not, if so then print in
alternative form for storage.
*/

# include <stdio.h>
# include <conio.h>
main()
{
int matrix[20][20], m, n, total_elements, total_zeros = 0, i, j;
clrscr();
printf("\n Enter Number of rows and columns: ");
scanf("%d %d",&m, &n);
total_elements = m * n;
printf("\n Enter data for sparse matrix: ");
for(i = 0; i < m ; i++)
{
for( j = 0; j < n ; j++)
{
scanf("%d", &matrix[i][j]);
if( matrix[i][j] == 0)
{
total_zeros++;
}
}
}
if(total_zeros > total_elements/2 )
{
printf("\n Given Matrix is Sparse Matrix..");
printf("\n The Representaion of Sparse Matrix is: \n");
printf("\n Row \t Col \t Value ");
for(i = 0; i < m ; i++)
{
for( j = 0; j < n ; j++)
{
if( matrix[i][j] != 0)
{
printf("\n %d \t %d \t %d",i,j,matrix[i][j]);
}
}
}
}
else
printf("\n Given Matrix is Not a Sparse Matrix..");
}

Lecture Notes

177

Dept. of Information Technology

EXCERCISES
1.

How many different binary trees can be made from three nodes that contain the
key value 1, 2, and 3?

2. a. Draw all the possible binary trees that have four leaves and all the nonleaf nodes
have no children.
b. Show what would be printed by each of the following.
An inorder traversal of the tree
A postorder traversal of the tree
A preorder traversal of the tree
3. a. Draw the binary search tree whose elements are inserted in the following order:
50 72 96 94 107 26 12 11 9 2 10 25 51 16 17 95
b.
c.
d.
e.
f.

What is the height of the tree?
What nodes are on level?
Which levels have the maximum number of nodes that they could contain?
What is the maximum height of a binary search tree containing these nodes?
Draw such a tree?
What is the minimum height of a binary search tree containing these nodes?
Draw such a tree?

g. Show how the tree would look after the deletion of 29, 59 and 47?
h. Show how the (original) tree would look after the insertion of nodes containing
63, 77, 76, 48, 9 and 10 (in that order).
4.

Write a “C” function to determine the height of a binary tree.

5.

Write a “C” function to count the number of leaf nodes in a binary tree.

6.

Write a “C” function to swap a binary tree.

7.

Write a “C” function to compute the maximum number of nodes in any level of a
binary tree. The maximum number of nodes in any level of a binary tree is also
called the width of the tree.

8.

Construct two binary trees so that their postorder traversal sequences are the
same.

9.

Write a “C” function to compute the internal path length of a binary tree.

10.

Write a “C” function to compute the external path length of a binary tree.

11.

Prove that every node in a tree except the root node has a unique parent.

12.

Write a “C” function to reconstruct a binary tree from its preorder and inorder
traversal sequences.

13.

Prove that the inorder and postorder traversal sequences of a binary tree
uniquely characterize the binary tree. Write a “C” function to reconstruct a binary
tree from its postorder and inorder traversal sequences.

Lecture Notes

178

Dept. of Information Technology

14.

15.

16.

Build the binary tree from the given traversal techniques:
A.

Inorder:
Preorder:

gdhbeiafjc
abdgheicfj

B.

Inorder:
Postorder:

gdhbeiafjc
ghdiebjfca

C.

Inorder:
Level order:

gdhbeiafjc
abcdefghij

Build the binary tree from the given traversal techniques:
A.

Inorder:
Preorder:

n1 n2 n3 n4 n5 n6 n7 n8 n9
n6 n2 n1 n4 n3 n5 n9 n7 n8

B.

Inorder:
Postorder:

n1 n2 n3 n4 n5 n6 n7 n8 n9
n1 n3 n5 n4 n2 n8 n7 n9 n6

C.

Inorder:
Level order:

n1 n2 n3 n4 n5 n6 n7 n8 n9
n6 n2 n9 n1 n4 n7 n3 n5 n8

Build the binary tree for the given inorder and preorder traversals:
Inorder:
Preorder:

17.

EACKFHDBG
FAEKCDHGB

Convert the following general tree represented as a binary tree:

3

1

12

7

15

5

10

13

14

11

4

9

2

16

Lecture Notes

179

8

6

17

Dept. of Information Technology

Multiple Choice Questions
1.

The node that has no children is referred as:
A. Parent node
C. Leaf node
B. Root node
D. Sibblings

[

C ]

2.

A binary tree in which all the leaves are on the same level is called as:
A. Complete binary tree
C. Strictly binary tree
B. Full binary tree
D. Binary search tree

[

B ]

3.

How can the graphs be represented?
A. Adjacency matrix
B. Adjacency list
C. Incidence matrix
D. All of the above

[

C ]

4.

The children of a same parent node are called as:
A. adjacent node
C. Sibblings
B. non-leaf node
D. leaf node

[

C ]

5.

A tree with n vertices, consists of________ edges.
A. n – 1
C. n
B. n - 2
D. log n

[

A ]

6.

The maximum number of nodes at any level is:
A. n
C. n + 1
B. 2n
D. 2n

[

B ]

A
B

D

H

C

E

I

FI G UR E 1

F

G

J

K

7.

For the Binary tree shown in fig. 1, the in-order traversal sequence is:
A. A B C D E F G H I J K
C. H D I B E A F C J G K
B. H I D E B F J K G C A
D. A B D H I E C F G J K

[

C ]

8.

For the Binary tree shown in fig. 1, the pre-order traversal sequence is:
A. A B C D E F G H I J K
C. H D I B E A F C J G K
B. H I D E B F J K G C A
D. A B D H I E C F G J K

[

D ]

9.

For the Binary tree shown in fig. 1, the post-order traversal sequence is:
A. A B C D E F G H I J K
C. H D I B E A F C J G K
B. H I D E B F J K G C A
D. A B D H I E C F G J K

[

B ]

Lecture Notes

180

Dept. of Information Technology

23

28

B

9

D

25

A

15

4

1
36

C

Node

20

A

E

16
3

F

G

17

Adjacency List
BCD

B

ADE

C

ADF

D

ABCEFG

E

BDG

F

CDG

G

FDE

FIGURE 2 and its adjacency list
10.

Which is the correct order for Kruskal’s minimum spanning tree algorithm
to add edges to the minimum spanning tree for the figure 2 shown above:
A. (A, B) then (A, C) then (A, D) then (D, E) then (C, F) then (D, G)
B. (A, D) then (E, G) then (B, D) then (D, E) then (F, G) then (A, C)
C. both A and B
D. none of the above

[

B ]

11.

For the figure 2 shown above, the cost of the minimal spanning tree is:
A. 57
C. 48
B. 68
D. 32

[ A

]

14
2

1

FIGURE 3

11

3

10

7

30

40

12.

For the figure 3, how many leaves does it have?
A. 2
C. 6
B. 4
D. 8

[

B ]

13.

For the figure 3, how many of the nodes have at least one sibling?
A. 5
C. 7
B. 6
D. 8

[

A

14.

For the figure 3, How many descendants does the root have?
A. 0
C. 4
B. 2
D. 8

[

D ]

15.

For the figure 3, what is the depth of the tree?
A. 2
C. 4
B. 3
D. 8

[

B ]

16.

For the figure 3, which statement is correct?
A. The tree is neither complete nor full.
B. The tree is complete but not full.
C. The tree is full but not complete.
D. The tree is both full and complete.

[

A ]

Lecture Notes

181

Dept. of Information Technology

]

17.

There is a tree in the box at the top of this section. What is the order of
nodes visited using a pre-order traversal?
A. 1 2 3 7 10 11 14 30 40
C. 1 3 2 7 10 40 30 11 14
B. 1 2 3 14 7 10 11 40 30
D. 14 2 1 3 11 10 7 30 40

[

]

18.

There
nodes
A. 1 2
B. 1 2

is a tree in the box at the top of this section. What is the order of
visited using an in-order traversal?
3 7 10 11 14 30 40
C. 1 3 2 7 10 40 30 11 14
3 14 7 10 11 40 30
D. 14 2 1 3 11 10 7 30 40

[

]

19.

There
nodes
A. 1 2
B. 1 2

is a tree in the box at the top of this section. What is the order of
visited using a post-order traversal?
3 7 10 11 14 30 40
C. 1 3 2 7 10 40 30 11 14
3 14 7 10 11 40 30
D. 14 2 1 3 11 10 7 30 40

[

]

20.

What is the minimum number of nodes in a full binary tree with depth 3?
A. 3
C. 8
B. 4
D. 15

[ D

]

21.

Select the one true statement.
A. Every binary tree is either complete or full.
B. Every complete binary tree is also a full binary tree.
C. Every full binary tree is also a complete binary tree.
D. No binary tree is both complete and full.

[

C ]

22.

Suppose T is a binary tree with 14 nodes. What is the minimum possible
depth of T?
A. 0
C. 4
B. 3
D. 5

[

B ]

23.

Select the one FALSE statement about binary trees:
A. Every binary tree has at least one node.
B. Every non-empty tree has exactly one root node.
C. Every node has at most two children.
D. Every non-root node has exactly one parent.

[

A ]

24.

Consider the node of a complete binary tree whose value is stored in
data[i] for an array implementation. If this node has a right child, where
will the right child's value be stored?
A. data[i+1]
C. data[2*i + 1]
B. data[i+2]
D. data[2*i + 2]

[

C ]

14
2

16

1

Figure 4

5

4

Lecture Notes

182

Dept. of Information Technology

25.

For the binary search tree shown in figure 4, Suppose we remove the root,
replacing it with something from the left subtree. What will be the new
root?
A. 1
D. 5
B. 2
E. 16
C. 4

[

D ]

A
B

G

C

Tr e e 2

D

E

G

F

E

F
I

H
J

I

Tr e e 1

C

D

H

A

B

J

26.

Which traversals of tree 1 and tree 2, will produce the same sequence of
node names?
A. Preorder, Postorder
C. Postorder, Inorder
B. Postorder, Postorder
D. Inorder, Inorder

[

C ]

27.

Which among the following is not a binary search tree?

[

C ]

A.

C.

5
3

7

2

4

6

B.
3

7

3

6

D.

5

7

5

14

2

2

16

6
1

5

4

Lecture Notes

183

Dept. of Information Technology

23
11

27

7

6

17

9

25

FI G UR E 5

14

28.

For the binary search tree shown in figure 5, after deleting 23 from the
binary search tree what node will be at the root?
A. 11
C. 27
B. 25
D. 14

[

]

29.

For the binary search tree shown in figure 5, after deleting 23 from the
binary search tree what parent → child pair does not occur in the tree?
A. 25 → 27
C. 11 → 7
B. 27 → 11
D. 7 → 9
The number of nodes in a complete binary tree of depth d is:
C. 2k
A. 2d
k
D. none of the above
B. 2 - 1

[

B ]

[ B

]

31.

The depth of a complete binary tree with n nodes is:
A. log n
C. ⎣ log2 n ⎦ + 1
B. n2
D. 2n

[ C

]

32.

If the inorder and preorder traversal of a binary tree are D, B, F, E, G, H, A,
C and A, B, D, E, F, G, H, C respectively then, the postorder traversal of
that tree is:
A. D, F, H, G, E, B, C, A
C. F, H, D, G, E, B, C, A
B. D, F, G, A, B, C, H, E
D. D, F, H, G, E, B, C, A

[ A

]

33.

The data structure used by level order traversal of binary tree is:
A. Queue
C. linked list
B. Stack
D. none of the above

[ A

]

30.

Lecture Notes

184

Dept. of Information Technology

Chapter

6

Graphs
6.1.

Introduction to Graphs:

Graph G is a pair (V, E), where V is a finite set of vertices and E is a finite set of edges.
We will often denote n = |V|, e = |E|.
A graph is generally displayed as figure 6.5.1, in which the vertices are represented by
circles and the edges by lines.
An edge with an orientation (i.e., arrow head) is a directed edge, while an edge with no
orientation is our undirected edge.
If all the edges in a graph are undirected, then the graph is an undirected graph. The
graph in figure 6.5.1(a) is an undirected graph. If all the edges are directed; then the
graph is a directed graph. The graph of figure 6.5.1(b) is a directed graph. A directed
graph is also called as digraph. A graph G is connected if and only if there is a simple
path between any two nodes in G.
A graph G is said to be complete if every node a in G is adjacent to every other node v
in G. A complete graph with n nodes will have n(n-1)/2 edges. For example, Figure
6.5.1.(a) and figure 6.5.1.(d) are complete graphs.
A directed graph G is said to be connected, or strongly connected, if for each pair (u, v)
for nodes in G there is a path from u to v and also a path from v to u. On the other
hand, G is said to be unilaterally connected if for any pair (u, v) of nodes in G there is a
path from u to v or a path from v to u. For example, the digraph shown in figure 6.5.1
(e) is strongly connected.

B

D

A

C

E

E

G
C

(a)

v4
v3

v4
(e)

v2

(b)

v1

v2

v4

D

F
v1

(d)

v1

B

A

v3

v1

v1

v2

v4
(f)

v3

v2

v2
v3

(c)

v3

(g)

v4

v5

v6

v7

Figure 6.5.1 Various Graphs

We can assign weight function to the edges: wG(e) is a weight of edge e ∈ E. The graph
which has such function assigned is called weighted graph.

Lecture Notes

185

Dept. of Information Technology

The number of incoming edges to a vertex v is called in–degree of the vertex (denote
indeg(v)). The number of outgoing edges from a vertex is called out-degree (denote
outdeg(v)). For example, let us consider the digraph shown in figure 6.5.1(f),
indegree(v1) = 2

outdegree(v1) = 1

indegree(v2) = 2

outdegree(v2) = 0

A path is a sequence of vertices (v1, v2, . . . . . , vk), where for all i, (vi, vi+1) ε E. A path
is simple if all vertices in the path are distinct. If there is a path containing one or more
edges which starts from a vertex Vi and terminates into the same vertex then the path
is known as a cycle. For example, there is a cycle in figure 6.5.1(a), figure 6.5.1(c) and
figure 6.5.1(d).
If a graph (digraph) does not have any cycle then it is called acyclic graph. For
example, the graphs of figure 6.5.1 (f) and figure 6.5.1 (g) are acyclic graphs.
A graph G’ = (V’, E’) is a sub-graph of graph G = (V, E) iff V’ ⊆ V and E’ ⊆ E.
A Forest is a set of disjoint trees. If we remove the root node of a given tree then it
becomes forest. The following figure shows a forest F that consists of three trees T1, T2
and T3.

A

P

B

T1

C

D

E

Q

X
Y

R
Z

F

T2

T3

A Forest F

A graph that has either self loop or parallel edges or both is called multi-graph.
Tree is a connected acyclic graph (there aren’t any sequences of edges that go around
in a loop). A spanning tree of a graph G = (V, E) is a tree that contains all vertices of V
and is a subgraph of G. A single graph can have multiple spanning trees.
Let T be a spanning tree of a graph G. Then
1.

Any two vertices in T are connected by a unique simple path.

2.

If any edge is removed from T, then T becomes disconnected.

3.

If we add any edge into T, then the new graph will contain a cycle.

4.

Number of edges in T is n-1.

Lecture Notes

186

Dept. of Information Technology

6.2.

Representation of Graphs:

There are two ways of representing digraphs. They are:
•

Adjacency matrix.

•

Adjacency List.

•

Incidence matrix.

Adjacency matrix:
In this representation, the adjacency matrix of a graph G is a two dimensional n x n
matrix, say A = (ai,j), where
⎧ 1 if there is an edge from v i to v j
= ⎨
⎩ 0 otherwise
The matrix is symmetric in case of undirected graph, while it may be asymmetric if the
graph is directed. This matrix is also called as Boolean matrix or bit matrix.
a i,

j

1
2

G1:

3

4

(a)

5

(b)

1
2
3
4
5

1
0
0
0
0
0

2
1
0
0
0
0

3
1
1
0
0
1

4
0
1
1
0
1

5
1
1
0
0
0

Figure 6.5.2. A graph and its Adjacency matrix

Figure 6.5.2(b) shows the adjacency matrix representation of the graph G1 shown in
figure 6.5.2(a). The adjacency matrix is also useful to store multigraph as well as
weighted graph. In case of multigraph representation, instead of entry 0 or 1, the entry
will be between number of edges between two vertices.
In case of weighted graph, the entries are weights of the edges between the vertices.
The adjacency matrix for a weighted graph is called as cost adjacency matrix. Figure
6.5.3(b) shows the cost adjacency matrix representation of the graph G2 shown in
figure 6.5.3(a).

G2:

4

B

3

1

2

A

6
(a)

D

C

2
4

2

E
2

4
1
1

F

G

(b)

A
B
C
D
E
F
G

A
0
3
6
∝
∝
∝
∝

B
3
0
2
4
∝
∝
∝

C
6
2
0
1
4
2
∝

D
∝
4
1
0
2
∝
4

E
∝
∝
4
2
0
2
1

F
∝
∝
2
∝
2
0
1

G
∝
∝
∝
4
1
1
0

Figure 6.5.3 Weighted graph and its Cost adjacency matrix

Lecture Notes

187

Dept. of Information Technology

Adjacency List:
In this representation, the n rows of the adjacency matrix are represented as n linked
lists. An array Adj[1, 2, . . . . . n] of pointers where for 1 < v < n, Adj[v] points to a
linked list containing the vertices which are adjacent to v (i.e. the vertices that can be
reached from v by a single edge). If the edges have weights then these weights may
also be stored in the linked list elements. For the graph G in figure 6.5.4(a), the
adjacency list in shown in figure 6.5.4 (b).

1

2

3

1

1

1

1

2

0

0

3

0

1

1

1

1

2

3

0

3

2

(a) Adjacency Matrix

2

3

(b) Adjacency List

Figure 6.5.4 Adjacency matrix and adjacency list

Incidence Matrix:
In this representation, if G is a graph with n vertices, e edges and no self loops, then
incidence matrix A is defined as an n by e matrix, say A = (ai,j), where
a i,

j

⎧ 1 if there is an edge j incident to v i
= ⎨
⎩ 0 otherwise

Here, n rows correspond to n vertices and e columns correspond to e edges. Such a
matrix is called as vertex-edge incidence matrix or simply incidence matrix.

c

B
a

d

b

A

g
(a)

D

C

f

e
h

k

E
j

i

G
l

F

(b)

A
B
C
D
E
F
G

a
1
1
0
0
0
0
0

b
0
1
1
0
0
0
0

c
0
1
0
1
0
0
0

d
0
0
1
1
0
0
0

e
0
0
0
1
1
0
0

f
0
0
0
1
0
0
1

g
1
0
1
0
0
0
0

h
0
0
1
0
1
0
0

i
0
0
0
0
1
0
1

j
0
0
0
0
1
1
0

k
0
0
1
0
0
1
0

l
0
0
0
0
0
1
1

Figure 6.5.4 Graph and its incidence matrix

Figure 6.5.4(b) shows the incidence matrix representation of the graph G1 shown in
figure 6.5.4(a).

Lecture Notes

188

Dept. of Information Technology

6.3.

Minimum Spanning Tree (MST):

A spanning tree for a connected graph is a tree whose vertex set is the same as the
vertex set of the given graph, and whose edge set is a subset of the edge set of the
given graph. i.e., any connected graph will have a spanning tree.
Weight of a spanning tree w(T) is the sum of weights of all edges in T. Minimum
spanning tree (MST) is a spanning tree with the smallest possible weight.
Example:

G:
A gr a p h G:

T hr e e ( of ma n y p o s s i b l e) s p a n n i n g t r e e s f r o m gr a p h G:

2

2

4

G:

3

3

5
6

1

1
A w e i g ht e d gr a p h G:

T h e mi n i m a l s p a n n i n g t r e e f r o m w e i g ht e d gr a p h G:

Let's consider a couple of real-world examples on minimum spanning tree:
•

One practical application of a MST would be in the design of a network. For
instance, a group of individuals, who are separated by varying distances,
wish to be connected together in a telephone network. Although MST cannot
do anything about the distance from one connection to another, it can be
used to determine the least cost paths with no cycles in this network,
thereby connecting everyone at a minimum cost.

•

Another useful application of MST would be finding airline routes. The
vertices of the graph would represent cities, and the edges would represent
routes between the cities. MST can be applied to optimize airline routes by
finding the least costly paths with no cycles.

Minimum spanning tree, can be constructed using any of the following two algorithms:
1.

Kruskal’s algorithm and

2.

Prim’s algorithm.

Both algorithms differ in their methodology, but both eventually end up with the
MST. Kruskal's algorithm uses edges, and Prim’s algorithm uses vertex connections in
determining the MST. In Prim’s algorithm at any instance of output it represents tree
whereas in Kruskal’s algorithm at any instance of output it may represent tree or not.

Lecture Notes

189

Dept. of Information Technology

6.3.1.

Kruskal’s Algorithm

This is a greedy algorithm. A greedy algorithm chooses some local optimum (i.e.
picking an edge with the least weight in a MST).
Kruskal's algorithm works as follows: Take a graph with 'n' vertices, keep on adding the
shortest (least cost) edge, while avoiding the creation of cycles, until (n - 1) edges
have been added. Sometimes two or more edges may have the same cost.
The order in which the edges are chosen, in this case, does not matter. Different MST’s
may result, but they will all have the same total cost, which will always be the
minimum cost.
Kruskal’s Algorithm for minimal spanning tree is as follows:
1. Make the tree T empty.
2. Repeat the steps 3, 4 and 5 as long as T contains less than n - 1 edges and E is
not empty otherwise, proceed to step 6.
3. Choose an edge (v, w) from E of lowest cost.
4. Delete (v, w) from E.
5. If (v, w) does not create a cycle in T
then Add (v, w) to T
else discard (v, w)
6. If T contains fewer than n - 1 edges then print no spanning tree.

Example 1:
Construct the minimal spanning tree for the graph shown below:

10

1

50

2

45

40

30

3

35
25

4

5

55
20

15

6

Arrange all the edges in the increasing order of their costs:
Cost

10

15

20

25

30

35

40

45

50

55

Edge (1, 2) (3, 6) (4, 6) (2, 6) (1, 4) (3, 5) (2, 5) (1, 5) (2, 3) (5, 6)

Lecture Notes

190

Dept. of Information Technology

The stages in Kruskal’s algorithm for minimal spanning tree is as follows:
EDGE

COST

(1, 2)

10

STAGES IN KRUSKAL’S
ALGORITHM

1

The edge between vertices 1 and 2 is
the first edge selected. It is included in
the spanning tree.

2
3

4

REMARKS

5
6

(3, 6)

15
1

Next, the edge between vertices 3 and 6
is selected and included in the tree.

2
3

4

5
6

(4, 6)

20

1

The edge between vertices 4 and 6 is
next included in the tree.

2
3

4

5
6

(2, 6)

25

1

The edge between vertices 2 and 6 is
considered next and included in the
tree.

2
3

4

5
6

(1, 4)

30

(3, 5)

35

The edge between the vertices 1 and 4
is discarded as its inclusion creates a
cycle.

Reject

1

2

4

Finally, the edge between vertices 3 and
5 is considered and included in the tree
built. This completes the tree.

3
5

The cost of the minimal spanning tree is
105.

6

Lecture Notes

191

Dept. of Information Technology

Example 2:
Construct the minimal spanning tree for the graph shown below:
28

1
10

2
14

6
24

25

16

7
3
18

5
22

12

4

Solution:
Arrange all the edges in the increasing order of their costs:
Cost

10

12

14

16

18

22

24

25

28

Edge (1, 6) (3, 4) (2, 7) (2, 3) (4, 7) (4, 5) (5, 7) (5, 6) (1, 2)

The stages in Kruskal’s algorithm for minimal spanning tree is as follows:
EDGE

COST

(1, 6)

10

STAGES IN KRUSKAL’S
ALGORITHM
1

REMARKS

The edge between vertices 1 and 6 is
the first edge selected. It is included in
the spanning tree.

2
6

3

7
5
4

(3, 4)

1

12

Next, the edge between vertices 3 and 4
is selected and included in the tree.

2
6

3

7
5
4

(2, 7)

1

14

The edge between vertices 2 and 7 is
next included in the tree.

2
6

3

7
5
4

Lecture Notes

192

Dept. of Information Technology

(2, 3)

1

16

The edge between vertices 2 and 3 is
next included in the tree.

2
6

3

7
5
4

(4, 7)

18

(4, 5)

22

The edge between the vertices 4 and 7
is discarded as its inclusion creates a
cycle.

Reject

1

The edge between vertices 4 and 7 is
considered next and included in the
tree.

2
6

3

7
5
4

(5, 7)

24

(5, 6)

25

The edge between the vertices 5 and 7
is discarded as its inclusion creates a
cycle.

Reject

1

Finally, the edge between vertices 5 and
6 is considered and included in the tree
built. This completes the tree.

2
6

3

7

The cost of the minimal spanning tree is
99.

5
4

6.3.2.

MINIMUM-COST SPANNING TREES: PRIM'S ALGORITHM

A given graph can have many spanning trees. From these many spanning trees, we
have to select a cheapest one. This tree is called as minimal cost spanning tree.
Minimal cost spanning tree is a connected undirected graph G in which each edge is
labeled with a number (edge labels may signify lengths, weights other than costs).
Minimal cost spanning tree is a spanning tree for which the sum of the edge labels is as
small as possible
The slight modification of the spanning tree algorithm yields a very simple algorithm for
finding an MST. In the spanning tree algorithm, any vertex not in the tree but
connected to it by an edge can be added. To find a Minimal cost spanning tree, we
must be selective - we must always add a new vertex for which the cost of the new
edge is as small as possible.
This simple modified algorithm of spanning tree is called prim's algorithm for finding an
Minimal cost spanning tree. Prim's algorithm is an example of a greedy algorithm.
Lecture Notes

193

Dept. of Information Technology

Prim’s Algorithm:
E is the set of edges in G. cost [1:n, 1:n] is the cost adjacency matrix of an n vertex
graph such that cost [i, j] is either a positive real number or ∝ if no edge (i, j) exists. A
minimum spanning tree is computed and stored as a set of edges in the array t [1:n-1,
1:2]. (t [i, 1], t [i, 2]) is an edge in the minimum-cost spanning tree. The final cost is
returned.
Algorithm Prim (E, cost, n, t)
{
Let (k, l) be an edge of minimum cost in E;
mincost := cost [k, l];
t [1, 1] := k; t [1, 2] := l;
for i :=1 to n do
// Initialize near
if (cost [i, l] < cost [i, k]) then near [i] := l;
else near [i] := k;
near [k] :=near [l] := 0;
for i:=2 to n - 1 do
// Find n - 2 additional edges for t.
{
Let j be an index such that near [j] ≠ 0 and
cost [j, near [j]] is minimum;
t [i, 1] := j; t [i, 2] := near [j];
mincost := mincost + cost [j, near [j]];
near [j] := 0
for k:= 1 to n do
// Update near[].
if ((near [k] ≠ 0) and (cost [k, near [k]] > cost [k, j]))
then near [k] := j;
}
return mincost;
}
EXAMPLE:
Use Prim’s Algorithm to find a minimal spanning tree for the graph shown below
starting with the vertex A.
4

B
3

2

D

1

2
E

4
A

6

C

4
1

2
2

G
F

1

Solution:
⎛0
⎜
⎜3
⎜6
⎜
The cost adjacency matrix is ⎜ ∞
⎜
⎜∞
⎜∞
⎜⎜
⎝∞
Lecture Notes

3

6

∞

∞

∞

0

2

4

∞

∞

2

0

1

4

2

4

1

0

2

∞

∞

4

2

0

2

∞

2

∞

2

0

∞

∞

4

1

1

194

∞⎞
⎟
∞⎟
∞⎟
⎟
4⎟
⎟
1⎟
1⎟
⎟
0 ⎟⎠
Dept. of Information Technology

The stepwise progress of the prim’s algorithm is as follows:
Step 1:
B

A

3

∝

D

∝

E

∝

F

6

0

C

∝ G

Vertex
Status
Dist.
Next

A
0
0
*

B
1
3
A

C
1
6
A

D
1
∝
A

E
1
∝
A

F
1
∝
A

G
1
∝
A

Vertex
Status
Dist.
Next

A
0
0
*

B
0
3
A

C
1
2
B

D
1
4
B

E
1
∝
A

F
1
∝
A

G
1
∝
A

Vertex
Status
Dist.
Next

A
0
0
*

B
0
3
A

C
0
2
B

D
1
1
C

E
1
4
C

F
1
2
C

G
1
∝
A

Vertex
Status
Dist.
Next

A
0
0
*

B
0
3
A

C
0
2
B

D
0
1
C

E
1
2
D

F
1
2
C

G
1
4
D

Vertex
Status
Dist.
Next

A
0
0
*

B
0
3
A

C
0
2
B

D
0
1
C

E
1
2
D

F
0
2
C

G
1
1
E

Step 2:
B 3

A

0

2
C

44

D

∝

E

∝

F

1

D

4

E

∝ G

Step 3:
B 3

A

0

∝

2
C

2

F

1

D

2

E

2

F

1

D

2

E

2

F

G

Step 4:

A

0

2
C

4

G

Step 5:
B
A

0

3
2

1

G

C

Lecture Notes

195

Dept. of Information Technology

Step 6:
B
A

1

3

0

2

2

C

G

Vertex
Status
Dist.
Next

A
0
0
*

B
0
3
A

C
0
2
B

D
0
1
C

E
0
2
D

F
1
1
G

G
0
1
E

G

Vertex
Status
Dist.
Next

A
0
0
*

B
0
3
A

C
0
2
B

D
0
1
C

E
0
2
D

F
0
1
G

G
0
1
E

D
1
E

1

F

Step 7:
B
A

0

3
2
C

6.4.

1

D

2

E

1

F

1

Reachability Matrix (Warshall’s Algorithm):

Warshall’s algorithm requires knowing which edges exist and which does not. It doesn’t
need to know the lengths of the edges in the given directed graph. This information is
conveniently displayed by adjacency matrix for the graph, in which a ‘1’ indicates the
existence of an edge and ‘0’ indicates non-existence.

A d j ac e nc y M at r i x

W a r s h a l l’ s A l g or it h m

A l l P a ir s Rec h a b i l it y
M at r i x

It begins with the adjacency matrix for the given graph, which is called A0, and then
updates the matrix ‘n’ times, producing matrices called A1, A2, . . . . . , An and then
stops.
In warshall’s algorithm the matrix Ai contains information about the existence of
i–paths. A one entry in the matrix Ai will correspond to the existence of i–paths and
zero entry will correspond to non-existence. Thus when the algorithm stops, the final
matrix An, contains the desired connectivity information.
A one entry indicates a pair of vertices, which are connected and zero entry indicates a
pair, which are not. This matrix is called a reachability matrix or path matrix for the
graph. It is also called the transitive closure of the original adjacency matrix.
The update rule for computing Ai from Ai-1 in warshall’s algorithm is:
Ai [x, y] = Ai-1 [x, y] ۷ (Ai-1 [x, i] ٨ Ai-1 [i, y])

Lecture Notes

196

----

(1)

Dept. of Information Technology

Example 1:
Use warshall’s algorithm to calculate the reachability matrix for the graph:
4
1

4

5

6

7

11
1
2

3
7

We begin with the adjacency matrix of the graph ‘A0’
1 ⎛0
⎜
2 ⎜0
A0 = ⎜
3 0
⎜
4 ⎜⎝1

1

1

0

1

0

0

1

1

0⎞
⎟
1⎟
0⎟
⎟
0 ⎟⎠

The first step is to compute ‘A1’ matrix. To do so we will use the updating rule – (1).
Before doing so, we notice that only one entry in A0 must remain one in A1, since in
Boolean algebra 1 + (anything) = 1. Since these are only nine zero entries in A0, there
are only nine entries in A0 that need to be updated.
A1[1, 1] = A0[1, 1] ۷ (A0[1, 1] ٨ A0[1, 1]) = 0 ۷ (0 ٨ 0) = 0
A1[1, 4] = A0[1, 4] ۷ (A0[1, 1] ٨ A0[1, 4]) = 0 ۷ (0 ٨ 0) = 0
A1[2, 1] = A0[2, 1] ۷ (A0[2, 1] ٨ A0[1, 1]) = 0 ۷ (0 ٨ 0) = 0
A1[2, 2] = A0[2, 2] ۷ (A0[2, 1] ٨ A0[1, 2]) = 0 ۷ (0 ٨ 1) = 0
A1[3, 1] = A0[3, 1] ۷ (A0[3, 1] ٨ A0[1, 1]) = 0 ۷ (0 ٨ 0) = 0
A1[3, 2] = A0[3, 2] ۷ (A0[3, 1] ٨ A0[1, 2]) = 0 ۷ (0 ٨ 1) = 0
A1[3, 3] = A0[3, 3] ۷ (A0[3, 1] ٨ A0[1, 3]) = 0 ۷ (0 ٨ 1) = 0
A1[3, 4] = A0[3, 4] ۷ (A0[3, 1] ٨ A0[1, 4]) = 0 ۷ (0 ٨ 0) = 0
A1[4, 4] = A0[4, 4] ۷ (A0[4, 1] ٨ A0[1, 4]) = 0 ۷ (1 ٨ 0) = 0
1 ⎛0
⎜
2 ⎜0
A1 = ⎜
3 0
⎜
4 ⎜⎝1

1

1

0

1

0

0

1

1

0⎞
⎟
1⎟
0⎟
⎟
0 ⎟⎠

Next, A2 must be calculated from A1; but again we need to update the 0 entries,
A2[1, 1] = A1[1, 1] ۷ (A1[1, 2] ٨ A1[2, 1]) = 0 ۷ (1 ٨ 0) = 0
A2[1, 4] = A1[1, 4] ۷ (A1[1, 2] ٨ A1[2, 4]) = 0 ۷ (1 ٨ 1) = 1
A2[2, 1] = A1[2, 1] ۷ (A1[2, 2] ٨ A1[2, 1]) = 0 ۷ (0 ٨ 0) = 0
A2[2, 2] = A1[2, 2] ۷ (A1[2, 2] ٨ A1[2, 2]) = 0 ۷ (0 ٨ 0) = 0
A2[3, 1] = A1[3, 1] ۷ (A1[3, 2] ٨ A1[2, 1]) = 0 ۷ (0 ٨ 0) = 0
A2[3, 2] = A1[3, 2] ۷ (A1[3, 2] ٨ A1[2, 2]) = 0 ۷ (0 ٨ 0) = 0
Lecture Notes

197

Dept. of Information Technology

A2[3, 3] = A1[3, 3] ۷ (A1[3, 2] ٨ A1[2, 3]) = 0 ۷ (0 ٨ 1) = 0
A2[3, 4] = A1[3, 4] ۷ (A1[3, 2] ٨ A1[2, 4]) = 0 ۷ (0 ٨ 1) = 0
A2[4, 4] = A1[4, 4] ۷ (A1[4, 2] ٨ A1[2, 4]) = 0 ۷ (1 ٨ 1) = 1
1 ⎛0
⎜
2 ⎜0
A2 = ⎜
3 0
⎜
4 ⎜⎝1

1

1

0

1

0

0

1

1

1⎞
⎟
1⎟
0⎟
⎟
1⎟⎠

This matrix has only seven 0 entries, and so to compute A3, we need to do only seven
computations.
A3[1, 1] = A2[1, 1] ۷ (A2[1, 3] ٨ A2[3, 1]) = 0 ۷ (1 ٨ 0) = 0
A3[2, 1] = A2[2, 1] ۷ (A2[2, 3] ٨ A2[3, 1]) = 0 ۷ (1 ٨ 0) = 0
A3[2, 2] = A2[2, 2] ۷ (A2[2, 3] ٨ A2[3, 2]) = 0 ۷ (1 ٨ 0) = 0
A3[3, 1] = A2[3, 1] ۷ (A2[3, 3] ٨ A2[3, 1]) = 0 ۷ (0 ٨ 0) = 0
A3[3, 2] = A2[3, 2] ۷ (A2[3, 3] ٨ A2[3, 2]) = 0 ۷ (0 ٨ 0) = 0
A3[3, 3] = A2[3, 3] ۷ (A2[3, 3] ٨ A2[3, 3]) = 0 ۷ (0 ٨ 0) = 0
A3[3, 4] = A2[3, 4] ۷ (A2[3, 3] ٨ A2[3, 4]) = 0 ۷ (0 ٨ 0) = 0
1 ⎛0
⎜
2 ⎜0
A3 = ⎜
3 0
⎜
4 ⎜⎝1

1

1

0

1

0

0

1

1

1⎞
⎟
1⎟
0⎟
⎟
1 ⎟⎠

Once A3 is calculated, we use the update rule to calculate A4 and stop. This matrix is
the reachability matrix for the graph.
A4[1, 1] = A3 [1, 1] ۷ (A3 [1, 4] ٨ A3 [4, 1]) = 0 ۷ (1 ٨ 1) = 0 ۷ 1 = 1
A4[2, 1] = A3 [2, 1] ۷ (A3 [2, 4] ٨ A3 [4, 1]) = 0 ۷ (1 ٨ 1) = 0 ۷ 1 = 1
A4[2, 2] = A3 [2, 2] ۷ (A3 [2, 4] ٨ A3 [4, 2]) = 0 ۷ (1 ٨ 1) = 0 ۷ 1 = 1
A4[3, 1] = A3 [3, 1] ۷ (A3 [3, 4] ٨ A3 [4, 1]) = 0 ۷ (0 ٨ 1) = 0 ۷ 0 = 0
A4[3, 2] = A3 [3, 2] ۷ (A3 [3, 4] ٨ A3 [4, 2]) = 0 ۷ (0 ٨ 1) = 0 ۷ 0 = 0
A4[3, 3] = A3 [3, 3] ۷ (A3 [3, 4] ٨ A3 [4, 3]) = 0 ۷ (0 ٨ 1) = 0 ۷ 0 = 0
A4[3, 4] = A3 [3, 4] ۷ (A3 [3, 4] ٨ A3 [4, 4]) = 0 ۷ (0 ٨ 1) = 0 ۷ 0 = 0
1 ⎛1
⎜
2 ⎜1
A4 = ⎜
3 0
⎜
4 ⎜⎝1

1

1

1

1

0

0

1

1

1⎞
⎟
1⎟
0⎟
⎟
1⎟⎠

Note that according to the algorithm vertex 3 is not reachable from itself 1. This is
because as can be seen in the graph, there is no path from vertex 3 back to itself.
Lecture Notes

198

Dept. of Information Technology

6.5.

Traversing a Graph

Many graph algorithms require one to systematically examine the nodes and edges of a
graph G. There are two standard ways to do this. They are:
•

Breadth first traversal (BFT)

•

Depth first traversal (DFT)

The BFT will use a queue as an auxiliary structure to hold nodes for future processing
and the DFT will use a STACK.
During the execution of these algorithms, each node N of G will be in one of three
states, called the status of N, as follows:
1. STATUS = 1 (Ready state): The initial state of the node N.
2. STATUS = 2 (Waiting state): The node N is on the QUEUE or STACK, waiting to
be processed.
3. STATUS = 3 (Processed state): The node N has been processed.
Both BFS and DFS impose a tree (the BFS/DFS tree) on the structure of graph. So, we
can compute a spanning tree in a graph. The computed spanning tree is not a
minimum spanning tree. The spanning trees obtained using depth first search are
called depth first spanning trees. The spanning trees obtained using breadth first
search are called Breadth first spanning trees.
6.5.1.

Breadth first search and traversal:

The general idea behind a breadth first traversal beginning at a starting node A is as
follows. First we examine the starting node A. Then we examine all the neighbors of A.
Then we examine all the neighbors of neighbors of A. And so on. We need to keep track
of the neighbors of a node, and we need to guarantee that no node is processed more
than once. This is accomplished by using a QUEUE to hold nodes that are waiting to be
processed, and by using a field STATUS that tells us the current status of any node.
The spanning trees obtained using BFS are called Breadth first spanning trees.
Breadth first traversal algorithm on graph G is as follows:
This algorithm executes a BFT on graph G beginning at a starting node A.
Initialize all nodes to the ready state (STATUS = 1).
1.

Put the starting node A in QUEUE and change its status to the waiting
state (STATUS = 2).

2.

Repeat the following steps until QUEUE is empty:

3.
Lecture Notes

a.

Remove the front node N of QUEUE. Process N and change the
status of N to the processed state (STATUS = 3).

b.

Add to the rear of QUEUE all the neighbors of N that are in the
ready state (STATUS = 1), and change their status to the waiting
state (STATUS = 2).

Exit.
199

Dept. of Information Technology

6.5.2.

Depth first search and traversal:

Depth first search of undirected graph proceeds as follows: First we examine the
starting node V. Next an unvisited vertex 'W' adjacent to 'V' is selected and a depth
first search from 'W' is initiated. When a vertex 'U' is reached such that all its adjacent
vertices have been visited, we back up to the last vertex visited, which has an unvisited
vertex 'W' adjacent to it and initiate a depth first search from W. The search terminates
when no unvisited vertex can be reached from any of the visited ones.
This algorithm is similar to the inorder traversal of binary tree. DFT algorithm is similar
to BFT except now use a STACK instead of the QUEUE. Again field STATUS is used to
tell us the current status of a node.
The algorithm for depth first traversal on a graph G is as follows.
This algorithm executes a DFT on graph G beginning at a starting node A.
1.

Initialize all nodes to the ready state (STATUS = 1).

2. Push the starting node A into STACK and change its status to the waiting state
(STATUS = 2).
3. Repeat the following steps until STACK is empty:
a. Pop the top node N from STACK. Process N and change the status of N to
the processed state (STATUS = 3).
b. Push all the neighbors of N that are in the ready state (STATUS = 1), and
change their status to the waiting state (STATUS = 2).
4. Exit.
Example 1:
Consider the graph shown below. Traverse the graph shown below in breadth first
order and depth first order.

A

F

C

D

B

E

J

G

K
A Gr a p h G

Node

Adjacency List

A

F, C, B

B

A, C, G

C

A, B, D, E, F, G

D

C, F, E, J

E

C, D, G, J, K

F

A, C, D

G

B, C, E, K

J

D, E, K

K

E, G, J
Adjacency list for graph G

Lecture Notes

200

Dept. of Information Technology

Breadth-first search and traversal:
The steps involved in breadth first traversal are as follows:
Current
Node

QUEUE

Processed Nodes

A

Status
A

B

C

D

E

F

G

J

K

1

1

1

1

1

1

1

1

1

2

1

1

1

1

1

1

1

1

A

FCB

A

3

2

2

1

1

2

1

1

1

F

CBD

AF

3

2

2

2

1

3

1

1

1

C

BDEG

AFC

3

2

3

2

2

3

2

1

1

B

DEG

AFCB

3

3

3

2

2

3

2

1

1

D

EGJ

AFCBD

3

3

3

3

2

3

2

2

1

E

GJK

AFCBDE

3

3

3

3

3

3

2

2

2

G

JK

AFCBDEG

3

3

3

3

3

3

3

2

2

J

K

AFCBDEGJ

3

3

3

3

3

3

3

3

2

K

EMPTY

AFCBDEGJK

3

3

3

3

3

3

3

3

3

For the above graph the breadth first traversal sequence is: A F C B D E G J K.
Depth-first search and traversal:
The steps involved in depth first traversal are as follows:
Current
Node

Stack

Processed Nodes

A

Status
A

B

C

D

E

F

G

J

K

1

1

1

1

1

1

1

1

1

2

1

1

1

1

1

1

1

1

A

BCF

A

3

2

2

1

1

2

1

1

1

F

BCD

AF

3

2

2

2

1

3

1

1

1

D

BCEJ

AFD

3

2

2

3

2

3

1

2

1

J

BCEK

AFDJ

3

2

2

3

2

3

1

3

2

K

BCEG

AFDJK

3

2

2

3

2

3

2

3

3

G

BCE

AFDJKG

3

2

2

3

2

3

3

3

3

E

BC

AFDJKGE

3

2

2

3

3

3

3

3

3

C

B

AFDJKGEC

3

2

3

3

3

3

3

3

3

B

EMPTY

AFDJKGECB

3

3

3

3

3

3

3

3

3

For the above graph the depth first traversal sequence is: A F D J K G E C B.

Lecture Notes

201

Dept. of Information Technology

Example 2:
Traverse the graph shown below in breadth first order, depth first order and construct
the breadth first and depth first spanning trees.
A

B

C

H

I

J

K

L

M

Node
Adjacency List
A
F, B, C, G
B
A
C
A, G
D
E, F
E
G, D, F
F
A, E, D
G
A, L, E, H, J, C
H
G, I
I
H
J
G, L, K, M
K
J
L
G, J, M
L, list
J for the graph G
TheM
adjacency

G

D
E
F
The G ra ph G

If the depth first traversal is initiated from vertex A, then the vertices of graph G are
visited in the order: A F E G L J K M H I C D B. The depth first spanning tree is shown
in the figure given below:
A
F

B

E
G
L

H

J

I

K

D
C

M
Depth first Traversal

If the breadth first traversal is initiated from vertex A, then the vertices of graph G are
visited in the order: A F B C G E D L H J M I K. The breadth first spanning tree is
shown in the figure given below:
A
F

E

B

C

D

G

L

H

J

M

I

K

Breadth first traversal

Lecture Notes

202

Dept. of Information Technology

Example 3:
Traverse the graph shown below in breadth first order, depth first order and construct
the breadth first and depth first spanning trees.

1
2

3

4

5

6

7

8
Graph G
He ad Node s

1

2

3

2

1

4

5

3

1

6

7

4

2

8

5

2

8

6

3

8

7

3

8

8

4

5

6

7

A d j a c e n c y l is t f o r g r a p h G

Depth first search and traversal:
If the depth first is initiated from vertex 1, then the vertices of graph G are visited in
the order: 1, 2, 4, 8, 5, 6, 3, 7. The depth first spanning tree is as follows:

1
2
4

3
5

6

7

8
Depth First Spanning Tree

Lecture Notes

203

Dept. of Information Technology

Breadth first search and traversal:
If the breadth first search is initiated from vertex 1, then the vertices of G are visited in
the order: 1, 2, 3, 4, 5, 6, 7, 8. The breadth first spanning tree is as follows:
1
2

3

4

5

6

7

8

Breadth First Spanning Tree

EXCERCISES
1.

Show that the sum of degrees of all vertices in an undirected graph is twice the
number of edges.

2.

Show that the number of vertices of odd degree in a finite graph is even.

3.

How many edges are contained in a complete graph of “n” vertices.

4.

Show that the number of spanning trees in a complete graph of “n” vertices is 2n-1
– 1.

5.

Prove that the edges explored by a breadth first or depth first traversal of a
connected graph from a tree.

6.

Explain how existence of a cycle in an undirected graph may be detected by
traversing the graph in a depth first manner.

7.

Write a “C” function to generate the incidence matrix of a graph from its
adjacency matrix.

8.

Give an example of a connected directed graph so that a depth first traversal of
that graph yields a forest and not a spanning tree of the graph.

9.

Rewrite the algorithms “BFSearch” and “DFSearch” so that it works on adjacency
matrix representation of graphs.

10.

Write a “C” function to find out whether there is a path between any two vertices
in a graph (i.e. to compute the transitive closure matrix of a graph)

11.

Write a “C” function to delete an existing edge from a graph represented by an
adjacency list.

12.

Construct a weighted graph for which the minimal spanning trees produced by
Kruskal’s algorithm and Prim’s algorithm are different.

Lecture Notes

204

Dept. of Information Technology

13.

Describe the algorithm to find a minimum spanning tree T of a weighted graph G.
Find the minimum spanning tree T of the graph shown below.
6

5

A

B

C

1

8

4

2
D

E
3

14.

For the graph given below find the following:
a)
Linked representation of the graph.
b)
Adjacency list.
c)
Depth first spanning tree.
d)
Breadth first spanning tree.
e)
Minimal spanning tree using Kruskal’s and Prim’s algorithms.
8 6
1 1

5 7

2 4

6 2

7 9

3 3

8 10

4 10

15.

9 5

For the graph given below find the following:
f)
Linked representation of the graph.
g)
Adjacency list.
h)
Depth first spanning tree.
i)
Breadth first spanning tree.
j)
Minimal spanning tree using Kruskal’s and Prim’s algorithms.
4

1
2

5

16.

7

3

8

6

For the graph given below find the following:
k)
Linked representation of the graph.
l)
Adjacency list.
m)
Depth first spanning tree.
n)
Breadth first spanning tree.
o)
Minimal spanning tree using Kruskal’s and Prim’s algorithms.
5
1
6
2

4
8
3
7

Lecture Notes

205

Dept. of Information Technology

Multiple Choice Questions
1.

How can the graphs be represented?
A. Adjacency matrix
C. Incidence matrix
B. Adjacency list
D. All of the above

[

D

]

2.

The depth-first traversal in graph is analogous to tree traversal:
A. In-order
C. Pre-order
B. Post-order
D. Level order

[

C

]

3.

The children of a same parent node are called as:
A. adjacent node
C. Sibblings
B. non-leaf node
D. leaf node

[

C

]

4.

Complete graphs with n nodes will have__________ edges.
A. n - 1
C. n(n-1)/2
B. n/2
D. (n – 1)/2

[

C ]

5.

A graph with no cycle is called as:
A. Sub-graph
C. Acyclic graph
B. Directed graph
D. none of the above

[

C ]

6.

The maximum number of nodes at any level is:
A. n
C. n + 1
B. 2n
D. 2n

[

B ]

20

A
23

C
28

36

D

25

9

E

16
3

F

7.

15

4

1

Node

B

17

G

Adjacency List

A

BCD

B

ADE

C

ADF

D

ABCEFG

E

BDG

F

CDG

G

FDE

FIGURE 1 and its adjacency list
For the figure 1 shown above, the depth first spanning tree visiting
sequence is:
A. A B C D E F G
C. A B C D E F G
B. A B D C F G E
D. none of the above

[

B

]

8.

For the figure 1 shown above, the breadth first spanning tree visiting
sequence is:
A. A B D C F G E
C. A B C D E F G
B. A B C D E F G
D. none of the above

[

9.

Which is the correct order for Kruskal’s minimum spanning tree algorithm
to add edges to the minimum spanning tree for the figure 1 shown
above:
A. (A, B) then (A, C) then (A, D) then (D, E) then (C, F) then (D, G)
B. (A, D) then (E, G) then (B, D) then (D, E) then (F, G) then (A, C)
C. both A and B
D. none of the above

[

B

]

10.

For the figure 1 shown above, the cost of the minimal spanning tree is:
A. 57
C. 48
B. 68
D. 32

[

A

]

Lecture Notes

206

B ]

Dept. of Information Technology

11.

A simple graph has no loops. What other property must a simple graph
have?
A. It must be directed.
C. It must have at least one vertex.
B. It must be undirected.
D. It must have no multiple edges.

[

D

]

12.

Suppose you have a directed graph representing all the flights that an
airline flies. What algorithm might be used to find the best sequence of
connections from one city to another?
A. Breadth first search.
C. A cycle-finding algorithm.
B. Depth first search.
D. A shortest-path algorithm.

[

D

]

13.

If G is an directed graph with 20 vertices, how many boolean values will
be needed to represent G using an adjacency matrix?
A. 20
C. 200
B. 40
D. 400

[

14.

Which graph representation allows the most efficient determination of
the existence of a particular edge in a graph?
A. An adjacency matrix.
C. Incidence matrix
B. Edge lists.
D. none of the above

[

B

]

15.

What graph traversal algorithm uses a queue to keep track of vertices
which need to be processed?
A. Breadth-first search.
C Level order search
B. Depth-first search.
D. none of the above

[

A

]

16.

What graph traversal algorithm uses a stack to keep track of vertices
which need to be processed?
A. Breadth-first search.
C Level order search
B. Depth-first search.
D. none of the above

[

B ]

17.

What is the expected number of operations needed to loop through all
the edges terminating at a particular vertex given an adjacency matrix
representation of the graph? (Assume n vertices are in the graph and m
edges terminate at the desired node.)
A. O(m)
C. O(m²)
B. O(n)
D. O(n²)

[

D ]

18.

What is the expected number of operations needed to loop through all
the edges terminating at a particular vertex given an adjacency list
representation of the graph? (Assume n vertices are in the graph and m
edges terminate at the desired node.)
A. O(m)
C. O(m²)
B. O(n)
D. O(n²)

[

A

]

[

B

]

19.

3

A
1

2
B

3

1
C

D
5

5
4

G
4

E

6
3

D ]

FIGURE 3

1
F

For the figure 3, starting at vertex A, which is a correct order for Prim’s
minimum spanning tree algorithm to add edges to the minimum
spanning tree?
Lecture Notes

207

Dept. of Information Technology

A. (A, G) then (G, C) then (C, B) then (C, F) then (F, E) then (E, D)
B. (A, G) then (A, B) then (B, C) then (A, D) then (C, F) then (F, E)
C. (A, G) then (B, C) then (E, F) then (A, B) then (C, F) then (D, E)
D. (A, G) then (A, B) then (A, C) then (A, D) then (A, D) then (C, F)
20.

For the figure 3, which is a correct order for Kruskal’s minimum spanning
tree algorithm to add edges to the minimum spanning tree?
A. (A, G) then (G, C) then (C, B) then (C, F) then (F, E) then (E, D)
B. (A, G) then (A, B) then (B, C) then (A, D) then (C, F) then (F, E)
C. (A, G) then (B, C) then (E, F) then (A, B) then (C, F) then (D, E)
D. (A, G) then (A, B) then (A, C) then (A, D) then (A, D) then (C, F)

[

21.

Which algorithm does not construct an in-tree as part of its processing?
A. Dijkstra’s Shortest Path Algorithm
B. Prim’s Minimum Spanning Tree Algorithm
C. Kruskal’s Minimum Spanning Tree Algorithm
D. The Depth-First Search Trace Algorithm

[

]

22.

The worst-case running time of Kruskal’s minimum-cost spanning tree
algorithm on a graph with n vertices and m edges is:
A.
C.
B.
D.

[

]

23.

An adjacency matrix representation of a graph cannot contain
information of:
A. Nodes
C. Direction of edges
B. Edges
D. Parallel edges

[

D

]

A

B

Node

D

G

F
C

]

Adjacency List

A

D

B

AC

C

GDF

D

----

E

E

C

CD

F

EA

G

B

FIGURE 4 and its adjacency list
24.

For the figure 4, which edge does not occur in the depth first spanning
tree resulting from depth first search starting at node B:
A. F → E
C. C → G
B. E → C
D. C → F

[

B

]

25.

The set of all edges generated by DFS tree starting at node B is:
A. B A D C G F E
C. B A C D G F E
B. A D
D. Cannot be generated

[

A

]

26.

The set of all edges generated by BFS tree starting at node B is:
A. B A D C G F E
C. B A C D G F E
B. A D
D. Cannot be generated

[

C

]

Lecture Notes

208

Dept. of Information Technology

Chapter

7

Searching and Sorting
There are basically two aspects of computer programming. One is data
organization also commonly called as data structures. Till now we have seen
about data structures and the techniques and algorithms used to access
them. The other part of computer programming involves choosing the
appropriate algorithm to solve the problem. Data structures and algorithms
are linked each other. After developing programming techniques to represent
information, it is logical to proceed to manipulate it. This chapter introduces
this important aspect of problem solving.

Searching is used to find the location where an element is available. There are two
types of search techniques. They are:
1.

Linear or sequential search

2.

Binary search

Sorting allows an efficient arrangement of elements within a given data structure. It is
a way in which the elements are organized systematically for some purpose. For
example, a dictionary in which words is arranged in alphabetical order and telephone
director in which the subscriber names are listed in alphabetical order. There are many
sorting techniques out of which we study the following.
1.

Bubble sort

2.

Quick sort

3.

Selection sort and

4.

Heap sort

There are two types of sorting techniques:
1.

Internal sorting

2.

External sorting

If all the elements to be sorted are present in the main memory then such sorting is
called internal sorting on the other hand, if some of the elements to be sorted are
kept on the secondary storage, it is called external sorting. Here we study only
internal sorting techniques.
7.1.

Linear Search:

This is the simplest of all searching techniques. In this technique, an ordered or
unordered list will be searched one by one from the beginning until the desired element
is found. If the desired element is found in the list then the search is successful
otherwise unsuccessful.
Lecture Notes

209

Dept. of Information Technology

Suppose there are ‘n’ elements organized sequentially on a List. The number of
comparisons required to retrieve an element from the list, purely depends on where the
element is stored in the list. If it is the first element, one comparison will do; if it is
second element two comparisons are necessary and so on. On an average you need
[(n+1)/2] comparison’s to search an element. If search is not successful, you would
need ’n’ comparisons.
The time complexity of linear search is O(n).
Algorithm:
Let array a[n] stores n elements. Determine whether element ‘x’ is present or not.
linsrch(a[n], x)
{
index = 0;
flag = 0;
while (index < n) do
{
if (x == a[index])
{
flag = 1;
break;
}
index ++;
}
if(flag == 1)
printf(“Data found at %d position“, index);
else
printf(“data not found”);
}
Example 1:
Suppose we have the following unsorted list: 45, 39, 8, 54, 77, 38, 24, 16, 4, 7, 9, 20
If we are searching for:

45, we’ll look at 1 element before success
39, we’ll look at 2 elements before success
8, we’ll look at 3 elements before success
54, we’ll look at 4 elements before success
77, we’ll look at 5 elements before success
38 we’ll look at 6 elements before success
24, we’ll look at 7 elements before success
16, we’ll look at 8 elements before success
4, we’ll look at 9 elements before success
7, we’ll look at 10 elements before success
9, we’ll look at 11 elements before success
20, we’ll look at 12 elements before success

For any element not in the list, we’ll look at 12 elements before failure.

Lecture Notes

210

Dept. of Information Technology

Example 2:
Let us illustrate linear search on the following 9 elements:
Index
Elements

0
-15

1
-6

2
0

3
7

4
9

5
23

6
54

7
82

8
101

Searching different elements is as follows:
1. Searching for x = 7

Search successful, data found at 3rd position.

2. Searching for x = 82

Search successful, data found at 7th position.

3. Searching for x = 42

Search un-successful, data not found.

7.1.1.

A non-recursive program for Linear Search:

# include <stdio.h>
# include <conio.h>
main()
{

int number[25], n, data, i, flag = 0;
clrscr();
printf("\n Enter the number of elements: ");
scanf("%d", &n);
printf("\n Enter the elements: ");
for(i = 0; i < n; i++)
scanf("%d", &number[i]);
printf("\n Enter the element to be Searched: ");
scanf("%d", &data);
for( i = 0; i < n; i++)
{
if(number[i] == data)
{
flag = 1;
break;
}
}
if(flag == 1)
printf("\n Data found at location: %d", i+1);
else
printf("\n Data not found ");

}

7.1.2.

A Recursive program for linear search:

# include <stdio.h>
# include <conio.h>
void linear_search(int a[], int data, int position, int n)
{
if(position < n)
Lecture Notes

211

Dept. of Information Technology

{
if(a[position] == data)
printf("\n Data Found at %d ", position);
else
linear_search(a, data, position + 1, n);
}
else
printf("\n Data not found");

}

void main()
{
int a[25], i, n, data;
clrscr();
printf("\n Enter the number of elements: ");
scanf("%d", &n);
printf("\n Enter the elements: ");
for(i = 0; i < n; i++)
{
scanf("%d", &a[i]);
}
printf("\n Enter the element to be seached: ");
scanf("%d", &data);
linear_search(a, data, 0, n);
getch();
}

7.2.

BINARY SEARCH

If we have ‘n’ records which have been ordered by keys so that x1 < x2 < … < xn . When
we are given a element ‘x’, binary search is used to find the corresponding element
from the list. In case ‘x’ is present, we have to determine a value ‘j’ such that a[j] = x
(successful search). If ‘x’ is not in the list then j is to set to zero (un successful search).
In Binary search we jump into the middle of the file, where we find key a[mid], and
compare ‘x’ with a[mid]. If x = a[mid] then the desired record has been found.
If x < a[mid] then ‘x’ must be in that portion of the file that precedes a[mid]. Similarly,
if a[mid] > x, then further search is only necessary in that part of the file which follows
a[mid].
If we use recursive procedure of finding the middle key a[mid] of the un-searched
portion of a file, then every un-successful comparison of ‘x’ with a[mid] will eliminate
roughly half the un-searched portion from consideration.
Since the array size is roughly halved after each comparison between ‘x’ and a[mid],
and since an array of length ‘n’ can be halved only about log2n times before reaching a
trivial length, the worst case complexity of Binary search is about log2n.
Algorithm:
Let array a[n] of elements in increasing order, n ≥ 0, determine whether ‘x’ is present,
and if so, set j such that x = a[j] else return 0.

Lecture Notes

212

Dept. of Information Technology

binsrch(a[], n, x)
{
low = 1; high = n;
while (low < high) do
{
mid = ⎣ (low + high)/2 ⎦
if (x < a[mid])
high = mid – 1;
else if (x > a[mid])
low = mid + 1;
else return mid;
}
return 0;
}
low and high are integer variables such that each time through the loop either ‘x’ is
found or low is increased by at least one or high is decreased by at least one. Thus we
have two sequences of integers approaching each other and eventually low will become
greater than high causing termination in a finite number of steps if ‘x’ is not present.
Example 1:
Let us illustrate binary search on the following 12 elements:
Index
Elements

1
4

2
7

3
8

4
9

5
16

6
20

7
24

8
38

9
39

10
45

11
54

12
77

If we are searching for x = 4: (This needs 3 comparisons)
low = 1, high = 12, mid = 13/2 = 6, check 20
low = 1, high = 5, mid = 6/2 = 3, check 8
low = 1, high = 2, mid = 3/2 = 1, check 4, found
If we are searching for x = 7: (This needs 4 comparisons)
low = 1, high = 12, mid = 13/2 = 6, check 20
low = 1, high = 5, mid = 6/2 = 3, check 8
low = 1, high = 2, mid = 3/2 = 1, check 4
low = 2, high = 2, mid = 4/2 = 2, check 7, found
If we are searching for x = 8: (This needs 2 comparisons)
low = 1, high = 12, mid = 13/2 = 6, check 20
low = 1, high = 5, mid = 6/2 = 3, check 8, found
If we are searching for x = 9: (This needs 3 comparisons)
low = 1, high = 12, mid = 13/2 = 6, check 20
low = 1, high = 5, mid = 6/2 = 3, check 8
low = 4, high = 5, mid = 9/2 = 4, check 9, found
If we are searching for x = 16: (This needs 4 comparisons)
low = 1, high = 12, mid = 13/2 = 6, check 20
low = 1, high = 5, mid = 6/2 = 3, check 8
low = 4, high = 5, mid = 9/2 = 4, check 9
low = 5, high = 5, mid = 10/2 = 5, check 16, found
If we are searching for x = 20: (This needs 1 comparison)
low = 1, high = 12, mid = 13/2 = 6, check 20, found
Lecture Notes

213

Dept. of Information Technology

If we are searching for x = 24: (This needs 3 comparisons)
low = 1, high = 12, mid = 13/2 = 6, check 20
low = 7, high = 12, mid = 19/2 = 9, check 39
low = 7, high = 8, mid = 15/2 = 7, check 24, found
If we are searching for x = 38: (This needs 4 comparisons)
low = 1, high = 12, mid = 13/2 = 6, check 20
low = 7, high = 12, mid = 19/2 = 9, check 39
low = 7, high = 8, mid = 15/2 = 7, check 24
low = 8, high = 8, mid = 16/2 = 8, check 38, found
If we are searching for x = 39: (This needs 2 comparisons)
low = 1, high = 12, mid = 13/2 = 6, check 20
low = 7, high = 12, mid = 19/2 = 9, check 39, found
If we are searching for x = 45: (This needs 4 comparisons)
low = 1, high = 12, mid = 13/2 = 6, check 20
low = 7, high = 12, mid = 19/2 = 9, check 39
low = 10, high = 12, mid = 22/2 = 11, check 54
low = 10, high = 10, mid = 20/2 = 10, check 45, found
If we are searching for x = 54: (This needs 3 comparisons)
low = 1, high = 12, mid = 13/2 = 6, check 20
low = 7, high = 12, mid = 19/2 = 9, check 39
low = 10, high = 12, mid = 22/2 = 11, check 54, found
If we are searching for x = 77: (This needs 4 comparisons)
low = 1, high = 12, mid = 13/2 = 6, check 20
low = 7, high = 12, mid = 19/2 = 9, check 39
low = 10, high = 12, mid = 22/2 = 11, check 54
low = 12, high = 12, mid = 24/2 = 12, check 77, found
The number of comparisons necessary by search element:
20 – requires 1 comparison;
8 and 39 – requires 2 comparisons;
4, 9, 24, 54 – requires 3 comparisons and
7, 16, 38, 45, 77 – requires 4 comparisons
Summing the comparisons, needed to find all twelve items and dividing by 12, yielding
37/12 or approximately 3.08 comparisons per successful search on the average.
Example 2:
Let us illustrate binary search on the following 9 elements:
Index
Elements

0
-15

1
-6

2
0

3
7

4
9

5
23

6
54

7
82

8
101

Solution:
The number of comparisons required for searching different elements is as follows:

Lecture Notes

214

Dept. of Information Technology

1. If we are searching for x = 101: (Number of comparisons = 4)
low
high mid
1
9
5
6
9
7
8
9
8
9
9
9
found
2. Searching for x = 82: (Number of comparisons = 3)
low
high mid
1
9
5
6
9
7
8
9
8
found
3. Searching for x = 42: (Number of comparisons = 4)
low
high mid
1
9
5
6
9
7
6
6
6
7
6 not found
4. Searching for x = -14: (Number of comparisons = 3)
low
high mid
1
9
5
1
4
2
1
1
1
2
1 not found
Continuing in this manner the number of element comparisons needed to find each of
nine elements is:
Index
Elements
Comparisons

1
-15
3

2
-6
2

3
0
3

4
7
4

5
9
1

6
23
3

7
54
2

8
82
3

9
101
4

No element requires more than 4 comparisons to be found. Summing the comparisons
needed to find all nine items and dividing by 9, yielding 25/9 or approximately 2.77
comparisons per successful search on the average.
There are ten possible ways that an un-successful search may terminate depending
upon the value of x.
If x < a(1), a(1) < x < a(2), a(2) < x < a(3), a(5) < x < a(6), a(6) < x < a(7) or a(7)
< x < a(8) the algorithm requires 3 element comparisons to determine that ‘x’ is not
present. For all of the remaining possibilities BINSRCH requires 4 element comparisons.
Thus the average number of element comparisons for an unsuccessful search is:
(3 + 3 + 3 + 4 + 4 + 3 + 3 + 3 + 4 + 4) / 10 = 34/10 = 3.4

Time Complexity:
The time complexity of binary search in a successful search is O(log n) and for an
unsuccessful search is O(log n).
Lecture Notes

215

Dept. of Information Technology

7.2.1.

A non-recursive program for binary search:

# include <stdio.h>
# include <conio.h>
main()
{
int number[25], n, data, i, flag = 0, low, high, mid;
clrscr();
printf("\n Enter the number of elements: ");
scanf("%d", &n);
printf("\n Enter the elements in ascending order: ");
for(i = 0; i < n; i++)
scanf("%d", &number[i]);
printf("\n Enter the element to be searched: ");
scanf("%d", &data);
low = 0; high = n-1;
while(low <= high)
{
mid = (low + high)/2;
if(number[mid] == data)
{
flag = 1;
break;
}
else
{
if(data < number[mid])
high = mid - 1;
else
low = mid + 1;
}
}
if(flag == 1)
printf("\n Data found at location: %d", mid + 1);
else
printf("\n Data Not Found ");
}
7.2.2.

A recursive program for binary search:

# include <stdio.h>
# include <conio.h>
void bin_search(int a[], int data, int low, int high)
{
int mid ;
if( low <= high)
{
mid = (low + high)/2;
if(a[mid] == data)
printf("\n Element found at location: %d ", mid + 1);
else
{
if(data < a[mid])
bin_search(a, data, low, mid-1);
else
Lecture Notes

216

Dept. of Information Technology

bin_search(a, data, mid+1, high);
}
else

}

printf("\n Element not found");
}
void main()
{
int a[25], i, n, data;
clrscr();
printf("\n Enter the number of elements: ");
scanf("%d", &n);
printf("\n Enter the elements in ascending order: ");
for(i = 0; i < n; i++)
scanf("%d", &a[i]);
printf("\n Enter the element to be searched: ");
scanf("%d", &data);
bin_search(a, data, 0, n-1);
getch();
}
7.3.

Bubble Sort:

The bubble sort is easy to understand and program. The basic idea of bubble sort is to
pass through the file sequentially several times. In each pass, we compare each
element in the file with its successor i.e., X[i] with X[i+1] and interchange two element
when they are not in proper order. We will illustrate this sorting technique by taking a
specific example. Bubble sort is also called as exchange sort.
Example:
Consider the array x[n] which is stored in memory as shown below:
X[0]

X[1]

X[2]

X[3]

X[4]

X[5]

33

44

22

11

66

55

Suppose we want our array to be stored in ascending order. Then we pass through the
array 5 times as described below:
Pass 1: (first element is compared with all other elements).
We compare X[i] and X[i+1] for i = 0, 1, 2, 3, and 4, and interchange X[i] and X[i+1]
if X[i] > X[i+1]. The process is shown below:
X[0]

X[1]

X[2]

X[3]

X[4]

X[5]

33

44

22

11

66

55

22

44
11

44
44

33

22

11

Remarks

44

66
55

66

55

66

The biggest number 66 is moved to (bubbled up) the right most position in the array.
Lecture Notes

217

Dept. of Information Technology

Pass 2: (second element is compared).
We repeat the same process, but this time we don’t include X[5] into our comparisons.
i.e., we compare X[i] with X[i+1] for i=0, 1, 2, and 3 and interchange X[i] and X[i+1]
if X[i] > X[i+1]. The process is shown below:
X[0]

X[1]

X[2]

X[3]

X[4]

33

22

11

44

55

22

33
11

33
33

22

Remarks

11

44

33

44

55

44

55

The second biggest number 55 is moved now to X[4].
Pass 3: (third element is compared).
We repeat the same process, but this time we leave both X[4] and X[5]. By doing this,
we move the third biggest number 44 to X[3].
X[0]

X[1]

X[2]

X[3]

22

11

33

44

11

22
22

11

Remarks

33

22

33

44

33

44

Pass 4: (fourth element is compared).
We repeat the process leaving X[3], X[4], and X[5]. By doing this, we move the fourth
biggest number 33 to X[2].
X[0]

X[1]

X[2]

11

22

33

11

22
22

Remarks

33

Pass 5: (fifth element is compared).
We repeat the process leaving X[2], X[3], X[4], and X[5]. By doing this, we move the
fifth biggest number 22 to X[1]. At this time, we will have the smallest number 11 in
X[0]. Thus, we see that we can sort the array of size 6 in 5 passes.
For an array of size n, we required (n-1) passes.
Lecture Notes

218

Dept. of Information Technology

7.3.1.

Program for Bubble Sort:

#include <stdio.h>
#include <conio.h>
void bubblesort(int x[], int n)
{
int i, j, temp;
for (i = 0; i < n; i++)
{
for (j = 0; j < n–i-1 ; j++)
{
if (x[j] > x[j+1])
{
temp = x[j];
x[j] = x[j+1];
x[j+1] = temp;
}
}
}
}
main()
{
int i, n, x[25];
clrscr();
printf("\n Enter the number of elements: ");
scanf("%d", &n);
printf("\n Enter Data:");
for(i = 0; i < n ; i++)
scanf("%d", &x[i]);
bubblesort(x, n);
printf ("\n Array Elements after sorting: ");
for (i = 0; i < n; i++)
printf ("%5d", x[i]);
}
Time Complexity:
The bubble sort method of sorting an array of size n requires (n-1) passes and (n-1)
comparisons on each pass. Thus the total number of comparisons is (n-1) * (n-1) = n2
– 2n + 1, which is O(n2). Therefore bubble sort is very inefficient when there are more
elements to sorting.
7.4.

Selection Sort:

Selection sort will not require no more than n-1 interchanges. Suppose x is an array of
size n stored in memory. The selection sort algorithm first selects the smallest element
in the array x and place it at array position 0; then it selects the next smallest element
in the array x and place it at array position 1. It simply continues this procedure until it
places the biggest element in the last position of the array.
The array is passed through (n-1) times and the smallest element is placed in its
respective position in the array as detailed below:

Lecture Notes

219

Dept. of Information Technology

Pass 1: Find the location j of the smallest element in the array x [0], x[1], . . . . x[n-1],
and then interchange x[j] with x[0]. Then x[0] is sorted.
Pass 2: Leave the first element and find the location j of the smallest element in the
sub-array x[1], x[2], . . . . x[n-1], and then interchange x[1] with x[j]. Then
x[0], x[1] are sorted.
Pass 3: Leave the first two elements and find the location j of the smallest element in
the sub-array x[2], x[3], . . . . x[n-1], and then interchange x[2] with x[j].
Then x[0], x[1], x[2] are sorted.
Pass (n-1): Find the location j of the smaller of the elements x[n-2] and x[n-1], and
then interchange x[j] and x[n-2]. Then x[0], x[1], . . . . x[n-2] are sorted. Of
course, during this pass x[n-1] will be the biggest element and so the entire
array is sorted.
Time Complexity:
In general we prefer selection sort in case where the insertion sort or the bubble sort
requires exclusive swapping. In spite of superiority of the selection sort over bubble
sort and the insertion sort (there is significant decrease in run time), its efficiency is
also O(n2) for n data items.
Example:
Let us consider the following example with 9 elements to analyze selection Sort:
1

2

3

4

5

6

7

8

9

Remarks

65

70

75

80

50

60

55

85

45

find the first smallest element

j

swap a[i] & a[j]

65

find the second smallest element

i
45

70

75

80

i
45

50

50

60

55

j
75

80

70

swap a[i] and a[j]
60

55

i
45

50

55

50

55

85

80

70

60

60

75

85

50

55

60

80

65

80

50

55

60

65

70

75

75

75
i

45

45

50

50

Lecture Notes

55

55

60

60

65

65

70

70

Find the fourth smallest element
swap a[i] and a[j]

85

85

i
45

65

j
70

Find the third smallest element
swap a[i] and a[j]

i
45

65

j

i
45

85

85

65

Find the fifth smallest element

j

swap a[i] and a[j]

70

Find the sixth smallest element

j

swap a[i] and a[j]

80

Find the seventh smallest element

j

75

75

swap a[i] and a[j]
85

80

Find the eighth smallest element

i

J

swap a[i] and a[j]

80

85

The outer loop ends.

220

Dept. of Information Technology

7.4.1.

Non-recursive Program for selection sort:

# include<stdio.h>
# include<conio.h>
void selectionSort( int low, int high );
int a[25];
int main()
{
int num, i= 0;
clrscr();
printf( "Enter the number of elements: " );
scanf("%d", &num);
printf( "\nEnter the elements:\n" );
for(i=0; i < num; i++)
scanf( "%d", &a[i] );
selectionSort( 0, num - 1 );
printf( "\nThe elements after sorting are: " );
for( i=0; i< num; i++ )
printf( "%d ", a[i] );
return 0;
}
void selectionSort( int low, int high )
{
int i=0, j=0, temp=0, minindex;
for( i=low; i <= high; i++ )
{
minindex = i;
for( j=i+1; j <= high; j++ )
{
if( a[j] < a[minindex] )
minindex = j;
}
temp = a[i];
a[i] = a[minindex];
a[minindex] = temp;
}
}
7.4.2.

Recursive Program for selection sort:

#include <stdio.h>
#include<conio.h>
int x[6] = {77, 33, 44, 11, 66};
selectionSort(int);
main()
{

int i, n = 0;
clrscr();
printf (" Array Elements before sorting: ");
for (i=0; i<5; i++)

Lecture Notes

221

Dept. of Information Technology

printf ("%d ", x[i]);
selectionSort(n);
/* call selection sort */
printf ("\n Array Elements after sorting: ");
for (i=0; i<5; i++)
printf ("%d ", x[i]);
}
selectionSort( int n)
{
int k, p, temp, min;
if (n== 4)
return (-1);
min = x[n];
p = n;
for (k = n+1; k<5; k++)
{
if (x[k] <min)
{
min = x[k];
p = k;
}
}
temp = x[n];
/* interchange x[n] and x[p] */
x[n] = x[p];
x[p] = temp;
n++ ;
selectionSort(n);
}
7.5.

Quick Sort:

The quick sort was invented by Prof. C. A. R. Hoare in the early 1960’s. It was one of
the first most efficient sorting algorithms. It is an example of a class of algorithms that
work by “divide and conquer” technique.
The quick sort algorithm partitions the original array by rearranging it into two groups.
The first group contains those elements less than some arbitrary chosen value taken
from the set, and the second group contains those elements greater than or equal to
the chosen value. The chosen value is known as the pivot element. Once the array has
been rearranged in this way with respect to the pivot, the same partitioning procedure
is recursively applied to each of the two subsets. When all the subsets have been
partitioned and rearranged, the original array is sorted.
The function partition() makes use of two pointers up and down which are moved
toward each other in the following fashion:
1.

Repeatedly increase the pointer ‘up’ until a[up] >= pivot.

2.

Repeatedly decrease the pointer ‘down’ until a[down] <= pivot.

3.

If down > up, interchange a[down] with a[up]

4.

Repeat the steps 1, 2 and 3 till the ‘up’ pointer crosses the ‘down’ pointer. If
‘up’ pointer crosses ‘down’ pointer, the position for pivot is found and place
pivot element in ‘down’ pointer position.

Lecture Notes

222

Dept. of Information Technology

The program uses a recursive function quicksort(). The algorithm of quick sort function
sorts all elements in an array ‘a’ between positions ‘low’ and ‘high’.
1.

It terminates when the condition low >= high is satisfied. This condition will
be satisfied only when the array is completely sorted.

2.

Here we choose the first element as the ‘pivot’. So, pivot = x[low]. Now it
calls the partition function to find the proper position j of the element x[low]
i.e. pivot. Then we will have two sub-arrays x[low], x[low+1], . . . . . . x[j-1]
and x[j+1], x[j+2], . . . x[high].

3.

It calls itself recursively to sort the left sub-array x[low], x[low+1], . . . . . . .
x[j-1] between positions low and j-1 (where j is returned by the partition
function).

4.

It calls itself recursively to sort the right sub-array x[j+1], x[j+2], . . x[high]
between positions j+1 and high.

The time complexity of quick sort algorithm is of O(n log n).

Algorithm
Sorts the elements a[p], . . . . . ,a[q] which reside in the global array a[n] into
ascending order. The a[n + 1] is considered to be defined and must be greater than all
elements in a[n]; a[n + 1] = + ∝
quicksort (p, q)
{
if ( p < q ) then
{
call j = PARTITION(a, p, q+1);
call quicksort(p, j – 1);
call quicksort(j + 1 , q);
}
}
partition(a, m, p)
{
v = a[m]; up = m; down = p;
do
{
repeat
up = up + 1;
until (a[up] > v);

// j is the position of the partitioning element

// a[m] is the partition element

repeat

down = down – 1;
until (a[down] < v);
if (up < down) then call interchange(a, up, down);
} while (up > down);
a[m] = a[down];
a[down] = v;
return (down);
}
Lecture Notes

223

Dept. of Information Technology

interchange(a, up, down)
{
p = a[up];
a[up] = a[down];
a[down] = p;
}
Example:
Select first element as the pivot element. Move ‘up’ pointer from left to right in search
of an element larger than pivot. Move the ‘down’ pointer from right to left in search of
an element smaller than pivot. If such elements are found, the elements are swapped.
This process continues till the ‘up’ pointer crosses the ‘down’ pointer. If ‘up’ pointer
crosses ‘down’ pointer, the position for pivot is found and interchange pivot and
element at ‘down’ position.
Let us consider the following example with 13 elements to analyze quick sort:
1

2

3

4

5

6

7

8

9

10

11

12

13

38

08

16

06

79

57

24

56

02

58

04

70

45

pivot

up

down

pivot

04

79

pivot

up

down

pivot

02

57

pivot
(24

08

16

06

04

pivot
(02
pivot,
down
02

08

16

06

04)

down

up

02)

38

(56

down

up

swap up &
down
swap pivot
& down

57

58

79

70

45)

24
swap pivot
& down

(08

16

pivot

up

pivot

04

pivot
04)

pivot down
(04)

swap up &
down

swap pivot
& down

up

(06

Remarks

06

04)
swap up &
down

down
16
down

Up

08

(16)

swap pivot
& down

up
swap pivot
& down

06

04
pivot,
down,
up
16
pivot,
down,
up
(02

04

Lecture Notes

06

08

16

24)

38
224

Dept. of Information Technology

(56

57

58

pivot

up

down

pivot

45

57

pivot down

up

(45)
45
pivot,
down,
up

(58

56

79

70

45)
swap up &
down
swap pivot
& down

79

70

57)
swap pivot
& down

(58
pivot

(57)

79
up
57

70

57) swap up &
down
down
79

down

up

58

(70

79)

(70
pivot,
down
70

79)

swap pivot
& down

57
pivot,
down,
up
up

swap pivot
& down

79
pivot,
down,
up

02

04

7.5.1.

06

08

16

24

38

(45

56

57

58

70

79)

45

56

57

58

70

79

Recursive program for Quick Sort:

# include<stdio.h>
# include<conio.h>
void quicksort(int, int);
int partition(int, int);
void interchange(int, int);
int array[25];
int main()
{
int num, i = 0;
clrscr();
printf( "Enter the number of elements: " );
scanf( "%d", &num);
printf( "Enter the elements: " );
for(i=0; i < num; i++)
scanf( "%d", &array[i] );
quicksort(0, num -1);
printf( "\nThe elements after sorting are: " );
Lecture Notes

225

Dept. of Information Technology

for(i=0; i < num; i++)
printf("%d ", array[i]);
return 0;
}
void quicksort(int low, int high)
{
int pivotpos;
if( low < high )
{
pivotpos = partition(low, high + 1);
quicksort(low, pivotpos - 1);
quicksort(pivotpos + 1, high);
}
}
int partition(int low, int high)
{
int pivot = array[low];
int up = low, down = high;
do
{
do

up = up + 1;
while(array[up] < pivot );

do
down = down - 1;
while(array[down] > pivot);
if(up < down)
interchange(up, down);

}

} while(up < down);
array[low] = array[down];
array[down] = pivot;
return down;

void interchange(int i, int j)
{
int temp;
temp = array[i];
array[i] = array[j];
array[j] = temp;
}

Lecture Notes

226

Dept. of Information Technology

7.6.

Priority Queue, Heap and Heap Sort:

Heap is a data structure, which permits one to insert elements into a set and also to
find the largest element efficiently. A data structure, which provides these two
operations, is called a priority queue.
7.6.1.

Max and Min Heap data structures:

A max heap is an almost complete binary tree such that the value of each node is
greater than or equal to those in its children.
95

15

85
75
55

45
25

65

45

35

15

55
85

Max heap

25
65

35

75

Min heap

95

A min heap is an almost complete binary tree such that the value of each node is less
than or equal to those in its children.

7.6.2.

Representation of Heap Tree:

Since heap is a complete binary tree, a heap tree can be efficiently represented using
one dimensional array. This provides a very convenient way of figuring out where
children belong to.
•

The root of the tree is in location 1.

•

The left child of an element stored at location i can be found in location 2*i.

•

The right child of an element stored at location i can be found in location 2*i+1.

•

The parent of an element stored at location i can be found at location floor(i/2).

The elements of the array can be thought of as lying in a tree structure. A heap tree
represented using a single array looks as follows:
X[1]

X[2]

X[3]

X[4]

X[5]

X[6]

X[7]

X[8]

65

45

60

40

25

50

55

30

x[ 1]
x[ 2]

x[ 4]

x[ 8]

Lecture Notes

30

65

x[ 3]
60

45

x[ 7]

x[ 6]
40

x[ 5] 2 5

50

55

He a p T r e e

227

Dept. of Information Technology

7.6.3.

Operations on heap tree:

The major operations required to be performed on a heap tree:
1.

Insertion,

2.

Deletion and

3.

Merging.

Insertion into a heap tree:
This operation is used to insert a node into an existing heap tree satisfying the
properties of heap tree. Using repeated insertions of data, starting from an empty heap
tree, one can build up a heap tree.
Let us consider the heap (max) tree. The principle of insertion is that, first we have to
adjoin the data in the complete binary tree. Next, we have to compare it with the data
in its parent; if the value is greater than that at parent then interchange the values.
This will continue between two nodes on path from the newly inserted node to the root
node till we get a parent whose value is greater than its child or we reached the root.
For illustration, 35 is added as the right child of 80. Its value is compared with its
parent’s value, and to be a max heap, parent’s value greater than child’s value is
satisfied, hence interchange as well as further comparisons are no more required.
As another illustration, let us consider the case of insertion 90 into the resultant heap
tree. First, 90 will be added as left child of 40, when 90 is compared with 40 it requires
interchange. Next, 90 is compared with 80, another interchange takes place. Now, our
process stops here, as 90 is now in root node. The path on which these comparisons
and interchanges have taken places are shown by dashed line.
The algorithm Max_heap_insert to insert a data into a max heap tree is as follows:
Max_heap_insert (a, n)
{
//inserts the value in a[n] into the heap which is stored at a[1] to a[n-1]
int i, n;
i = n;
item = a[n];
while ( (i > 1) and (a[ ⎣ i/2 ⎦ ] < item ) do
{
a[i] = a[ ⎣ i/2 ⎦ ] ;
// move the parent down
i = ⎣ i/2 ⎦ ;
}
a[i] = item ;
return true ;
}
Example:
Form a heap using the above algorithm for the data: 40, 80, 35, 90, 45, 50, 70.
1.

Insert 40:
40

Lecture Notes

228

Dept. of Information Technology

2.

Insert 80:
80
40

40

80

80

3.

40

Insert 35:
80
40

4.

35

Insert 90:
90
80

80

90

90
40

35

80

35

40
40

90

5.

Insert 45:
90
80
40

6.

35
45

Insert 50:
90
80
40

7.

90

50
35
50

45

80

50

35
40

45

35

Insert 70:
90

90
70

80

50

70

80
50

40

Lecture Notes

45

35

70

40

229

45

35

50

Dept. of Information Technology

Deletion of a node from heap tree:
Any node can be deleted from a heap tree. But from the application point of view,
deleting the root node has some special importance. The principle of deletion is as
follows:
•

Read the root node into a temporary storage say, ITEM.

•

Replace the root node by the last node in the heap tree. Then re-heap the
tree as stated below:
•

Let newly modified root node be the current node. Compare its value
with the value of its two child. Let X be the child whose value is the
largest. Interchange the value of X with the value of the current
node.

•

Make X as the current node.

•

Continue re-heap, if the current node is not an empty node.

The algorithm for the above is as follows:
delmax (a, n, x)
// delete the maximum from the heap a[n] and store it in x
{
if (n = 0) then
{
write (“heap is empty”);
return false;
}
x = a[1]; a[1] = a[n];
adjust (a, 1, n-1);
return true;
}
adjust (a, i, n)
// The complete binary trees with roots a(2*i) and a(2*i + 1) are combined with a(i) to
form a single heap, 1 < i < n. No node has an address greater than n or less than 1. //
{
j = 2 *i ;
item = a[i] ;
while (j < n) do
{
if ((j < n) and (a (j) < a (j + 1)) then j Å j + 1;
// compare left and right child and let j be the larger child
if (item > a (j)) then break;
// a position for item is found
else a[ ⎣ j / 2 ⎦ ] = a[j]
// move the larger child up a level
j = 2 * j;
}
a [ ⎣ j / 2 ⎦ ] = item;
}
Here the root node is 99. The last node is 26, it is in the level 3. So, 99 is replaced by
26 and this node with data 26 is removed from the tree. Next 26 at root node is
compared with its two child 45 and 63. As 63 is greater, they are interchanged. Now,
Lecture Notes

230

Dept. of Information Technology

26 is compared with its children, namely, 57 and 42, as 57 is greater, so they are
interchanged. Now, 26 appears as the leave node, hence re-heap is completed.
26 63
99

26

45

63

57

63

45

57

26
35

27

29

12

24

57

42

35

26

27

De l e t i n g t h e n o d e w it h d at a 9 9

7.6.4.

29

12

26

42

24

Af t er De l e t i o n of n o d e w it h d at a 9 9

Merging two heap trees:

Consider, two heap trees H1 and H2. Merging the tree H2 with H1 means to include all
the node from H2 to H1. H2 may be min heap or max heap and the resultant tree will
be min heap if H1 is min heap else it will be max heap. Merging operation consists of
two steps: Continue steps 1 and 2 while H2 is not empty:
1.

Delete the root node, say x, from H2. Re-heap H2.

2.

Insert the node x into H1 satisfying the property of H1.
92

13

59
38

67

19

45

92

H1: max heap

80
93

96

H2: min heap

+
96
93

67

80

38

7.6.5.

92

59

45

13

92

19

Resultant max heap after merging H1 and H2

Application of heap tree:

They are two main applications of heap trees known are:
1.

Sorting (Heap sort) and

2.

Priority queue implementation.

Lecture Notes

231

Dept. of Information Technology

7.7.

HEAP SORT:

A heap sort algorithm works by first organizing the data to be sorted into a special type
of binary tree called a heap. Any kind of data can be sorted either in ascending order or
in descending order using heap tree. It does this with the following steps:
1.

Build a heap tree with the given set of data.

2.

a.

Remove the top most item (the largest) and replace it with the last
element in the heap.

b.

Re-heapify the complete binary tree.

c.

Place the deleted node in the output.

3. Continue step 2 until the heap tree is empty.

Algorithm:
This algorithm sorts the elements a[n]. Heap sort rearranges them in-place in nondecreasing order. First transform the elements into a heap.
heapsort(a, n)
{
heapify(a, n);
for i = n to 2 by – 1 do
{
temp = a[i];
a[i] = a[1];
a[1] = temp;
adjust (a, 1, i – 1);
}
}
heapify (a, n)
//Readjust the elements in a[n] to form a heap.
{
for i Å ⎣ n/2 ⎦ to 1 by – 1 do adjust (a, i, n);
}
adjust (a, i, n)
// The complete binary trees with roots a(2*i) and a(2*i + 1) are combined with a(i) to
form a single heap, 1 < i < n. No node has an address greater than n or less than 1. //
{
j = 2 *i ;
item = a[i] ;
while (j < n) do
{
if ((j < n) and (a (j) < a (j + 1)) then j Å j + 1;
// compare left and right child and let j be the larger child
if (item > a (j)) then break;
// a position for item is found
else a[ ⎣ j / 2 ⎦ ] = a[j]
// move the larger child up a level
j = 2 * j;
}
a [ ⎣ j / 2 ⎦ ] = item;
}
Lecture Notes

232

Dept. of Information Technology

Time Complexity:
Each ‘n’ insertion operations takes O(log k), where ‘k’ is the number of elements in the
heap at the time. Likewise, each of the ‘n’ remove operations also runs in time O(log
k), where ‘k’ is the number of elements in the heap at the time.
Since we always have k ≤ n, each such operation runs in O(log n) time in the worst
case.
Thus, for ‘n’ elements it takes O(n log n) time, so the priority queue sorting algorithm
runs in O(n log n) time when we use a heap to implement the priority queue.
Example 1:
Form a heap from the set of elements (40, 80, 35, 90, 45, 50, 70) and sort the data
using heap sort.
Solution:
First form a heap tree from the given set of data and then sort by repeated deletion
operation:
40

40

80

35

90

45

80

50

70

90

70

45

90

70
45

35

40

40

80

50

50

70

90

35

80

45

50

35

90
70

80
40

Lecture Notes

45

50

35

233

Dept. of Information Technology

1.

Exchange root 90 with the last element 35 of the array and re-heapify
80

35

80

45 35
80

70

40

45

45

50

90

40

70
35

50

90

35
2.

Exchange root 80 with the last element 50 of the array and re-heapify
70
70
50
45
40

3.

35

80

50

45
40

90

50
35

80

Exchange root 70 with the last element 35 of the array and re-heapify
50
35
50
35
45
50
45
40

4.

70

70

80

90

40

70

90

35
80

90

Exchange root 50 with the last element 40 of the array and re-heapify
45

40

45

40
45
50

5.

35
70

80

40
90

50

35
70

80

90

Exchange root 45 with the last element 35 of the array and re-heapify
40
35

40

35
40
50

6.

45
70

80

35
90

50

45
70

80

90

Exchange root 40 with the last element 35 of the array and re-heapify
35
40
50

45
70

80

90

The sorted tree

Lecture Notes

234

Dept. of Information Technology

7.7.1.

Program for Heap Sort:

void adjust(int i, int n, int a[])
{
int j, item;
j = 2 * i;
item = a[i];
while(j <= n)
{
if((j < n) && (a[j] < a[j+1]))
j++;
if(item >= a[j])
break;
else
{
a[j/2] = a[j];
j = 2*j;
}
}
a[j/2] = item;
}
void heapify(int n, int a[])
{
int i;
for(i = n/2; i > 0; i--)
adjust(i, n, a);
}
void heapsort(int n,int a[])
{
int temp, i;
heapify(n, a);
for(i = n; i > 0; i--)
{
temp = a[i];
a[i] = a[1];
a[1] = temp;
adjust(1, i - 1, a);
}
}
void main()
{
int i, n, a[20];
clrscr();
printf("\n How many element you want: ");
scanf("%d", &n);
printf("Enter %d elements: ", n);
for (i=1; i<=n; i++)
scanf("%d", &a[i]);
heapsort(n, a);
printf("\n The sorted elements are: \n");
for (i=1; i<=n; i++)
printf("%5d", a[i]);
getch();
}
Lecture Notes

235

Dept. of Information Technology

7.8.

Priority queue implementation using heap tree:

Priority queue can be implemented using circular array, linked list etc. Another
simplified implementation is possible using heap tree; the heap, however, can be
represented using an array. This implementation is therefore free from the complexities
of circular array and linked list but getting the advantages of simplicities of array.
As heap trees allow the duplicity of data in it. Elements associated with their priority
values are to be stored in from of heap tree, which can be formed based on their
priority values. The top priority element that has to be processed first is at the root; so
it can be deleted and heap can be rebuilt to get the next element to be processed, and
so on. As an illustration, consider the following processes with their priorities:
Process

P1

P2

P3

P4

P5

P6

P7

P8

P9

P10

Priority

5

4

3

4

5

5

3

2

1

5

These processes enter the system in the order as listed above at time 0, say. Assume
that a process having higher priority value will be serviced first. The heap tree can be
formed considering the process priority values. The order of servicing the process is
successive deletion of roots from the heap.

Exercises
1.

Write a recursive “C” function to implement binary search and compute its
time complexity.

2.

Find the expected number of passes, comparisons and exchanges for
bubble sort when the number of elements is equal to “10”. Compare these
results with the actual number of operations when the given sequence is as
follows: 7, 1, 3, 4, 10, 9, 8, 6, 5, 2.

3.

An array contains “n” elements of numbers. The several elements of this
array may contain the same number “x”. Write an algorithm to find the
total number of elements which are equal to “x” and also indicate the
position of the first such element in the array.

4.

When a “C” function to sort a matrix row-wise and column-wise. Assume
that the matrix is represented by a two dimensional array.

5.

A very large array of elements is to be sorted. The program is to be run on
a personal computer with limited memory. Which sort would be a better
choice: Heap sort or Quick sort? Why?

6.

Here is an array of ten integers: 5 3 8 9 1 7 0 2 6 4
Suppose we partition this array using quicksort's partition function and
using 5 for the pivot. Draw the resulting array after the partition finishes.

7.

Here is an array which has just been partitioned by the first step of
quicksort: 3, 0, 2, 4, 5, 8, 7, 6, 9. Which of these elements could be the
pivot? (There may be more than one possibility!)

8.

Show the result of inserting 10, 12, 1, 14, 6, 5, 8, 15, 3, 9, 7, 4, 11, 13,
and 2, one at a time, into an initially empty binary heap.

9.

Sort the sequence 3, 1, 4, 5, 9, 2, 6, 5 using insertion sort.

Lecture Notes

236

Dept. of Information Technology

10.

Show how heap sort processes the input 142, 543, 123, 65, 453, 879, 572,
434, 111, 242, 811, 102.

11.

Sort 3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5 using quick sort with median-of-three
partitioning and a cutoff of 3.

Multiple Choice Questions
1.

What is the worst-case time for serial search finding a single item in an
array?
A. Constant time
C. Logarithmic time
B. Quadratic time
D. Linear time

[ D ]

2.

What is the worst-case time for binary search finding a single item in an
array?
A. Constant time
C. Logarithmic time
B. Quadratic time
D. Linear time

[ B

]

3.

What additional requirement is placed on an array, so that binary search
may be used to locate an entry?
A. The array elements must form a heap.
B. The array must have at least 2 entries
C. The array must be sorted.
D. The array's size must be a power of two.

[ C

]

4.

Which searching can be performed recursively ?
A. linear search
C. Binary search
B. both
D. none

[

5.

Which searching can be performed iteratively ?
A. linear search
C. Binary search
B. both
D. none

[ B

]

6.

In a selection sort of n elements, how many times is the swap function
called in the complete execution of the algorithm?
C. n - 1
A. 1
D. n log n
B. n2

[ B

]

7.

Selection sort and quick sort both fall into the same category of sorting
algorithms. What is this category?
A. O(n log n) sorts
C. Divide-and-conquer sorts
B. Interchange sorts
D. Average time is quadratic

[ B ]

8.

Suppose that a selection sort of 100 items has completed 42 iterations of
the main loop. How many items are now guaranteed to be in their final spot
(never to be moved again)?
A. 21
C. 42
B. 41
D. 43

[ C

]

9.

When is insertion sort a good choice for sorting an array?
A. Each component of the array requires a large amount of memory
B. The array has only a few items out of place
C. Each component of the array requires a small amount of memory
D. The processor speed is fast

[ B

]

Lecture Notes

237

B ]

Dept. of Information Technology

10.

What is the worst-case time for quick sort to sort an array of n elements?
A. O(log n)
C. O(n log n)
B. O(n)
D. O(n²)

[D

]

11.

Suppose we are sorting an array of eight integers using quick sort, and we
have just finished the first partitioning with the array looking like this:
2 5 1 7 9 12 11 10 Which statement is correct?
A. The pivot could be either the 7 or the 9.
B. The pivot is not the 7, but it could be the 9.
C. The pivot could be the 7, but it is not the 9.
D. Neither the 7 nor the 9 is the pivot

[ A

]

12.

What is the worst-case time for heap sort to sort an array of n elements?
A. O(log n)
C. O(n log n)
B. O(n)
D. O(n²)

[

13.

Suppose we are sorting an array of eight integers using heap sort, and we
have just finished one of the reheapifications downward. The array now
looks like this: 6 4 5 1 2 7 8
How many reheapifications downward have been performed so far?
A. 1
C. 2
B. 3 or 4
D. 5 or 6

[B

]

14.

Time complexity of inserting an element to a heap of n elements is of the
order of
C. n log2n
A. log2 n
B. n2
D. n

[ A

]

15.

A min heap is the tree structure where smallest element is available at the
A. leaf
C. intermediate parent
B. root
D. any where

[B

]

16.

In the quick sort method , a desirable choice for the portioning element will
be
A. first element of list
C. median of list
B. last element of list
D. any element of list

[C

]

17.

Quick sort is also known as
A. merge sort
B. bubble sort

[

D ]

18.

Which design algorithm technique is used for quick sort .
A. Divide and conqueror
C. backtrack
B. greedy
D. dynamic programming

[

A ]

19.

Which among the following is fastest sorting technique (for unordered data)
A. Heap sort
C. Quick Sort
B. Selection Sort
D. Bubble sort

[ C

]

20.

In which searching technique elements are eliminated by half in each pass .
A. Linear search
C. Binary search
B. both
D. none

[ C

]

21.

Running time of Heap sort algorithm is -----.
C. O(n)
A. O( log2 n)
B. A. O( n log2 n)
D. O(n2)

[ B

]

Lecture Notes

C. heap sort
D. none

238

C ]

Dept. of Information Technology

22.

Running time of Bubble sort algorithm is -----.
A. O( log2 n)
C. O(n)
B. A. O( n log2 n)
D. O(n2)

[ D

]

23.

Running time of Selection sort algorithm is -----.
A. O( log2 n)
C. O(n)
B. A. O( n log2 n)
D. O(n2)

[D

]

24.

The Max heap constructed from the list of numbers 30,10,80,60,15,55 is
A. 60,80,55,30,10,15
C. 80,55,60,15,10,30
B. 80,60,55,30,10,15
D. none

[

25.

The number of swappings needed to sort the numbers 8,22,7,9,31,19,5,13
in ascending order using bubble sort is
A. 11
C. 13
B. 12
D. 14

[ D

]

26.

Time complexity of insertion sort algorithm in best case is
C. O(n)
A. O( log2 n)
B. A. O( n log2 n)
D. O(n2)

[ C

]

27.

Binary search algorithm performs efficiently on a
A. linked list
C. array
B. both
D. none

[C

]

28.

Which is a stable sort ?
A. Bubble sort
B. Selection Sort

[

29.

Heap is a good data structure to implement
A. priority Queue
C. linear queue
B. Deque
D. none

[ A

30.

Always Heap is a
A. complete Binary tree
B. Binary Search Tree

[

Lecture Notes

C. Quick sort
D. none

C ]

D ]

A ]

C. Full Binary tree
D. none

239

]

Dept. of Information Technology

