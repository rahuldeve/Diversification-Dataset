11
Dynamic Programming

Dynamic programming is a useful mathematical technique for making a sequence of interrelated decisions. It provides a systematic procedure for determining the optimal combination of decisions.
In contrast to linear programming, there does not exist a standard mathematical formulation of “the” dynamic programming problem. Rather, dynamic programming is a general type of approach to problem solving, and the particular equations used must be developed to fit each situation. Therefore, a certain degree of ingenuity and insight into the
general structure of dynamic programming problems is required to recognize when and
how a problem can be solved by dynamic programming procedures. These abilities can
best be developed by an exposure to a wide variety of dynamic programming applications
and a study of the characteristics that are common to all these situations. A large number
of illustrative examples are presented for this purpose.

11.1
EXAMPLE 1

A PROTOTYPE EXAMPLE FOR DYNAMIC PROGRAMMING
The Stagecoach Problem
The STAGECOACH PROBLEM is a problem specially constructed1 to illustrate the features and to introduce the terminology of dynamic programming. It concerns a mythical
fortune seeker in Missouri who decided to go west to join the gold rush in California during the mid-19th century. The journey would require traveling by stagecoach through unsettled country where there was serious danger of attack by marauders. Although his starting point and destination were fixed, he had considerable choice as to which states (or
territories that subsequently became states) to travel through en route. The possible routes
are shown in Fig. 11.1, where each state is represented by a circled letter and the direction of travel is always from left to right in the diagram. Thus, four stages (stagecoach
runs) were required to travel from his point of embarkation in state A (Missouri) to his
destination in state J (California).
This fortune seeker was a prudent man who was quite concerned about his safety. After some thought, he came up with a rather clever way of determining the safest route. Life
1

This problem was developed by Professor Harvey M. Wagner while he was at Stanford University.

|

▲

▲

533

|

e-Text Main Menu

|

Textbook Table of Contents

|

534

11

DYNAMIC PROGRAMMING

insurance policies were offered to stagecoach passengers. Because the cost of the policy
for taking any given stagecoach run was based on a careful evaluation of the safety of that
run, the safest route should be the one with the cheapest total life insurance policy.
The cost for the standard policy on the stagecoach run from state i to state j, which
will be denoted by cij, is

A

B

C

D

2

4

3

E

F

G

H I

J

B

7

4

6

E

1

4

H

3

C

3

2

4

F

6

3

I

4

D

4

1

5

G

3

3

These costs are also shown in Fig. 11.1.
We shall now focus on the question of which route minimizes the total cost of the
policy.
Solving the Problem
First note that the shortsighted approach of selecting the cheapest run offered by each successive stage need not yield an overall optimal decision. Following this strategy would
give the route A  B  F  I  J, at a total cost of 13. However, sacrificing a little on
one stage may permit greater savings thereafter. For example, A  D  F is cheaper
overall than A  B  F.
One possible approach to solving this problem is to use trial and error.1 However, the
number of possible routes is large (18), and having to calculate the total cost for each
route is not an appealing task.

1

This problem also can be formulated as a shortest-path problem (see Sec. 9.3), where costs here play the role
of distances in the shortest-path problem. The algorithm presented in Sec. 9.3 actually uses the philosophy of
dynamic programming. However, because the present problem has a fixed number of stages, the dynamic programming approach presented here is even better.

FIGURE 11.1
The road system and costs
for the stagecoach problem.

7

B
2

E

4

6

1
4

3

3
A

4

6
2

C

F

J
3

4
3

1

▲

▲

|

|

4
I

3

4
D

H

G

5

e-Text Main Menu

|

3

Textbook Table of Contents

|

11.1 A PROTOTYPE EXAMPLE FOR DYNAMIC PROGRAMMING

535

Fortunately, dynamic programming provides a solution with much less effort than exhaustive enumeration. (The computational savings are enormous for larger versions of this
problem.) Dynamic programming starts with a small portion of the original problem and
finds the optimal solution for this smaller problem. It then gradually enlarges the problem, finding the current optimal solution from the preceding one, until the original problem is solved in its entirety.
For the stagecoach problem, we start with the smaller problem where the fortune
seeker has nearly completed his journey and has only one more stage (stagecoach run) to
go. The obvious optimal solution for this smaller problem is to go from his current state
(whatever it is) to his ultimate destination (state J). At each subsequent iteration, the problem is enlarged by increasing by 1 the number of stages left to go to complete the journey. For this enlarged problem, the optimal solution for where to go next from each possible state can be found relatively easily from the results obtained at the preceding iteration.
The details involved in implementing this approach follow.
Formulation. Let the decision variables xn (n  1, 2, 3, 4) be the immediate destination on stage n (the nth stagecoach run to be taken). Thus, the route selected is A 
x1  x2  x3  x4, where x4  J.
Let fn(s, xn) be the total cost of the best overall policy for the remaining stages, given
that the fortune seeker is in state s, ready to start stage n, and selects xn as the immediate destination. Given s and n, let xn* denote any value of xn (not necessarily unique) that
minimizes fn(s, xn), and let f n* (s) be the corresponding minimum value of fn(s, xn). Thus,
f n*(s)  min fn(s, xn)  fn(s, xn*),
xn

where
fn(s, xn)  immediate cost (stage n)  minimum future cost (stages n  1 onward)
 csxn  f n*1(xn).
The value of csxn is given by the preceding tables for cij by setting i  s (the current state)
and j  xn (the immediate destination). Because the ultimate destination (state J) is reached
at the end of stage 4, f 5* ( J)  0.
The objective is to find f 1* (A) and the corresponding route. Dynamic programming
finds it by successively finding f 4*(s), f 3*(s), f 2*(s), for each of the possible states s and
then using f 2*(s) to solve for f 1*(A).1
Solution Procedure. When the fortune seeker has only one more stage to go (n  4),
his route thereafter is determined entirely by his current state s (either H or I) and his final destination x4  J, so the route for this final stagecoach run is s  J. Therefore, since
f 4*(s)  f4(s, J)  cs,J, the immediate solution to the n  4 problem is
n  4:

s

f 4*(s)

x4*

H
I

3
4

J
J

1

|

▲

▲

Because this procedure involves moving backward stage by stage, some writers also count n backward to denote
the number of remaining stages to the destination. We use the more natural forward counting for greater simplicity.

|

e-Text Main Menu

|

Textbook Table of Contents

|

536

11

DYNAMIC PROGRAMMING

When the fortune seeker has two more stages to go (n  3), the solution procedure
requires a few calculations. For example, suppose that the fortune seeker is in state F.
Then, as depicted below, he must next go to either state H or I at an immediate cost of
cF,H  6 or cF,I  3, respectively. If he chooses state H, the minimum additional cost after he reaches there is given in the preceding table as f 4*(H)  3, as shown above the H
node in the diagram. Therefore, the total cost for this decision is 6  3  9. If he chooses
state I instead, the total cost is 3  4  7, which is smaller. Therefore, the optimal choice
is this latter one, x3*  I, because it gives the minimum cost f 3*(F)  7.
3
H
6
F
3
I
4

Similar calculations need to be made when you start from the other two possible states
s  E and s  G with two stages to go. Try it, proceeding both graphically (Fig. 11.1)
and algebraically [combining cij and f 4*(s) values], to verify the following complete results for the n  3 problem.

n  3:

x3

f3(s, x3)  csx3  f 4*(x3)

s

H

I

f 3*(s)

x3*

E
F
G

4
9
6

8
7
7

4
7
6

H
I
H

The solution for the second-stage problem (n  2), where there are three stages to
go, is obtained in a similar fashion. In this case, f2(s, x2)  csx  f 3*(x2). For example,
suppose that the fortune seeker is in state C, as depicted below.
2

4
E
3

7
2

C

F

4
G

|

▲

▲

6

|

e-Text Main Menu

|

Textbook Table of Contents

|

11.1 A PROTOTYPE EXAMPLE FOR DYNAMIC PROGRAMMING

537

He must next go to state E, F, or G at an immediate cost of cC,E  3, cC,F  2, or
cC,G  4, respectively. After getting there, the minimum additional cost for stage 3 to the
end is given by the n  3 table as f 3*(E)  4, f 3*(F)  7, or f 3*(G)  6, respectively, as
shown above the E and F nodes and below the G node in the preceding diagram. The resulting calculations for the three alternatives are summarized below.
x2  E:
x2  F:
x2  G:

f2(C, E)  cC,E  f 3*(E)  3  4  7.
f2(C, F)  cC,F  f 3*(F)  2  7  9.
f2(C, G)  cC,G  f 3*(G)  4  6  10.

The minimum of these three numbers is 7, so the minimum total cost from state C to the
end is f 2*(C)  7, and the immediate destination should be x2*  E.
Making similar calculations when you start from state B or D (try it) yields the following results for the n  2 problem:

n  2:

f2(s, x2)  csx2  f 3*(x2)

x2
s

E

F

G

f 2*(s)

x2*

B
C
D

11
7
8

11
9
8

12
10
11

11
7
8

E or F
E
E or F

In the first and third rows of this table, note that E and F tie as the minimizing value of
x2, so the immediate destination from either state B or D should be x2*  E or F.
Moving to the first-stage problem (n  1), with all four stages to go, we see that the
calculations are similar to those just shown for the second-stage problem (n  2), except
now there is just one possible starting state s  A, as depicted below.
11
B
2

7
4

A

C

3
D
8

These calculations are summarized next for the three alternatives for the immediate destination:

|

▲

▲

x1  B:
x1  C:
x1  D:

|

f1(A, B)  cA,B  f 2*(B)  2  11  13.
f1(A, C)  cA,C  f 2*(C)  4  7  11.
f1(A, D)  cA,D  f 2*(D)  3  8  11.

e-Text Main Menu

|

Textbook Table of Contents

|

538

11

DYNAMIC PROGRAMMING

Stage:
FIGURE 11.2
Graphical display of the
dynamic programming
solution of the stagecoach
problem. Each arrow shows
an optimal policy decision
(the best immediate
destination) from that state,
where the number by the
state is the resulting cost
from there to the end.
Following the boldface
arrows from A to T gives the
three optimal solutions (the
three routes giving the
minimum total cost of 11).

1

2

3

11

4

4
7

B

E

1

4
11
State:

7
4

A

3
H

3

3

7

C

F

T

4
3

3

4

3

1
D

G

8

6

I
4

Since 11 is the minimum, f 1*(A)  11 and x1*  C or D, as shown in the following table.

n  1:

f1(s, x1)  csx1  f 2*(x1)

x1
s

B

C

D

f 1*(s)

x1*

A

13

11

11

11

C or D

An optimal solution for the entire problem can now be identified from the four tables. Results for the n  1 problem indicate that the fortune seeker should go initially to
either state C or state D. Suppose that he chooses x1*  C. For n  2, the result for s  C
is x2*  E. This result leads to the n  3 problem, which gives x3*  H for s  E, and the
n  4 problem yields x4*  J for s  H. Hence, one optimal route is A  C  E 
H  J. Choosing x1*  D leads to the other two optimal routes A  D  E  H  J
and A  D  F  I  J. They all yield a total cost of f 1*(A)  11.
These results of the dynamic programming analysis also are summarized in Fig. 11.2.
Note how the two arrows for stage 1 come from the first and last columns of the n  1
table and the resulting cost comes from the next-to-last column. Each of the other arrows
(and the resulting cost) comes from one row in one of the other tables in just the same way.
You will see in the next section that the special terms describing the particular context of this problem—stage, state, and policy—actually are part of the general terminology of dynamic programming with an analogous interpretation in other contexts.

11.2

CHARACTERISTICS OF DYNAMIC PROGRAMMING PROBLEMS

|

▲

▲

The stagecoach problem is a literal prototype of dynamic programming problems. In fact,
this example was purposely designed to provide a literal physical interpretation of the
rather abstract structure of such problems. Therefore, one way to recognize a situation

|

e-Text Main Menu

|

Textbook Table of Contents

|

11.2 CHARACTERISTICS OF DYNAMIC PROGRAMMING PROBLEMS

539

that can be formulated as a dynamic programming problem is to notice that its basic structure is analogous to the stagecoach problem.
These basic features that characterize dynamic programming problems are presented
and discussed here.

|

▲

▲

1. The problem can be divided into stages, with a policy decision required at each stage.
The stagecoach problem was literally divided into its four stages (stagecoaches)
that correspond to the four legs of the journey. The policy decision at each stage was
which life insurance policy to choose (i.e., which destination to select for the next stagecoach ride). Similarly, other dynamic programming problems require making a sequence
of interrelated decisions, where each decision corresponds to one stage of the problem.
2. Each stage has a number of states associated with the beginning of that stage.
The states associated with each stage in the stagecoach problem were the states
(or territories) in which the fortune seeker could be located when embarking on that
particular leg of the journey. In general, the states are the various possible conditions
in which the system might be at that stage of the problem. The number of states may
be either finite (as in the stagecoach problem) or infinite (as in some subsequent examples).
3. The effect of the policy decision at each stage is to transform the current state to a
state associated with the beginning of the next stage (possibly according to a probability distribution).
The fortune seeker’s decision as to his next destination led him from his current
state to the next state on his journey. This procedure suggests that dynamic programming problems can be interpreted in terms of the networks described in Chap. 9. Each
node would correspond to a state. The network would consist of columns of nodes,
with each column corresponding to a stage, so that the flow from a node can go only
to a node in the next column to the right. The links from a node to nodes in the next
column correspond to the possible policy decisions on which state to go to next. The
value assigned to each link usually can be interpreted as the immediate contribution to
the objective function from making that policy decision. In most cases, the objective
corresponds to finding either the shortest or the longest path through the network.
4. The solution procedure is designed to find an optimal policy for the overall problem,
i.e., a prescription of the optimal policy decision at each stage for each of the possible states.
For the stagecoach problem, the solution procedure constructed a table for each
stage (n) that prescribed the optimal decision (xn*) for each possible state (s). Thus, in
addition to identifying three optimal solutions (optimal routes) for the overall problem,
the results show the fortune seeker how he should proceed if he gets detoured to a state
that is not on an optimal route. For any problem, dynamic programming provides this
kind of policy prescription of what to do under every possible circumstance (which is
why the actual decision made upon reaching a particular state at a given stage is referred to as a policy decision). Providing this additional information beyond simply
specifying an optimal solution (optimal sequence of decisions) can be helpful in a variety of ways, including sensitivity analysis.
5. Given the current state, an optimal policy for the remaining stages is independent of
the policy decisions adopted in previous stages. Therefore, the optimal immediate de-

|

e-Text Main Menu

|

Textbook Table of Contents

|

540

11

DYNAMIC PROGRAMMING

cision depends on only the current state and not on how you got there. This is the principle of optimality for dynamic programming.
Given the state in which the fortune seeker is currently located, the optimal life
insurance policy (and its associated route) from this point onward is independent of
how he got there. For dynamic programming problems in general, knowledge of the
current state of the system conveys all the information about its previous behavior necessary for determining the optimal policy henceforth. (This property is the Markovian
property, discussed in Sec. 16.2.) Any problem lacking this property cannot be formulated as a dynamic programming problem.
6. The solution procedure begins by finding the optimal policy for the last stage.
The optimal policy for the last stage prescribes the optimal policy decision for
each of the possible states at that stage. The solution of this one-stage problem is usually trivial, as it was for the stagecoach problem.
7. A recursive relationship that identifies the optimal policy for stage n, given the optimal policy for stage n  1, is available.
For the stagecoach problem, this recursive relationship was
* (xn)}.
f n*(s)  min {csxn  f n1
xn

Therefore, finding the optimal policy decision when you start in state s at stage n requires finding the minimizing value of xn. For this particular problem, the corresponding
minimum cost is achieved by using this value of xn and then following the optimal policy when you start in state xn at stage n  1.
The precise form of the recursive relationship differs somewhat among dynamic
programming problems. However, notation analogous to that introduced in the preceding section will continue to be used here, as summarized below.
N  number of stages.
n  label for current stage (n  1, 2, . . . , N).
sn  current state for stage n.
xn  decision variable for stage n.
xn*  optimal value of xn (given sn).
fn(sn, xn)  contribution of stages n, n  1, . . . , N to objective function if system starts
in state sn at stage n, immediate decision is xn, and optimal decisions are
made thereafter.
f n*(sn)  fn(sn, xn*).
The recursive relationship will always be of the form
f n*(sn)  max {fn(sn, xn)}
xn

or

f n*(sn)  min {fn(sn, xn)},
xn

|

▲

▲

where fn(sn, xn) would be written in terms of sn, xn, f *n1(sn1), and probably some
measure of the immediate contribution of xn to the objective function. It is the inclusion of f *n1(sn1) on the right-hand side, so that f *n(sn) is defined in terms of f *n1(sn1),
that makes the expression for f *n (sn) a recursive relationship.
The recursive relationship keeps recurring as we move backward stage by stage.
When the current stage number n is decreased by 1, the new f *n(sn) function is derived

|

e-Text Main Menu

|

Textbook Table of Contents

|

11.3 DETERMINISTIC DYNAMIC PROGRAMMING

541

by using the f *n1(sn1) function that was just derived during the preceding iteration,
and then this process keeps repeating. This property is emphasized in the next (and final) characteristic of dynamic programming.
8. When we use this recursive relationship, the solution procedure starts at the end and
moves backward stage by stage—each time finding the optimal policy for that stage—
until it finds the optimal policy starting at the initial stage. This optimal policy immediately yields an optimal solution for the entire problem, namely, x1* for the initial state
s1, then x2* for the resulting state s2, then x3* for the resulting state s3, and so forth to
x*N for the resulting stage sN.
This backward movement was demonstrated by the stagecoach problem, where the
optimal policy was found successively beginning in each state at stages 4, 3, 2, and 1,
respectively.1 For all dynamic programming problems, a table such as the following
would be obtained for each stage (n  N, N  1, . . . , 1).

xn

fn(sn, xn)
f n*(sn)

sn

xn*

When this table is finally obtained for the initial stage (n  1), the problem of interest
is solved. Because the initial state is known, the initial decision is specified by x1* in this
table. The optimal value of the other decision variables is then specified by the other tables in turn according to the state of the system that results from the preceding decisions.

11.3

DETERMINISTIC DYNAMIC PROGRAMMING
This section further elaborates upon the dynamic programming approach to deterministic
problems, where the state at the next stage is completely determined by the state and policy decision at the current stage. The probabilistic case, where there is a probability distribution for what the next state will be, is discussed in the next section.
Deterministic dynamic programming can be described diagrammatically as shown in
Fig. 11.3. Thus, at stage n the process will be in some state sn. Making policy decision
xn then moves the process to some state sn1 at stage n  1. The contribution thereafter
to the objective function under an optimal policy has been previously calculated to be
f *n1(sn1). The policy decision xn also makes some contribution to the objective function. Combining these two quantities in an appropriate way provides fn(sn, xn), the contribution of stages n onward to the objective function. Optimizing with respect to xn then
gives f n*(sn)  fn(sn, xn*). After xn* and f n*(sn) are found for each possible value of sn, the
solution procedure is ready to move back one stage.
One way of categorizing deterministic dynamic programming problems is by the form
of the objective function. For example, the objective might be to minimize the sum of the
contributions from the individual stages (as for the stagecoach problem), or to maximize
1

|

▲

▲

Actually, for this problem the solution procedure can move either backward or forward. However, for many
problems (especially when the stages correspond to time periods), the solution procedure must move backward.

|

e-Text Main Menu

|

Textbook Table of Contents

|

542

11

DYNAMIC PROGRAMMING

Stage
n
FIGURE 11.3
The basic structure for
deterministic dynamic
programming.

State:

sn

Value: fn(sn, xn)

Stage
n1
xn
Contribution
of xn

sn  1
f n*  1(sn  1)

such a sum, or to minimize a product of such terms, and so on. Another categorization is
in terms of the nature of the set of states for the respective stages. In particular, states sn
might be representable by a discrete state variable (as for the stagecoach problem) or by
a continuous state variable, or perhaps a state vector (more than one variable) is required.
Several examples are presented to illustrate these various possibilities. More importantly, they illustrate that these apparently major differences are actually quite inconsequential (except in terms of computational difficulty) because the underlying basic structure shown in Fig. 11.3 always remains the same.
The first new example arises in a much different context from the stagecoach problem, but it has the same mathematical formulation except that the objective is to maximize rather than minimize a sum.
EXAMPLE 2

Distributing Medical Teams to Countries
The WORLD HEALTH COUNCIL is devoted to improving health care in the underdeveloped countries of the world. It now has five medical teams available to allocate among
three such countries to improve their medical care, health education, and training programs. Therefore, the council needs to determine how many teams (if any) to allocate to
each of these countries to maximize the total effectiveness of the five teams. The teams
must be kept intact, so the number allocated to each country must be an integer.
The measure of performance being used is additional person-years of life. (For a particular country, this measure equals the increased life expectancy in years times the country’s population.) Table 11.1 gives the estimated additional person-years of life (in multiples of 1,000) for each country for each possible allocation of medical teams.
Which allocation maximizes the measure of performance?
TABLE 11.1 Data for the World Health Council problem
Thousands of Additional
Person-Years of Life

|

▲

▲

Country
Medical
Teams

1

2

3

0
1
2
3
4
5

0
45
70
90
105
120

0
20
45
75
110
150

0
50
70
80
100
130

|

e-Text Main Menu

|

Textbook Table of Contents

|

11.3 DETERMINISTIC DYNAMIC PROGRAMMING

543

Formulation. This problem requires making three interrelated decisions, namely, how
many medical teams to allocate to each of the three countries. Therefore, even though
there is no fixed sequence, these three countries can be considered as the three stages in
a dynamic programming formulation. The decision variables xn (n  1, 2, 3) are the number of teams to allocate to stage (country) n.
The identification of the states may not be readily apparent. To determine the states,
we ask questions such as the following. What is it that changes from one stage to the next?
Given that the decisions have been made at the previous stages, how can the status of the
situation at the current stage be described? What information about the current state of
affairs is necessary to determine the optimal policy hereafter? On these bases, an appropriate choice for the “state of the system” is
sn  number of medical teams still available for allocation to remaining countries
(n, . . . , 3).
Thus, at stage 1 (country 1), where all three countries remain under consideration for allocations, s1  5. However, at stage 2 or 3 (country 2 or 3), sn is just 5 minus the number of teams allocated at preceding stages, so that the sequence of states is
s1  5,

s2  5  x1,

s3  s2  x2.

With the dynamic programming procedure of solving backward stage by stage, when we
are solving at stage 2 or 3, we shall not yet have solved for the allocations at the preceding stages. Therefore, we shall consider every possible state we could be in at stage 2 or
3, namely, sn  0, 1, 2, 3, 4, or 5.
Figure 11.4 shows the states to be considered at each stage. The links (line segments)
show the possible transitions in states from one stage to the next from making a feasible
allocation of medical teams to the country involved. The numbers shown next to the links
are the corresponding contributions to the measure of performance, where these numbers
come from Table 11.1. From the perspective of this figure, the overall problem is to find
the path from the initial state 5 (beginning stage 1) to the final state 0 (after stage 3) that
maximizes the sum of the numbers along the path.
To state the overall problem mathematically, let pi(xi) be the measure of performance
from allocating xi medical teams to country i, as given in Table 11.1. Thus, the objective
is to choose x1, x2, x3 so as to
3

Maximize

 pi (xi),
i1

subject to
3

 xi  5,
i1
and
xi are nonnegative integers.
Using the notation presented in Sec. 11.2, we see that fn(sn, xn) is
3

|

▲

▲

fn(sn, xn)  pn(xn)  max

|

e-Text Main Menu

|

 pi(xi),
in1

Textbook Table of Contents

|

544

11

DYNAMIC PROGRAMMING

Stage: 1

2

3
0

0

0

50

20

150

0

1

0

0

1

70

45
110

20

105

80
2 0

120

20

45

75

3

45

75

45

4

0

70

5

4

20

45
State:

130

20

110
FIGURE 11.4
Graphical display of the
World Health Council
problem, showing the
possible states at each stage,
the possible transitions in
states, and the corresponding
contributions to the measure
of performance.

100

75

3

0

90

2

5

0

0

5

where the maximum is taken over xn1, . . . , x3 such that
3

 xi  sn
in
and the xi are nonnegative integers, for n  1, 2, 3. In addition,
f n*(sn) 

max

xn0,1, . . . , sn

fn(sn, xn)

Therefore,
fn(sn, xn)  pn(xn)  f n*1(sn  xn)

|

▲

▲

(with f 4* defined to be zero). These basic relationships are summarized in Fig. 11.5.

|

e-Text Main Menu

|

Textbook Table of Contents

|

11.3 DETERMINISTIC DYNAMIC PROGRAMMING

Stage
n
State:

FIGURE 11.5
The basic structure for the
World Health Council
problem.

Stage
n1

xn

sn

545

sn  xn
f *n  1(sn  xn)

Value: fn(sn, xn)
pn(xn)
 pn(xn)  f *n  1(sn  xn)

Consequently, the recursive relationship relating functions f 1*, f 2*, and f 3* for this problem is
f n*(sn) 

max

xn0,1, . . . , sn

* (sn  xn)},
{pn(xn)  f n1

for n  1, 2.

For the last stage (n  3),
f 3*(s3) 

max

x30,1, . . . , s3

p3(x3).

The resulting dynamic programming calculations are given next.
Solution Procedure. Beginning with the last stage (n  3), we note that the values of
p3(x3) are given in the last column of Table 11.1 and these values keep increasing as we
move down the column. Therefore, with s3 medical teams still available for allocation to
country 3, the maximum of p3(x3) is automatically achieved by allocating all s3 teams; so
x3*  s3 and f 3*(s3)  p3(s3), as shown in the following table.
n  3:

s3

f 3*(s3)

x3*

0
1
2
3
4
5

0
50
70
80
100
130

0
1
2
3
4
5

We now move backward to start from the next-to-last stage (n  2). Here, finding
x2* requires calculating and comparing f2(s2, x2) for the alternative values of x2, namely,
x2  0, 1, . . . , s2. To illustrate, we depict this situation when s2  2 graphically:
0
0
45
50
State:

2

20

1

0
2

|

▲

▲

70

|

e-Text Main Menu

|

Textbook Table of Contents

|

546

11

DYNAMIC PROGRAMMING

This diagram corresponds to Fig. 11.5 except that all three possible states at stage 3 are
shown. Thus, if x2  0, the resulting state at stage 3 will be s2  x2  2  0  2, whereas
x2  1 leads to state 1 and x2  2 leads to state 0. The corresponding values of p2(x2)
from the country 2 column of Table 11.1 are shown along the links, and the values of
f 3*(s2  x2) from the n  3 table are given next to the stage 3 nodes. The required calculations for this case of s2  2 are summarized below.
Formula:

x2  0:
x2  1:
x2  2:

f2(2, x2)  p2(x2)  f 3*(2  x2).
p2(x2) is given in the country 2 column of Table 11.1.
f 3*(2  x2) is given in the n  3 table (bottom of preceding page).
f2(2, 0)  p2(0)  f 3*(2)  0  70  70.
f2(2, 1)  p2(1)  f 3*(1)  20  50  70.
f2(2, 2)  p2(2)  f 3*(0)  45  0  45.

Because the objective is maximization, x2*  0 or 1 with f 2*(2)  70.
Proceeding in a similar way with the other possible values of s2 (try it) yields the following table.

n  2:

f2(s2, x2)  p2(x2)  f 3*(s2  x2)

x2
s2

0

1

0
1
2
3
4
5

0
50
70
80
100
130

20
70
90
100
120

2

3

45
95
115
125

4

75
125
145

110
160

5

f 2*(s2)

150

0
50
70
95
125
160

x2*
0
0
0
2
3
4

or
or
or
or
or
or

1
1
1
1
1
1

We now are ready to move backward to solve the original problem where we are starting from stage 1 (n  1). In this case, the only state to be considered is the starting state
of s1  5, as depicted below.
0
0
120

•
•
•

125
State:

5

45

4

0
5
160

|

▲

▲

Since allocating x1 medical teams to country 1 leads to a state of 5  x1 at stage 2, a
choice of x1  0 leads to the bottom node on the right, x  1 leads to the next node up,
and so forth up to the top node with x1  5. The corresponding p1(x1) values from Table

|

e-Text Main Menu

|

Textbook Table of Contents

|

11.3 DETERMINISTIC DYNAMIC PROGRAMMING

547

11.1 are shown next to the links. The numbers next to the nodes are obtained from the
f 2*(s2) column of the n  2 table. As with n  2, the calculation needed for each alternative value of the decision variable involves adding the corresponding link value and node
value, as summarized below.
Formula:

x1  0:
x1  1:

x1  5:

f1(5, x1)  p1(x1)  f 2*(5  x1).
p1(x1) is given in the country 1 column of Table 11.1.
f 2*(5  x1) is given in the n  2 table.
f1(5, 0)  p1(0)  f 2*(5)  0  160  160.
f1(5, 1)  p1(1)  f 2*(4)  45  125  170.
f1(5, 5)  p1(5)  f 2*(0)  120 

0  120.

The similar calculations for x1  2, 3, 4 (try it) verify that x1*  1 with f 1*(5)  170, as
shown in the following table.

n  1:

f1(s1, x1)  p1(x1)  f 2*(s1  x1)

x2
s1

0

1

2

3

4

5

f 1*(s1)

x1*

5

160

170

165

160

155

120

170

1

Thus, the optimal solution has x1*  1, which makes s2  5  1  4, so x2*  3, which
makes s3  4  3  1, so x3*  1. Since f 1*(5)  170, this (1, 3, 1) allocation of medical
teams to the three countries will yield an estimated total of 170,000 additional personyears of life, which is at least 5,000 more than for any other allocation.
These results of the dynamic programming analysis also are summarized in Fig. 11.6.

A Prevalent Problem Type—The Distribution of Effort Problem
The preceding example illustrates a particularly common type of dynamic programming
problem called the distribution of effort problem. For this type of problem, there is just
one kind of resource that is to be allocated to a number of activities. The objective is to
determine how to distribute the effort (the resource) among the activities most effectively.
For the World Health Council example, the resource involved is the medical teams, and
the three activities are the health care work in the three countries.

|

▲

▲

Assumptions. This interpretation of allocating resources to activities should ring a bell
for you, because it is the typical interpretation for linear programming problems given at
the beginning of Chap. 3. However, there also are some key differences between the distribution of effort problem and linear programming that help illuminate the general distinctions between dynamic programming and other areas of mathematical programming.
One key difference is that the distribution of effort problem involves only one resource (one functional constraint), whereas linear programming can deal with thousands
of resources. (In principle, dynamic programming can handle slightly more than one resource, as we shall illustrate in Example 5 by solving the three-resource Wyndor Glass

|

e-Text Main Menu

|

Textbook Table of Contents

|

548

11

DYNAMIC PROGRAMMING

Stage:

2

1

3
0

0
0

0

0
0
*

(x 3

50

0

1



0
1)

50

50
1

70

20
2

0

70

130

2
70

45

80

95
)

3

(x *
2
3

FIGURE 11.6
Graphical display of the
dynamic programming
solution of the World Health
Council problem. An arrow
from state sn to state sn1
indicates that an optimal
policy decision from state sn
is to allocate (sn  sn1)
medical teams to country n.
Allocating the medical teams
in this way when following
the boldfaced arrows from
the initial state to the final
state gives the optimal
solution.

3
80
100

75

*

(x 1
State:



1)

4

4

125

100

110

45

5

5

5

170

160

130

|

▲

▲

Co. problem, but it quickly becomes very inefficient when the number of resources is
increased.)
On the other hand, the distribution of effort problem is far more general than linear
programming in other ways. Consider the four assumptions of linear programming presented in Sec. 3.3: proportionality, additivity, divisibility, and certainty. Proportionality is
routinely violated by nearly all dynamic programming problems, including distribution of
effort problems (e.g., Table 11.1 violates proportionality). Divisibility also is often violated, as in Example 2, where the decision variables must be integers. In fact, dynamic
programming calculations become more complex when divisibility does hold (as in Examples 4 and 5). Although we shall consider the distribution of effort problem only under the assumption of certainty, this is not necessary, and many other dynamic programming problems violate this assumption as well (as described in Sec. 11.4).

|

e-Text Main Menu

|

Textbook Table of Contents

|

11.3 DETERMINISTIC DYNAMIC PROGRAMMING

549

Of the four assumptions of linear programming, the only one needed by the distribution of effort problem (or other dynamic programming problems) is additivity (or its analog for functions involving a product of terms). This assumption is needed to satisfy the
principle of optimality for dynamic programming (characteristic 5 in Sec. 11.2).
Formulation. Because they always involve allocating one kind of resource to a number of activities, distribution of effort problems always have the following dynamic programming formulation (where the ordering of the activities is arbitrary):
Stage n  activity n (n  1, 2, . . . , N).
xn  amount of resource allocated to activity n.
State sn  amount of resource still available for allocation to remaining activities
(n, . . . , N).
The reason for defining state sn in this way is that the amount of the resource still available for allocation is precisely the information about the current state of affairs (entering
stage n) that is needed for making the allocation decisions for the remaining activities.
When the system starts at stage n in state sn, the choice of xn results in the next state
at stage n  1 being sn1  sn  xn, as depicted below:1
Stage:

n

State:

sn

n1
xn

sn  xn

Note how the structure of this diagram corresponds to the one shown in Fig. 11.5 for the
World Health Council example of a distribution of effort problem. What will differ from
one such example to the next is the rest of what is shown in Fig. 11.5, namely, the relationship between fn(sn, xn) and f *n1(sn  xn), and then the resulting recursive relationship
* functions. These relationships depend on the particular objective
between the f n* and f n1
function for the overall problem.
The structure of the next example is similar to the one for the World Health Council
because it, too, is a distribution of effort problem. However, its recursive relationship differs in that its objective is to minimize a product of terms for the respective stages.
At first glance, this example may appear not to be a deterministic dynamic programming problem because probabilities are involved. However, it does indeed fit our definition because the state at the next stage is completely determined by the state and policy decision at the current stage.
EXAMPLE 3

Distributing Scientists to Research Teams
A government space project is conducting research on a certain engineering problem that
must be solved before people can fly safely to Mars. Three research teams are currently
trying three different approaches for solving this problem. The estimate has been made
that, under present circumstances, the probability that the respective teams—call them 1,
1

|

▲

▲

This statement assumes that xn and sn are expressed in the same units. If it is more convenient to define xn as
some other quantity such that the amount of the resource allocated to activity n is anxn, then sn1  sn  anxn.

|

e-Text Main Menu

|

Textbook Table of Contents

|

550

11

DYNAMIC PROGRAMMING

2, and 3—will not succeed is 0.40, 0.60, and 0.80, respectively. Thus, the current probability that all three teams will fail is (0.40)(0.60)(0.80)  0.192. Because the objective is
to minimize the probability of failure, two more top scientists have been assigned to the
project.
Table 11.2 gives the estimated probability that the respective teams will fail when 0,
1, or 2 additional scientists are added to that team. Only integer numbers of scientists are
considered because each new scientist will need to devote full attention to one team. The
problem is to determine how to allocate the two additional scientists to minimize the probability that all three teams will fail.
Formulation. Because both Examples 2 and 3 are distribution of effort problems, their
underlying structure is actually very similar. In this case, scientists replace medical teams
as the kind of resource involved, and research teams replace countries as the activities.
Therefore, instead of medical teams being allocated to countries, scientists are being allocated to research teams. The only basic difference between the two problems is in their
objective functions.
With so few scientists and teams involved, this problem could be solved very easily
by a process of exhaustive enumeration. However, the dynamic programming solution is
presented for illustrative purposes.
In this case, stage n (n  1, 2, 3) corresponds to research team n, and the state sn is the
number of new scientists still available for allocation to the remaining teams. The decision
variables xn (n  1, 2, 3) are the number of additional scientists allocated to team n.
Let pi (xi) denote the probability of failure for team i if it is assigned xi additional scientists, as given by Table 11.2. If we let  denote multiplication, the government’s objective is to choose x1, x2, x3 so as to
3

Minimize

 pi(xi)  p1(x1)p2(x2)p3(x3),
i1

subject to
3

 xi  2
i1

TABLE 11.2 Data for the Government Space Project problem
Probability of Failure

|

▲

▲

Team
New
Scientists

1

2

3

0
1
2

0.40
0.20
0.15

0.60
0.40
0.20

0.80
0.50
0.30

|

e-Text Main Menu

|

Textbook Table of Contents

|

11.3 DETERMINISTIC DYNAMIC PROGRAMMING

551

and
xi are nonnegative integers.
Consequently, fn(sn, xn) for this problem is
3

fn(sn, xn)  pn(xn)  min



pi (xi),

in1

where the minimum is taken over xn1, . . . , x3 such that
3

 xi  sn

in

and
xi are nonnegative integers,
for n  1, 2, 3. Thus,
f n*(sn) 

min

xn0,1, . . . , sn

fn(sn, xn),

where
fn(sn, xn)  pn(xn)  f *n1(sn  xn)
(with f 4* defined to be 1). Figure 11.7 summarizes these basic relationships.
Thus, the recursive relationship relating the f 1*, f 2*, and f 3* functions in this case is
f n*(sn) 

min

xn0,1, . . . , sn

{pn(xn)  f *n1(sn  xn)},

for n  1, 2,

and, when n  3,
f 3*(s3) 

min

x3  0,1, . . . , s3

p3(x3).

Solution Procedure. The resulting dynamic programming calculations are as follows:
n  3:

s3

f 3*(s3)

x3*

0
1
2

0.80
0.50
0.30

0
1
2

Stage
n

FIGURE 11.7
The basic structure for the
government space project
problem.

State:

xn

sn

|

▲

▲

Value: fn(sn, xn)
pn(xn)
 pn(xn)  f *n  1(sn  xn)

|

e-Text Main Menu

|

Stage
n1
sn  xn
f *n  1(sn  xn)

Textbook Table of Contents

|

552

11

DYNAMIC PROGRAMMING

n  2:

n  1:

f2(s2, x2)  p2(x2)  f 3*(s2  x2)

x2
s2

0

1

0
1
2

0.48
0.30
0.18

0.32
0.20

2

f 2*(s2)

x2*

0.16

0.48
0.30
0.16

0
0
2

f1(s1, x1)  p1(x1)  f 2*(s1  x1)

x1
s1

0

1

2

f 1*(s1)

x1*

2

0.064

0.060

0.072

0.060

1

Therefore, the optimal solution must have x1*  1, which makes s2  2  1  1, so that
x2*  0, which makes s3  1  0  1, so that x3*  1. Thus, teams 1 and 3 should each
receive one additional scientist. The new probability that all three teams will fail would
then be 0.060.

All the examples thus far have had a discrete state variable sn at each stage. Furthermore, they all have been reversible in the sense that the solution procedure actually
could have moved either backward or forward stage by stage. (The latter alternative
amounts to renumbering the stages in reverse order and then applying the procedure in
the standard way.) This reversibility is a general characteristic of distribution of effort
problems such as Examples 2 and 3, since the activities (stages) can be ordered in any
desired manner.
The next example is different in both respects. Rather than being restricted to integer values, its state variable sn at stage n is a continuous variable that can take on any
value over certain intervals. Since sn now has an infinite number of values, it is no longer
possible to consider each of its feasible values individually. Rather, the solution for f n*(sn)
and xn* must be expressed as functions of sn. Furthermore, this example is not reversible
because its stages correspond to time periods, so the solution procedure must proceed
backward.
EXAMPLE 4

Scheduling Employment Levels

|

▲

▲

The workload for the LOCAL JOB SHOP is subject to considerable seasonal fluctuation.
However, machine operators are difficult to hire and costly to train, so the manager is reluctant to lay off workers during the slack seasons. He is likewise reluctant to maintain
his peak season payroll when it is not required. Furthermore, he is definitely opposed to
overtime work on a regular basis. Since all work is done to custom orders, it is not possible to build up inventories during slack seasons. Therefore, the manager is in a dilemma
as to what his policy should be regarding employment levels.

|

e-Text Main Menu

|

Textbook Table of Contents

|

11.3 DETERMINISTIC DYNAMIC PROGRAMMING

553

The following estimates are given for the minimum employment requirements during the four seasons of the year for the foreseeable future:
Season
Requirements

Spring

Summer

Autumn

Winter

Spring

255

220

240

200

255

Employment will not be permitted to fall below these levels. Any employment above these
levels is wasted at an approximate cost of $2,000 per person per season. It is estimated
that the hiring and firing costs are such that the total cost of changing the level of employment from one season to the next is $200 times the square of the difference in employment levels. Fractional levels of employment are possible because of a few part-time
employees, and the cost data also apply on a fractional basis.
Formulation. On the basis of the data available, it is not worthwhile to have the employment level go above the peak season requirements of 255. Therefore, spring employment should be at 255, and the problem is reduced to finding the employment level
for the other three seasons.
For a dynamic programming formulation, the seasons should be the stages. There are
actually an indefinite number of stages because the problem extends into the indefinite
future. However, each year begins an identical cycle, and because spring employment is
known, it is possible to consider only one cycle of four seasons ending with the spring
season, as summarized below.
Stage 1  summer,
Stage 2  autumn,
Stage 3  winter,
Stage 4  spring.
xn  employment level for stage n (n  1, 2, 3, 4).
(x4  255.)
It is necessary that the spring season be the last stage because the optimal value of
the decision variable for each state at the last stage must be either known or obtainable
without considering other stages. For every other season, the solution for the optimal employment level must consider the effect on costs in the following season.
Let
rn  minimum employment requirement for stage n,
where these requirements were given earlier as r1  220, r2  240, r3  200, and
r4  255. Thus, the only feasible values for xn are
rn  xn  255.
Referring to the cost data given in the problem statement, we have
Cost for stage n  200(xn  xn1)2  2,000(xn  rn).

|

▲

▲

Note that the cost at the current stage depends upon only the current decision xn and
the employment in the preceding season xn1. Thus, the preceding employment level is

|

e-Text Main Menu

|

Textbook Table of Contents

|

554

11

DYNAMIC PROGRAMMING

TABLE 11.3 Data for the Local Job Shop problem
n

rn

Feasible xn

Possible sn  xn1

Cost

1
2
3
4

220
240
200
255

220  x1  255
240  x2  255
200  x3  255
x4  255

s1  255
220  s2  255
240  s3  255
200  s4  255

200(x1  255)2  2,000(x1  220)
200(x2  x1)2  2,000(x2  240)
200(x3  x2)2  2,000(x3  200)
200(255  x3)2

all the information about the current state of affairs that we need to determine the optimal policy henceforth. Therefore, the state sn for stage n is
State sn  xn1.
When n  1, s1  x0  x4  255.
For your ease of reference while working through the problem, a summary of the data
is given in Table 11.3 for each of the four stages.
The objective for the problem is to choose x1, x2, x3 (with x0  x4  255) so as to
4

Minimize

[200(xi  xi1)2  2,000(xi  ri)],

i1

subject to
ri  xi  255,

for i  1, 2, 3, 4.

Thus, for stage n onward (n  1, 2, 3, 4), since sn  xn1
fn(sn, xn)  200(xn  sn)2  2,000(xn  rn)
4

 [200(xi  xi1)2  2,000(xi  ri)],
r x 255 in1

 min
i

i

where this summation equals zero when n  4 (because it has no terms). Also,
f n*(sn) 

min

rnxn255

fn(sn, xn).

Hence,
fn(sn, xn)  200(xn  sn)2  2,000(xn  rn)  f *n1(xn)
(with f5* defined to be zero because costs after stage 4 are irrelevant to the analysis). A
summary of these basic relationships is given in Fig. 11.8.

State:

▲

▲

|

xn

sn

Value: fn(sn, xn)
 sum

|

Stage
n1

Stage
n

FIGURE 11.8
The basic structure for the
Local Job Shop problem.

200(xn  sn)2  2,000(xn  rn)

e-Text Main Menu

|

xn
f *n  1(xn)

Textbook Table of Contents

|

11.3 DETERMINISTIC DYNAMIC PROGRAMMING

555

Consequently, the recursive relationship relating the f n* functions is
f n*(sn)  min

rnxn255

{200(xn  sn)2  2,000(xn  rn)  f *n1(xn)}.

The dynamic programming approach uses this relationship to identify successively
these functions—f 4*(s4), f 3*(s3), f 2*(s2), f 1*(255)—and the corresponding minimizing xn.
Solution Procedure. Stage 4: Beginning at the last stage (n  4), we already know
that x4*  255, so the necessary results are

n  4:

s4

f 4*(s4)

x4*

200  s4  255

200(255  s4)2

255

Stage 3: For the problem consisting of just the last two stages (n  3), the recursive
relationship reduces to
f *3 (s3) 


min

{200(x3  s3)2  2,000(x3  200)  f *4 (x3)}

min

{200(x3  s3)2  2,000(x3  200)  200(255  x3)2},

200x3255
200x3255

where the possible values of s3 are 240  s3  255.
One way to solve for the value of x3 that minimizes f3(s3, x3) for any particular value
of s3 is the graphical approach illustrated in Fig. 11.9.

FIGURE 11.9
Graphical solution for f 3*(s3)
for the Local Job Shop
problem.

200(255  x3)2

Sum  f3(s3, x3)

200(x3  s3)2

f *3(s3)

2,000(x3  200)

|

▲

▲

200

|

e-Text Main Menu

s3

|

s3  250
2

Textbook Table of Contents

255

|

x3

556

11

DYNAMIC PROGRAMMING

However, a faster way is to use calculus. We want to solve for the minimizing x3 in
terms of s3 by considering s3 to have some fixed (but unknown) value. Therefore, set the
first (partial) derivative of f3(s3, x3) with respect to x3 equal to zero:
	
 f3(s3, x3)  400(x3  s3)  2,000  400(255  x3)
	x3
 400(2x3  s3  250)
 0,
which yields
s3  250
x3*  
.
2
Because the second derivative is positive, and because this solution lies in the feasible interval for x3 (200  x3  255) for all possible s3 (240  s3  255), it is indeed the desired minimum.
Note a key difference between the nature of this solution and those obtained for the
preceding examples where there were only a few possible states to consider. We now have
an infinite number of possible states (240  s3  255), so it is no longer feasible to solve
separately for x3* for each possible value of s3. Therefore, we instead have solved for x3*
as a function of the unknown s3.
Using







2
s3  250
s3  250
f 3*(s3)  f3(s3, x3*)  200 
  s3  200 255  

2
2
s3  250
 2,000 
  200
2





2



and reducing this expression algebraically complete the required results for the third-stage
problem, summarized as follows.

n  3:

s3

f 3*(s3)

x3*

240  s3  255

50(250  s3)2  50(260  s3)2  1,000(s3  150)

s3  250

2

Stage 2: The second-stage (n  2) and first-stage problems (n  1) are solved in a
similar fashion. Thus, for n  2,
f2(s2, x2)  200(x2  s2)2  2,000(x2  r2)  f 3*(x2)
 200(x2  s2)2  2,000(x2  240)
 50(250  x2)2  50(260  x2)2  1,000(x2  150).
The possible values of s2 are 220  s2  255, and the feasible region for x2 is 240 
x2  255. The problem is to find the minimizing value of x2 in this region, so that

|

▲

▲

f 2*(s2) 

|

min

240x2255

f2(s2, x2).

e-Text Main Menu

|

Textbook Table of Contents

|

11.3 DETERMINISTIC DYNAMIC PROGRAMMING

557

Setting to zero the partial derivative with respect to x2:
	
 f2(s2, x2)  400(x2  s2)  2,000  100(250  x2)  100(260  x2)  1,000
	x2
 200(3x2  2s2  240)
0
yields
2s2  240
x2  
.
3
Because
	2
2 f2(s2, x2)  600 
 0,
	x2
this value of x2 is the desired minimizing value if it is feasible (240  x2  255). Over
the possible s2 values (220  s2  255), this solution actually is feasible only if 240 
s2  255.
Therefore, we still need to solve for the feasible value of x2 that minimizes f2(s2, x2)
when 220  s2  240. The key to analyzing the behavior of f2(s2, x2) over the feasible
region for x2 again is the partial derivative of f2(s2, x2). When s2  240,
	
 f2(s2, x2) 
 0,
	x2

for 240  x2  255,

so that x2  240 is the desired minimizing value.
The next step is to plug these values of x2 into f2(s2, x2) to obtain f 2*(s2) for s2  240
and s2  240. This yields
n  2:

s2

f 2*(s2)

x2*

220  s2  240

200(240  s2)2  115,000
200
 [(240  s2)2  (255  s2)2
9
 (270  s2)2]  2,000(s2  195)

240
2s2  240

3

240  s2  255

Stage 1: For the first-stage problem (n  1),
f1(s1, x1)  200(x1  s1)2  2,000(x1  r1)  f 2*(x1).
Because r1  220, the feasible region for x1 is 220  x1  255. The expression for f 2*(x1)
will differ in the two portions 220  x1  240 and 240  x1  255 of this region.
Therefore,

|

▲

▲

 200(x1  s1)2  2,000(x1  220)  200(240  x1)2  115,000,

if 220  x1  240

f1(s1, x1)  
200
2
[(240  x1)2  (255  x1)2  (270  x1)2]
 200(x1  s1)  2,000(x1  220)  
9


 2,000(x1  195),
if 240  x1  255.

|

e-Text Main Menu

|

Textbook Table of Contents

|

558

11

DYNAMIC PROGRAMMING

Considering first the case where 220  x1  240, we have
	
 f1(s1, x1)  400(x1  s1)  2,000  400(240  x1)
	x1
 400(2x1  s1  235).
It is known that s1  255 (spring employment), so that
	
 f1(s1, x1)  800(x1  245)  0
	x1
for all x1  240. Therefore, x1  240 is the minimizing value of f1(s1, x1) over the region
220  x1  240.
When 240  x1  255,
	
 f1(s1, x1)  400(x1  s1)  2,000
	x1
400
 [(240  x1)  (255  x1)  (270  x1)]  2,000
9
400
  (4x1  3s1  225).
3
Because
	2

f (s , x ) 
 0
	x12 1 1 1

for all x1,

set
	
 f1(s1, x1)  0,
	x1
which yields
3s1  225
x1  
.
4
Because s1  255, it follows that x1  247.5 minimizes f1(s1, x1) over the region
240  x1  255.
Note that this region (240  x1  255) includes x1  240, so that f1(s1, 240) 
 f1(s1,
247.5). In the next-to-last paragraph, we found that x1  240 minimizes f1(s1, x1) over the
region 220  x1  240. Consequently, we now can conclude that x1  247.5 also minimizes f1(s1, x1) over the entire feasible region 220  x1  255.
Our final calculation is to find f 1*(s1) for s1  255 by plugging x1  247.5 into the
expression for f1(255, x1) that holds for 240  x1  255. Hence,
f 1*(255)  200(247.5  255)2  2,000(247.5  220)

|

▲

▲

200
  [2(250  247.5)2  (265  247.5)2  30(742.5  575)]
9
 185,000.

|

e-Text Main Menu

|

Textbook Table of Contents

|

11.3 DETERMINISTIC DYNAMIC PROGRAMMING

559

These results are summarized as follows:
n  1:

s1

f 1*(s1)

x1*

255

185,000

247.5

Therefore, by tracing back through the tables for n  2, n  3, and n  4, respectively, and setting sn  x*n1 each time, the resulting optimal solution is x1*  247.5,
x2*  245, x3*  247.5, x4*  255, with a total estimated cost per cycle of $185,000.

To conclude our illustrations of deterministic dynamic programming, we give one example that requires more than one variable to describe the state at each stage.
EXAMPLE 5

Wyndor Glass Company Problem
Consider the following linear programming problem:
Maximize

Z  3x1  5x2,

subject to
x1  2x2  4
3x1  2x2  12
3x1  2x2  18
and
x1  0,

x2  0.

(You might recognize this as being the model for the Wyndor Glass Co. problem—introduced in Sec. 3.1.) One way of solving small linear (or nonlinear) programming problems
like this one is by dynamic programming, which is illustrated below.
Formulation. This problem requires making two interrelated decisions, namely, the
level of activity 1, denoted by x1, and the level of activity 2, denoted by x2. Therefore,
these two activities can be interpreted as the two stages in a dynamic programming formulation. Although they can be taken in either order, let stage n  activity n (n  1, 2).
Thus, xn is the decision variable at stage n.
What are the states? In other words, given that the decision had been made at prior
stages (if any), what information is needed about the current state of affairs before the decision can be made at stage n? Reflection might suggest that the required information is
the amount of slack left in the functional constraints. Interpret the right-hand side of these
constraints (4, 12, and 18) as the total available amount of resources 1, 2, and 3, respectively (as described in Sec. 3.1). Then state sn can be defined as

|

▲

▲

State sn  amount of respective resources still available for allocation to
remaining activities.

|

e-Text Main Menu

|

Textbook Table of Contents

|

560

11

DYNAMIC PROGRAMMING

(Note that the definition of the state is analogous to that for distribution of effort problems, including Examples 2 and 3, except that there are now three resources to be allocated instead of just one.) Thus,
sn  (R1, R2, R3),
where Ri is the amount of resource i remaining to be allocated (i  1, 2, 3). Therefore,
s1  (4, 12, 18),
s2  (4  x1, 12, 18  3x1).
However, when we begin by solving for stage 2, we do not yet know the value of x1, and
so we use s2  (R1, R2, R3) at that point.
Therefore, in contrast to the preceding examples, this problem has three state variables (i.e., a state vector with three components) at each stage rather than one. From a
theoretical standpoint, this difference is not particularly serious. It only means that, instead of considering all possible values of the one state variable, we must consider all possible combinations of values of the several state variables. However, from the standpoint
of computational efficiency, this difference tends to be a very serious complication. Because the number of combinations, in general, can be as large as the product of the number of possible values of the respective variables, the number of required calculations tends
to “blow up” rapidly when additional state variables are introduced. This phenomenon has
been given the apt name of the curse of dimensionality.
Each of the three state variables is continuous. Therefore, rather than consider each
possible combination of values separately, we must use the approach introduced in Example 4 of solving for the required information as a function of the state of the system.
Despite these complications, this problem is small enough that it can still be solved
without great difficulty. To solve it, we need to introduce the usual dynamic programming
notation. Thus,
f2(R1, R2, R3, x2)  contribution of activity 2 to Z if system starts in state
(R1, R2, R3) at stage 2 and decision is x2
 5x2,
f1(4, 12, 18, x1)  contribution of activities 1 and 2 to Z if system starts in state
(4, 12, 18) at stage 1, immediate decision is x1, and then
optimal decision is made at stage 2,
 3x1 
max
{5x2}.
x212
2x2183x1
x20

Similarly, for n  1, 2,
f n*(R1, R2, R3)  max

fn(R1, R2, R3, xn),

xn

|

▲

▲

where this maximum is taken over the feasible values of xn. Consequently, using the relevant portions of the constraints of the problem gives

|

(1)

f 2*(R1, R2, R3)  max {5x2},

(2)

f1(4, 12, 18, x1)  3x1  f 2*(4  x1, 12, 18  3x1),

2x2R2
2x2R3
x20

e-Text Main Menu

|

Textbook Table of Contents

|

11.3 DETERMINISTIC DYNAMIC PROGRAMMING

561

f 1*(4, 12, 18)  max {3x1  f 2*(4  x1, 12, 18  3x1)}.

(3)

x14
3x118
x10

Equation (1) will be used to solve the stage 2 problem. Equation (2) shows the basic
dynamic programming structure for the overall problem, also depicted in Fig. 11.10. Equation (3) gives the recursive relationship between f 1* and f 2* that will be used to solve the
stage 1 problem.
Solution Procedure. Stage 2: To solve at the last stage (n  2), Eq. (1) indicates that
x2* must be the largest value of x2 that simultaneously satisfies 2x2  R2, 2x2  R3, and
x2  0. Assuming that R2  0 and R3  0, so that feasible solutions exist, this largest
value is the smaller of R2 /2 and R3 /2. Thus, the solution is
n  2:

(R1, R2, R3)

f 2*(R1, R2, R3)

x2*

R2  0, R3  0

R2 R3
5 min ,

2 2



R2 R3
min ,

2 2







Stage 1: To solve the two-stage problem (n  1), we plug the solution just obtained
for f 2*(R1, R2, R3) into Eq. (3). For stage 2,
(R1, R2, R3)  (4  x1, 12, 18  3x1),
so that
R2 R3
12 18  3x1
f 2*(4  x1, 12, 18  3x1)  5 min ,
  5 min , 
2 2
2
2









is the specific solution plugged into Eq. (3). After we combine its constraints on x1, Eq.
(3) then becomes
f1*(4, 12, 18)  max

0x14

3x

1

12 18  3x1
 5 min , 
.
2
2





Over the feasible interval 0  x1  4, notice that



6
12 18  3x1
min , 

3
2
2
9   x1
2



FIGURE 11.10
The basic structure for the
Wyndor Glass Co. linear
programming problem.



x1

4, 12, 18

▲

▲

Value: f1(4, 12, 18, x1)
 sum

|

|

e-Text Main Menu

if 2  x1  4,

Stage
2

Stage
1
State:

if 0  x1  2

4  x1, 12, 18  3x1

3x1

|

f *2 (4

 x1, 12, 18  3x1)

Textbook Table of Contents

|

562

11

DYNAMIC PROGRAMMING

so that



3x1  30
12 18  3x1
3x1  5 min , 

9
2
2
45  x1
2





if 0  x1  2
if 2  x1  4.

Because both
max {3x1  30}

and

0x12

max

2x14

45  92 x 
1

achieve their maximum at x1  2, it follows that x1*  2 and that this maximum is 36, as
given in the following table.
n  1:

(R1, R2, R3)

f 1*(R1, R2, R3)

x1*

(4, 12, 18)

36

2

Because x1*  2 leads to
R1  4  2  2,

R2  12,

R3  18  3(2)  12

for stage 2, the n  2 table yields x2*  6. Consequently, x1*  2, x2*  6 is the optimal
solution for this problem (as originally found in Sec. 3.1), and the n  1 table shows that
the resulting value of Z is 36.

11.4

PROBABILISTIC DYNAMIC PROGRAMMING

|

▲

▲

Probabilistic dynamic programming differs from deterministic dynamic programming in
that the state at the next stage is not completely determined by the state and policy decision at the current stage. Rather, there is a probability distribution for what the next state
will be. However, this probability distribution still is completely determined by the state
and policy decision at the current stage. The resulting basic structure for probabilistic dynamic programming is described diagrammatically in Fig. 11.11.
For the purposes of this diagram, we let S denote the number of possible states at
stage n  1 and label these states on the right side as 1, 2, . . . , S. The system goes to
state i with probability pi (i  1, 2, . . . , S) given state sn and decision xn at stage n. If
the system goes to state i, Ci is the contribution of stage n to the objective function.
When Fig. 11.11 is expanded to include all the possible states and decisions at all the
stages, it is sometimes referred to as a decision tree. If the decision tree is not too large,
it provides a useful way of summarizing the various possibilities.
Because of the probabilistic structure, the relationship between fn(sn, xn) and the
f *n1(sn1) necessarily is somewhat more complicated than that for deterministic dynamic
programming. The precise form of this relationship will depend upon the form of the overall objective function.
To illustrate, suppose that the objective is to minimize the expected sum of the contributions from the individual stages. In this case, fn(sn, xn) represents the minimum ex-

|

e-Text Main Menu

|

Textbook Table of Contents

|

11.4 PROBABILISTIC DYNAMIC PROGRAMMING

563

Stage n  1

Stage n
Probability

State:

sn

Decision

xn

p1
p2
pS

fn(sn, xn)

Contribution
from stage n





1

C1

f n*  1(1)

C2

2
f n*  1(2)

CS
FIGURE 11.11
The basic structure for
probabilistic dynamic
programming.




S
f n*  1(S)

pected sum from stage n onward, given that the state and policy decision at stage n are
sn and xn, respectively. Consequently,
S

fn(sn, xn)   pi[Ci  f *n1(i)],
i1

with
f *n1(i)  min fn1(i, xn1),
xn1

where this minimization is taken over the feasible values of xn1.
Example 6 has this same form. Example 7 will illustrate another form.
EXAMPLE 6

Determining Reject Allowances

|

▲

▲

The HIT-AND-MISS MANUFACTURING COMPANY has received an order to supply
one item of a particular type. However, the customer has specified such stringent quality
requirements that the manufacturer may have to produce more than one item to obtain an
item that is acceptable. The number of extra items produced in a production run is called
the reject allowance. Including a reject allowance is common practice when producing
for a custom order, and it seems advisable in this case.
The manufacturer estimates that each item of this type that is produced will be acceptable with probability 12 and defective (without possibility for rework) with probability
1
. Thus, the number of acceptable items produced in a lot of size L will have a binomial
2
distribution; i.e., the probability of producing no acceptable items in such a lot is (12)L.
Marginal production costs for this product are estimated to be $100 per item (even if
defective), and excess items are worthless. In addition, a setup cost of $300 must be incurred whenever the production process is set up for this product, and a completely new
setup at this same cost is required for each subsequent production run if a lengthy in-

|

e-Text Main Menu

|

Textbook Table of Contents

|

564

11

DYNAMIC PROGRAMMING

spection procedure reveals that a completed lot has not yielded an acceptable item. The
manufacturer has time to make no more than three production runs. If an acceptable item
has not been obtained by the end of the third production run, the cost to the manufacturer
in lost sales income and penalty costs will be $1,600.
The objective is to determine the policy regarding the lot size (1  reject allowance)
for the required production run(s) that minimizes total expected cost for the manufacturer.
Formulation.

A dynamic programming formulation for this problem is

Stage n  production run n (n  1, 2, 3),
xn  lot size for stage n,
State sn  number of acceptable items still needed (1 or 0) at beginning of stage n.
Thus, at stage 1, state s1  1. If at least one acceptable item is obtained subsequently, the
state changes to sn  0, after which no additional costs need to be incurred.
Because of the stated objective for the problem,
fn(sn, xn)  total expected cost for stages n, . . . , 3 if system starts in state sn at
stage n, immediate decision is xn, and optimal decisions are made
thereafter,
f n*(sn)  min fn(sn, xn),
xn0, 1, . . .

where f n*(0)  0. Using $100 as the unit of money, the contribution to cost from stage n
is [K(xn)  xn] regardless of the next state, where K(xn) is a function of xn such that
K(xn) 

0,3,

if xn  0
if xn 
 0.

Therefore, for sn  1,




1
fn(1, xn)  K(xn)  xn  
2
1
 K(xn)  xn  
2

xn

xn

    f*

1
f *n1(1)  1  
2

xn

n1(0)

f *n1(1)

[where f 4*(1) is defined to be 16, the terminal cost if no acceptable items have been obtained]. A summary of these basic relationships is given in Fig. 11.12.

Probability

FIGURE 11.12
The basic structure for the
Hit-and-Miss Manufacturing
Co. problem.

Contribution
from stage n
0

State:

1

Decision

xn

Value: fn(1, xn)
x
1 n*
 K(xn)xn
f
(1)
2 n1

()

1 xxn
1  ( 12 ) n
2

()
(12 )

K(xn)xn

f *n  1(0)  0

xn

K(xn)xn
1

|

▲

▲

f *n  1(1)

|

e-Text Main Menu

|

Textbook Table of Contents

|

11.4 PROBABILISTIC DYNAMIC PROGRAMMING

565

Consequently, the recursive relationship for the dynamic programming calculations is
f n*(1) 

min

xn0, 1, . . .





1
K(xn)  xn  
2

xn



f *n1(1)

for n  1, 2, 3.
Solution Procedure. The calculations using this recursive relationship are summarized as follows.

 

1
f3(1, x3)  K(x3)  x3  16 
2
n  3:

x3
s3

0

0

0

1

1

16

2

12

3

9

8

 

1
f2(1, x2)  K(x2)  x2  
2
n  2:

x2
s2

0

0

0

1

8

4

5

8

1
8
2

f 3*(s3)

x3*

0

0

8

3 or 4

x2

f 3*(1)

1

2

3

4

f 2*(s2)
0

0

8

7

7

1
7
2

7

2 or 3

 

1
f1(1, x1)  K(x1)  x1  
2
n  1:

x3

x1

x

x2*

1

f 2*(1)

s1

0

1

2

3

4

f 1*(s1)

x1*

1

7

1
7
2

3
6
4

7
6
8

7
7
16

3
6
4

2

Thus, the optimal policy is to produce two items on the first production run; if none
is acceptable, then produce either two or three items on the second production run; if none
is acceptable, then produce either three or four items on the third production run. The total expected cost for this policy is $675.

EXAMPLE 7

Winning in Las Vegas

|

▲

▲

An enterprising young statistician believes that she has developed a system for winning
a popular Las Vegas game. Her colleagues do not believe that her system works, so they
have made a large bet with her that if she starts with three chips, she will not have at least
five chips after three plays of the game. Each play of the game involves betting any de-

|

e-Text Main Menu

|

Textbook Table of Contents

|

566

11

DYNAMIC PROGRAMMING

sired number of available chips and then either winning or losing this number of chips.
The statistician believes that her system will give her a probability of 23 of winning a given
play of the game.
Assuming the statistician is correct, we now use dynamic programming to determine her optimal policy regarding how many chips to bet (if any) at each of the three
plays of the game. The decision at each play should take into account the results of
earlier plays. The objective is to maximize the probability of winning her bet with her
colleagues.
Formulation.

The dynamic programming formulation for this problem is

Stage n  nth play of game (n  1, 2, 3),
xn  number of chips to bet at stage n,
State sn  number of chips in hand to begin stage n.
This definition of the state is chosen because it provides the needed information about the
current situation for making an optimal decision on how many chips to bet next.
Because the objective is to maximize the probability that the statistician will win her
bet, the objective function to be maximized at each stage must be the probability of finishing the three plays with at least five chips. (Note that the value of ending with more
than five chips is just the same as ending with exactly five, since the bet is won either
way.) Therefore,
fn(sn, xn)  probability of finishing three plays with at least five chips, given that
the statistician starts stage n in state sn, makes immediate decision xn,
and makes optimal decisions thereafter,
f n*(sn) 
max
fn(sn, xn).
xn0, 1, . . . , sn

The expression for fn(sn, xn) must reflect the fact that it may still be possible to accumulate five chips eventually even if the statistician should lose the next play. If she
loses, the state at the next stage will be sn  xn, and the probability of finishing with at
least five chips will then be f *n1(sn  xn). If she wins the next play instead, the state will
become sn  xn, and the corresponding probability will be f *n1(sn  xn). Because the assumed probability of winning a given play is 23, it now follows that
1
2
fn(sn, xn)   f *n1(sn  xn)   f *n1(sn  xn)
3
3
[where f 4*(s4) is defined to be 0 for s4  5 and 1 for s4  5]. Thus, there is no direct contribution to the objective function from stage n other than the effect of then being in the
next state. These basic relationships are summarized in Fig. 11.13.
Therefore, the recursive relationship for this problem is
f n*(sn) 

max

xn0, 1, . . . , sn

13 f *

n1(sn



2
 xn)   f *n1(sn  xn) ,
3

|

▲

▲

for n  1, 2, 3, with f 4*(s4) as just defined.

|

e-Text Main Menu

|

Textbook Table of Contents

|

11.4 PROBABILISTIC DYNAMIC PROGRAMMING

Stage n

State:

sn

Probability

Decision

Contribution
from stage n
0

1
3

xn

Value: fn(sn, xn)
2
1
 f *n  1(sn  xn)  f *n  1(sn  xn)
3
3

FIGURE 11.13
The basic structure for the
Las Vegas problem.

567

2
3

Stage n  1
sn  xn
f *n  1(sn  xn)

0
sn  xn
f *n  1(sn  xn)

Solution Procedure. This recursive relationship leads to the following computational
results.
n  3:

s3

f 3*(s3)

x3*

0
1
2

0
0
0
2

3
2

3
1

—
—
—

3
4
5

2 (or more)
1 (or more)
0 (or  s3  5)

1
2
f2(s2, x2)  f 3*(s2  x2)  f 3*(s2  x2)
3
3
n  2:

x2
s2

0

0
1

0
0

2

0

3

2

3
2

3
1

4
5

1

0
4

9
4

9
8

9

2

4

9
2

3
2

3

3

4

2

3
2

3

f 2*(s2)

x2*

0
0
4

9
2

3
8

9
1

—
—

2

3

1 or 2
0, 2, or 3
1
0 (or  s2  5)

1
2
f1(s1, x1)  f 2*(s1  x1)  f 2*(s1  x1)
3
3

|

▲

▲

n  1:

|

x1
s1

0

1

2

3

f 1*(s1)

x1*

3

2

3

20

27

2

3

2

3

20

27

1

e-Text Main Menu

|

Textbook Table of Contents

|

568

11

DYNAMIC PROGRAMMING

Therefore, the optimal policy is

 if win,


x1*  1 

 if lose,


x2*  1

ifif win,
lose,



x3*  0
x3*  2 or 3.

x2*  1 or 2

if lose,

This policy gives the statistician a probability of

11.5

x3* 

if win,

21, or2, 33, or 4(for x (for 1)x*  2)
*
2

2

bet is lost
20

27

of winning her bet with her colleagues.

CONCLUSIONS
Dynamic programming is a very useful technique for making a sequence of interrelated
decisions. It requires formulating an appropriate recursive relationship for each individual problem. However, it provides a great computational savings over using exhaustive
enumeration to find the best combination of decisions, especially for large problems. For
example, if a problem has 10 stages with 10 states and 10 possible decisions at each stage,
then exhaustive enumeration must consider up to 10 billion combinations, whereas dynamic programming need make no more than a thousand calculations (10 for each state
at each stage).
This chapter has considered only dynamic programming with a finite number of stages.
Chapter 21 is devoted to a general kind of model for probabilistic dynamic programming
where the stages continue to recur indefinitely, namely, Markov decision processes.

SELECTED REFERENCES
1. Bertsekas, D. P.: Dynamic Programming: Deterministic and Stochastic Models, Prentice-Hall,
Englewood Cliffs, NJ, 1987.
2. Denardo, E. V.: Dynamic Programming Theory and Applications, Prentice-Hall, Englewood
Cliffs, NJ, 1982.
3. Howard, R. A.: “Dynamic Programming,” Management Science, 12: 317–345, 1966.
4. Smith, D. K.: Dynamic Programming: A Practical Introduction, Ellis Horwood, London, 1991.
5. Sniedovich, M.: Dynamic Programming, Marcel Dekker, New York, 1991.

LEARNING AIDS FOR THIS CHAPTER IN YOUR OR COURSEWARE
“Ch. 11—Dynamic Programming” LINGO File

|

▲

▲

LINGO

|

e-Text Main Menu

|

Textbook Table of Contents

|

CHAPTER 11 PROBLEMS

569

PROBLEMS
An asterisk on the problem number indicates that at least a partial
answer is given in the back of the book.

11.2-1. Consider the following network, where each number along
a link represents the actual distance between the pair of nodes connected by that link. The objective is to find the shortest path from
the origin to the destination.

f *2(A)  11
A

5

f *3(D)  6

9

D

7
(origin)

6

O

B

T

8
E

7
C

6

6

(destination)

7

f *3(E)  7

f *2(C)  13

(a) What are the stages and states for the dynamic programming
formulation of this problem?
(b) Use dynamic programming to solve this problem. However,
instead of using the usual tables, show your work graphically (similar to Fig. 11.2). In particular, start with the given
network, where the answers already are given for f n*(sn) for
four of the nodes; then solve for and fill in f 2*(B) and f 1*(O).
Draw an arrowhead that shows the optimal link to traverse
out of each of the latter two nodes. Finally, identify the optimal path by following the arrows from node O onward to
node T.
(c) Use dynamic programming to solve this problem by manually
constructing the usual tables for n  3, n  2, and n  1.
(d) Use the shortest-path algorithm presented in Sec. 9.3 to solve
this problem. Compare and contrast this approach with the one
in parts (b) and (c).

|

▲

▲

11.2-2. The sales manager for a publisher of college textbooks has
six traveling salespeople to assign to three different regions of the
country. She has decided that each region should be assigned at
least one salesperson and that each individual salesperson should
be restricted to one of the regions, but now she wants to determine
how many salespeople should be assigned to the respective regions
in order to maximize sales.

|

e-Text Main Menu

|

The following table gives the estimated increase in sales (in
appropriate units) in each region if it were allocated various numbers of salespeople:
Region
Salespersons

1

2

3

1
2
3
4

35
48
70
89

21
42
56
70

28
41
63
75

(a) Use dynamic programming to solve this problem. Instead of
using the usual tables, show your work graphically by constructing and filling in a network such as the one shown for
Prob. 11.2-1. Proceed as in Prob. 11.2-1b by solving for f n*(sn)
for each node (except the terminal node) and writing its value
by the node. Draw an arrowhead to show the optimal link (or
links in case of a tie) to take out of each node. Finally, identify the resulting optimal path (or paths) through the network
and the corresponding optimal solution (or solutions).
(b) Use dynamic programming to solve this problem by constructing the usual tables for n  3, n  2, and n  1.

Textbook Table of Contents

|

570

11

DYNAMIC PROGRAMMING

the problem of finding the longest path (the largest total time)
through this network from start to finish, since the longest path is
the critical path.

11.2-3. Consider the following project network when applying
PERT/CPM as described in Chap. 10, where the number over each
node is the time required for the corresponding activity. Consider

1
F
5

4
5
A

C

G
2
D

0

J

4

6

START

4

0

K

FINISH

H
7
3

3

2

B

E

I

(c) Once an optimal policy has been found for the overall problem, the information needed to specify the optimal decision at
a particular stage is the state at that stage and the decisions
made at preceding stages.

(a) What are the stages and states for the dynamic programming
formulation of this problem?
(b) Use dynamic programming to solve this problem. However,
instead of using the usual tables, show your work graphically.
In particular, fill in the values of the various f n*(sn) under the
corresponding nodes, and show the resulting optimal arc to traverse out of each node by drawing an arrowhead near the beginning of the arc. Then identify the optimal path (the longest
path) by following these arrowheads from the Start node to the
Finish node. If there is more than one optimal path, identify
them all.
(c) Use dynamic programming to solve this problem by constructing the usual tables for n  4, n  3, n  2, and n  1.

11.3-1.* The owner of a chain of three grocery stores has purchased
five crates of fresh strawberries. The estimated probability distribution of potential sales of the strawberries before spoilage differs
among the three stores. Therefore, the owner wants to know how
to allocate five crates to the three stores to maximize expected profit.
For administrative reasons, the owner does not wish to split
crates between stores. However, he is willing to distribute no crates
to any of his stores.
The following table gives the estimated expected profit at each
store when it is allocated various numbers of crates:

▲

▲

11.2-4. Consider the following statements about solving dynamic
programming problems. Label each statement as true or false, and
then justify your answer by referring to specific statements (with
page citations) in the chapter.
(a) The solution procedure uses a recursive relationship that enables solving for the optimal policy for stage (n  1) given the
optimal policy for stage n.
(b) After completing the solution procedure, if a nonoptimal decision is made by mistake at some stage, the solution procedure will need to be reapplied to determine the new optimal
decisions (given this nonoptimal decision) at the subsequent
stages.

|

|

e-Text Main Menu

L

Store

|

Crates

1

2

3

0
1
2
3
4
5

0
5
9
14
17
21

0
6
11
15
19
22

0
4
9
13
18
20

Textbook Table of Contents

|

CHAPTER 11 PROBLEMS

Use dynamic programming to determine how many of the five
crates should be assigned to each of the three stores to maximize
the total expected profit.
11.3-2. A college student has 7 days remaining before final examinations begin in her four courses, and she wants to allocate this
study time as effectively as possible. She needs at least 1 day on
each course, and she likes to concentrate on just one course each
day, so she wants to allocate 1, 2, 3, or 4 days to each course. Having recently taken an OR course, she decides to use dynamic programming to make these allocations to maximize the total grade
points to be obtained from the four courses. She estimates that the
alternative allocations for each course would yield the number of
grade points shown in the following table:

571

11.3-4. A political campaign is entering its final stage, and polls
indicate a very close election. One of the candidates has enough
funds left to purchase TV time for a total of five prime-time commercials on TV stations located in four different areas. Based on
polling information, an estimate has been made of the number of
additional votes that can be won in the different broadcasting areas depending upon the number of commercials run. These estimates are given in the following table in thousands of votes:
Area
Commercials

1

2

3

4

0
1
2
3
4
5

0
4
7
9
12
15

0
6
8
10
11
12

0
5
9
11
10
9

0
3
7
12
14
16

Estimated Grade Points
Course
Study Days

1

2

3

4

1
2
3
4

3
5
6
7

5
5
6
9

2
4
7
8

6
7
9
9

Solve this problem by dynamic programming.
11.3-3. A company is planning its advertising strategy for next
year for its three major products. Since the three products are quite
different, each advertising effort will focus on a single product. In
units of millions of dollars, a total of 6 is available for advertising
next year, where the advertising expenditure for each product must
be an integer greater than or equal to 1. The vice-president for marketing has established the objective: Determine how much to spend
on each product in order to maximize total sales. The following
table gives the estimated increase in sales (in appropriate units) for
the different advertising expenditures:

Product
Advertising
Expenditure

1

2

3

1
2
3
4

7
10
14
17

4
8
11
14

6
9
13
15

▲

▲

|

e-Text Main Menu

11.3-5. A county chairwoman of a certain political party is making plans for an upcoming presidential election. She has received
the services of six volunteer workers for precinct work, and she
wants to assign them to four precincts in such a way as to maximize their effectiveness. She feels that it would be inefficient to
assign a worker to more than one precinct, but she is willing to assign no workers to any one of the precincts if they can accomplish
more in other precincts.
The following table gives the estimated increase in the number of votes for the party’s candidate in each precinct if it were allocated various numbers of workers:
Precinct
Workers

1

2

3

4

0
1
2
3
4
5
6

0
4
9
15
18
22
24

0
7
11
16
18
20
21

0
5
10
15
18
21
22

0
6
11
14
16
17
18

This problem has several optimal solutions for how many of the
six workers should be assigned to each of the four precincts to

Use dynamic programming to solve this problem.

|

Use dynamic programming to determine how the five commercials should be distributed among the four areas in order to
maximize the estimated number of votes won.

|

Textbook Table of Contents

|

572

11 DYNAMIC PROGRAMMING

maximize the total estimated increase in the plurality of the party’s
candidate. Use dynamic programming to find all of them so the
chairwoman can make the final selection based on other factors.

(b) Now assume that any amount within the total budget can be spent
in each phase, where the estimated effect of spending an amount
xi (in units of millions of dollars) in phase i (i  1, 2, 3) is
m  10x1  x12
f2  0.40  0.10x2
f3  0.60  0.07x3.

11.3-6. Use dynamic programming to solve the Northern Airplane
Co. production scheduling problem presented in Sec. 8.1 (see Table
8.7). Assume that production quantities must be integer multiples
of 5.

[Hint: After solving for the f 2*(s) and f 3*(s) functions analytically,
solve for x1* graphically.]

11.3-7. Reconsider the Build-Em-Fast Co. problem described in
Prob. 8.1-9. Use dynamic programming to solve this problem.

11.3-9. The management of a company is considering three possible new products for next year’s product line. A decision now
needs to be made regarding which products to market and at what
production levels.
Initiating the production of two of these products would require a substantial start-up cost, as shown in the first row of the
table below. Once production is under way, the marginal net revenue from each unit produced is shown in the second row. The
third row gives the percentage of the available production capacity that would be used for each unit produced.

11.3-8.* A company will soon be introducing a new product into
a very competitive market and is currently planning its marketing strategy. The decision has been made to introduce the product in three phases. Phase 1 will feature making a special introductory offer of the product to the public at a greatly reduced
price to attract first-time buyers. Phase 2 will involve an intensive advertising campaign to persuade these first-time buyers to
continue purchasing the product at a regular price. It is known
that another company will be introducing a new competitive product at about the time that phase 2 will end. Therefore, phase 3
will involve a follow-up advertising and promotion campaign to
try to keep the regular purchasers from switching to the competitive product.
A total of $4 million has been budgeted for this marketing
campaign. The problem now is to determine how to allocate this
money most effectively to the three phases. Let m denote the initial share of the market (expressed as a percentage) attained in
phase 1, f2 the fraction of this market share that is retained in
phase 2, and f3 the fraction of the remaining market share that is
retained in phase 3. Given the following data, use dynamic programming to determine how to allocate the $4 million to maximize the final share of the market for the new product, i.e., to
maximize mf2 f3.
(a) Assume that the money must be spent in integer multiples of
$1 million in each phase, where the minimum permissible
multiple is 1 for phase 1 and 0 for phases 2 and 3. The following table gives the estimated effect of expenditures in each
phase:

Product

Start-up cost
Marginal net revenue
Capacity used per unit, %

f2

f3

0
1
2
3
4

—
20
30
40
50

0.2
0.4
0.5
0.6
—

0.3
0.5
0.6
0.7
—

|

▲

▲

m

|

e-Text Main Menu

2

3

3
2
20

2
3
40

0
1
20

Only 3 units of product 1 could be sold, whereas all units that
could be produced of the other two products could be sold. The
objective is to determine the number of units of each product to
produce in order to maximize the total profit (total net revenue minus start-up costs).
(a) Assuming that production quantities must be integers, use dynamic programming to solve this problem.
(b) Now consider the case where the divisibility assumption holds,
so that the variables representing production quantities are
treated as continuous variables. Assuming that proportionality
holds for both net revenues and capacities used, use dynamic
programming to solve this problem.

Effect on
Market Share
Millions of
Dollars Expended

1

11.3-10. Consider an electronic system consisting of four components, each of which must work for the system to function. The reliability of the system can be improved by installing several parallel units in one or more of the components. The following table
gives the probability that the respective components will function
if they consist of one, two, or three parallel units:

|

Textbook Table of Contents

|

CHAPTER 11 PROBLEMS

573

11.3-13. Consider the following integer nonlinear
programming problem.

Probability of Functioning
Parallel Units

Component 1

Component 2

Component 3

Component 4

1
2
3

0.5
0.6
0.8

0.6
0.7
0.8

0.7
0.8
0.9

0.5
0.7
0.9

The probability that the system will function is the product of
the probabilities that the respective components will function.
The cost (in hundreds of dollars) of installing one, two, or
three parallel units in the respective components is given by the
following table:

Maximize
subject to

x1  2x2  3x3  10
x1  1,
x2  1,

x1, x2, x3 are integers.
Use dynamic programming to solve this problem.
11.3-14.* Consider the following nonlinear programming problem.
Maximize

Parallel Units

Component 1

Component 2

Component 3

Component 4

1
2
3

1
2
3

2
4
5

1
3
4

2
3
4

11.3-11. Consider the following integer nonlinear programming
problem.
Maximize

Z  3x21  x31  5x22  x32,

x3  1,

and

Cost

Because of budget limitations, a maximum of $1,000 can be expended.
Use dynamic programming to determine how many parallel
units should be installed in each of the four components to maximize the probability that the system will function.

Z  x1x 22x 33,

x1  0,

Z  36x1  9x21  6x31
 36x2  3x32,

subject to
x1  x2  3
and
x2  0.

Use dynamic programming to solve this problem.
11.3-15. Re-solve the Local Job Shop employment scheduling
problem (Example 4) when the total cost of changing the level of
employment from one season to the next is changed to $100 times
the square of the difference in employment levels.
11.3-16. Consider the following nonlinear programming problem.

subject to

Z  2x21  2x2  4x3  x23

Maximize

x1  2x2  4

subject to

and

2x1  x2  x3  4

x1  0,
x2  0
x1, x2 are integers.

and
x1  0,

Use dynamic programming to solve this problem.

x2  0,

x3  0.

Use dynamic programming to solve this problem.
11.3-12. Consider the following integer nonlinear programming
problem.
Maximize

Z  18x1 

x21

 20x2  10x3,

11.3-17. Consider the following nonlinear programming problem.
Z  2x1  x 22,

Maximize
subject to

subject to

x 21  x 22  4

2x1  4x2  3x3  11

and

and

x1  0,

x1, x2, x3 are nonnegative integers.

Use dynamic programming to solve this problem.

▲

▲

Use dynamic programming to solve this problem.

|

|

e-Text Main Menu

x2  0.

|

Textbook Table of Contents

|

574

11

DYNAMIC PROGRAMMING

and

11.3-18. Consider the following nonlinear programming problem.
Z

Minimize



x 41

x1  0,

2x 22

Use dynamic programming to solve this problem.

subject to
x 21



x 22

x2  0.

 2.

11.3-23. Consider the following nonlinear programming problem.

(There are no nonnegativity constraints.) Use dynamic programming to solve this problem.

Z  5x1  x2,

Maximize
subject to

11.3-19. Consider the following nonlinear programming problem.
Z

Maximize

2x 21  x2  13
x 21  x2  9

x 21x2,

and

subject to
x 21

x1  0,

 x2  2.

Use dynamic programming to solve this problem.

(There are no nonnegativity constraints.) Use dynamic programming to solve this problem.

11.3-24. Consider the following “fixed-charge” problem.

11.3-20. Consider the following nonlinear programming problem.
Z

Maximize

x 31



4x 22

Maximize

 16x3,

x1  3x2  2x3  6
x1  x2  2x3  5

x1x2x3  4

and

and
x2  1,

x1  0,

x3  1.



0
f (x3)  1  x3

subject to
x1  x2  x3  1
and
x3  0.

Use dynamic programming to solve this problem.
11.3-22. Consider the following linear programming problem.
Maximize

if x3  0
if x3 
 0.

11.4-1. A backgammon player will be playing three consecutive
matches with friends tonight. For each match, he will have the opportunity to place an even bet that he will win; the amount bet can
be any quantity of his choice between zero and the amount of
money he still has left after the bets on the preceding matches. For
each match, the probability is 12 that he will win the match and thus
win the amount bet, whereas the probability is 12 that he will lose
the match and thus lose the amount bet. He will begin with $75,
and his goal is to have $100 at the end. (Because these are friendly
matches, he does not want to end up with more than $100.) Therefore, he wants to find the optimal betting policy (including all ties)
that maximizes the probability that he will have exactly $100 after the three matches.
Use dynamic programming to solve this problem.

Z  x1(1  x2)x3,

x2  0,

x3  0,

Use dynamic programming to solve this problem.

11.3-21. Consider the following nonlinear programming problem.
Maximize

x2  0,

where

(a) Solve by dynamic programming when, in addition to the given
constraints, all three variables also are required to be integer.
(b) Use dynamic programming to solve the problem as given (continuous variables).

x1  0,

Z  3x1  7x2  6f (x3),

subject to

subject to

x1  1,

x2  0.

Z  15x1  10x2,

subject to
x1  2x2  6
3x1  x2  8

|

▲

▲

11.4-2. Imagine that you have $5,000 to invest and that you will
have an opportunity to invest that amount in either of two invest-

|

e-Text Main Menu

|

Textbook Table of Contents

|

CHAPTER 11 PROBLEMS

ments (A or B) at the beginning of each of the next 3 years. Both
investments have uncertain returns. For investment A you will either lose your money entirely or (with higher probability) get back
$10,000 (a profit of $5,000) at the end of the year. For investment
B you will get back either just your $5,000 or (with low probability) $10,000 at the end of the year. The probabilities for these events
are as follows:
Amount
Returned ($)

Probability

A

0
10,000

0.3
0.7

B

5,000
10,000

0.9
0.1

Investment

You are allowed to make only (at most) one investment each year,
and you can invest only $5,000 each time. (Any additional money
accumulated is left idle.)
(a) Use dynamic programming to find the investment policy that
maximizes the expected amount of money you will have after
3 years.
(b) Use dynamic programming to find the investment policy that
maximizes the probability that you will have at least $10,000
after 3 years.
11.4-3.* Suppose that the situation for the Hit-and-Miss Manufacturing Co. problem (Example 6) has changed somewhat. After
a more careful analysis, you now estimate that each item produced
will be acceptable with probability 23, rather than 12, so that the probability of producing zero acceptable items in a lot of size L is (13)L.
Furthermore, there now is only enough time available to make two
production runs. Use dynamic programming to determine the new
optimal policy for this problem.

|

▲

▲

11.4-4. Reconsider Example 7. Suppose that the bet is changed as
follows: “Starting with two chips, she will not have at least five
chips after five plays of the game.” By referring to the previous
computational results, make additional calculations to determine
the new optimal policy for the enterprising young statistician.

|

e-Text Main Menu

|

575

11.4-5. The Profit & Gambit Co. has a major product that has been
losing money recently because of declining sales. In fact, during
the current quarter of the year, sales will be 4 million units below
the break-even point. Because the marginal revenue for each unit
sold exceeds the marginal cost by $5, this amounts to a loss of $20
million for the quarter. Therefore, management must take action
quickly to rectify this situation. Two alternative courses of action
are being considered. One is to abandon the product immediately,
incurring a cost of $20 million for shutting down. The other alternative is to undertake an intensive advertising campaign to increase
sales and then abandon the product (at the cost of $20 million) only
if the campaign is not sufficiently successful. Tentative plans for
this advertising campaign have been developed and analyzed. It
would extend over the next three quarters (subject to early cancellation), and the cost would be $30 million in each of the three quarters. It is estimated that the increase in sales would be approximately 3 million units in the first quarter, another 2 million units
in the second quarter, and another 1 million units in the third quarter. However, because of a number of unpredictable market variables, there is considerable uncertainty as to what impact the advertising actually would have; and careful analysis indicates that
the estimates for each quarter could turn out to be off by as much
as 2 million units in either direction. (To quantify this uncertainty,
assume that the additional increases in sales in the three quarters
are independent random variables having a uniform distribution
with a range from 1 to 5 million, from 0 to 4 million, and from
1 to 3 million, respectively.) If the actual increases are too small,
the advertising campaign can be discontinued and the product abandoned at the end of either of the next two quarters.
If the intensive advertising campaign were initiated and continued to its completion, it is estimated that the sales for some time
thereafter would continue to be at about the same level as in the
third (last) quarter of the campaign. Therefore, if the sales in that
quarter still were below the break-even point, the product would
be abandoned. Otherwise, it is estimated that the expected discounted profit thereafter would be $40 for each unit sold over the
break-even point in the third quarter.
Use dynamic programming to determine the optimal policy
maximizing the expected profit.

Textbook Table of Contents

|

