Chapter 19Data StructuresBased on slides  McGraw-HillAdditional material  2004/2005/2006 Lewis/Martin 19-2CSE 240Data StructuresData structure: particular organization of data in memoryGroup related items togetherOrganize so that convenient to program and efficient to executeExampleAn array is one kind of data structureWe will look at. . .struct  Cs mechanism for building data structureslinked list  built from struct19-3CSE 240Structures in CThe C structMechanism for grouping related data of different types(Array elements must be of same type)ExampleSuppose we want to keep track of weather data for the past 100days, and for each day, we want the following dataint highTemp;int lowTemp;double precip;double windSpeed;int windDirection;We can use a struct to group these data19-4CSE 240Declaring a structWe name the struct and declare fields (or members)struct w_type {int highTemp;int lowTemp;double precip;double windSpeed;int windDirection;};This is declaration so no memory is actually allocated!19-5CSE 240Defining and Using a structWe define a variable using our new data typestruct w_type day;Memory is allocated (on stack), and we can accessindividual fields of this variableday.highTemp = 32;day.lowTemp = 22;Struct declaration determines layout in memoryday.highTempday.lowTempday.precipday.windSpeedday.windDirection322219-6CSE 240Declaring and Defining at OnceYou can both declare and define a struct at same timestruct w_type {int highTemp;int lowTemp;double precip;double windSpeed;int windDirection;} day;Can still use the w_type name to declare other structsstruct w_type day2;19-7CSE 240typedefC provides a way to define new data type namesSyntax   typedef <type> <name>;Examples   typedef int Color;   typedef struct w_type WeatherData;   typedef struct ab_type {     int a;     double b;   } ABGroup;19-8CSE 240Using typedefBenefitCode more readable because we have application-specific types   Color pixels[128*124];   WeatherData day1, day2;Common practicePut typedefs into a header fileUse type names in programIf the definition of Color/WeatherData changes, might not need tochange the code in rest of program19-9CSE 240LC-3 Code for StructsConsider the following code. . .int x;WeatherData day;int y;day.highTemp = 12;day.lowTemp = 1;day.windDirection = 3;...xday.highTempday.lowTempday.precipday.windSpeedday.windDirectionyoffset = 3456789101119-10CSE 240Code for Structs; day.highTemp = 12;     AND R1, R1, #0  ; R1 = 12     ADD R1, R1, #12     ADD R0, R6, #4  ; R0 has base addr of day     ADD R0, R0, #0  ; add offset to highTemp     STR R1, R0, #0  ; store value into day.highTemp; day.lowTemp = 1;     AND R1, R1, #0  ; R1 = 1     ADD R1, R1, #1     ADD R0, R6, #4  ; R0 has base addr of day     ADD R0, R0, #1  ; add offset to lowTemp     STR R1, R0, #0  ; store value into day.lowTemp; day.windDirection = 3;     AND R1, R1, #0  ; R1 = 3     ADD R1, R1, #3     ADD R0, R6, #4  ; R0 has base addr of day     ADD R0, R0, #6  ; add offset to windDirection     STR R1, R0, #0  ; store value into day.windDirection19-11CSE 240Array of StructsCan define an array of structs  WeatherData days[100];Each array element is a struct7 words, in this caseTo access member of particular element  days[34].highTemp = 97;select elementselect field19-12CSE 240Pointers to StructWe can define and create a pointer to a struct  WeatherData *dayPtr;  // define ptr not WeatherData  dayPtr = &days[34];To access a member of the struct addressed by dayPtr  (*dayPtr).highTemp = 97;. operator has higher precedence than *, so this is NOT the same as  *dayPtr.highTemp = 97;      *(dayPtr.highTemp) = 97;Special syntax for this common access pattern  dayPtr->highTemp = 97;19-13CSE 240Passing Structs as ArgumentsUnlike an array, structs passed by valuestruct members copied to functions activation record, andchanges inside function are not reflected in the calling routinescopyMost of the time, youll want to pass a pointer to  a structint InputDay(WeatherData *day){  printf(High temp in deg F: );  scanf(%d, &day->highTemp);  printf(Low temp in deg F: );  scanf(%d, &day->lowTemp);  ...}19-14CSE 240Dynamic AllocationProblemWhat if we dont know the number of days for our weatherprogram?Cant allocate array, because dont know maximum number ofdays that might be requiredEven if we do know the maximum number, it might be wasteful toallocate that much memory because most of the time only a fewdays worth of data is neededSolutionAllocate storage dynamically, as needed19-15CSE 240mallocC Library function for allocating memory at run-time   void *malloc(int numBytes);ReturnsGeneric pointer (void*) to contiguous region of memory ofrequested size (in bytes)Bytes are allocated from memory region called heapHeap != stackRun-time system keeps track of chunks of memory in heap thathave been allocated19-16CSE 240Using mallocProblemData type sizes are implementation specificSolutionUse sizeof operator to get size of particular typeWeatherData *days;days = malloc(n * sizeof(WeatherData));Also need to change type of return value to proper kind of pointerCalled casting   days = (WeatherData*)            malloc(n* sizeof(WeatherData));19-17CSE 240Exampleint numberOfDays;WeatherData *days;printf(How many days of weather?);scanf(%d, &numberOfDays);days = (WeatherData*) malloc(sizeof(WeatherData)                             * numberOfDays);if (days == NULL) {  printf(Error in allocating the data array.\n);  ...}days[0].highTemp = ...If allocation fails, malloc returns NULL (zero)Note: Can use array notationor pointer notation19-18CSE 240freeWhen program is done with malloced dataIt must/should be released for reuseAchieved via free functionfree is passed same pointer returned by mallocvoid free(void*);Other pointers (e.g., to the stack) may not be freedIf allocated data is not freedProgram may run out of heap memory and be unable to continueExplicit memory management versus garbage collection19-19CSE 240Example: The Linked List Data StructureLinked listOrdered collection of nodesEach of which contains some dataConnected using pointers!Each node contains address of next node in list!Last node points to NULLFirst node in list is called headLast node in list is called tailNode 0Node 1Node 2NULL19-20CSE 240Linked List vs. ArrayAdvantage of linked listDynamic size (easy to add or remove nodes)Advantage of arrayEasy/fast element accessElement accessLinked list elements can only be accessed sequentiallye.g., to find the 5th element, you must start from head and followthe links through four other nodes19-21CSE 240Example: Car LotGoalCreate inventory database for used car lotSupport the following operations!Search database for a particular vehicle!Add new vehicle to database!Delete vehicle from databaseImplementationSince we dont know how many cars might be on lot at one time,we choose a linked list representationIn order to have faster search, the database must remainsorted by vehicle ID19-22CSE 240CarNodeEach vehicle has the following characteristicsVehicle ID, make, model, year, mileage, cost(And... pointer to next node)typedef struct car_node CarNode;struct car_node {  int vehicleID;  char make[20];  char model[20];  int year;  int mileage;  double cost;  CarNode *next; /* ptr to next car in list */}19-23CSE 240Scanning the ListScanningSearching, adding, and deleting require us to find a particularnode in the listScan list until we find node whose ID is >= one were looking forCarNode *scan_list(CarNode *head, int searchID){  CarNode *previous, *current;  previous = head;  current = head->next;  /* Traverse until ID >= searchID */  while ((current != NULL) &&         (current->vehicleID < searchID)) {    previous = current;    current = current->next;  }  return previous;}19-24CSE 240Adding a NodeStepsCreate new node with proper info (via malloc)Find node (if any) with a greater vehicleID (via scan_list)Splice the new node into the list (update next fields)Node 0Node 1Node 2NULLnew node19-25CSE 240Excerpts from Code to Add a NodenewNode = (CarNode*) malloc(sizeof(CarNode));/* initialize node with new car info */...prevNode = scan_list(head, newNode->vehicleID);nextNode = prevNode->next;if ((nextNode != NULL) &&    (nextNode->vehicleID == newNode->vehicleID))  prevNode->next = newNode;  newNode->next = nextNode;} else {  printf(Car already exists in database.);  free(newNode);}19-26CSE 240Deleting a NodeStepsFind the node that points to the desired node (via scan_list)Redirect that nodes pointer to the next node (or NULL)Free the deleted nodes memoryNode 0Node 1Node 2NULL19-27CSE 240Excerpts from Code to Delete a Nodeprintf(Enter vehicle ID of car to delete:\n);scanf(%d, &vehicleID);prevNode = scan_list(head, vehicleID);delNode = prevNode->next;if ((delNode != NULL) &&    (delNode->vehicleID == vehicleID))  prevNode->next = delNode->next;  free(delNode);}else {  printf(Vehicle not found in database.\n);}19-28CSE 240Beyond Linked ListsThe linked list is a fundamental data structureDynamicEasy to add and delete nodesOther data structuresLeverage same techniques as linked listsTreesHash TablesDirected Acyclic Graphs. . .19-29CSE 240Tree-Based Symbol TableBig PictureEach node holds a symbol/address pairstruct sym_node_struct {  char* symbol;  int address;  sym_node_t* left;  sym_node_t* right;};Operationsvoid sym_table_insert(char *, int);int sym_table_lookup(char *);Node 0Node 1Node 2Node 3Node 4NULLNULLNULLNULLNULLNULLNode 5NULLNULL19-30CSE 240Tree-Based Symbol Table (cont.)InvariantAt each node, all symbols in left children alphabetically precedesymbol in node itselfAlso, all symbols in right children alphabetically follow nodessymbolImplicationsFaster lookupSlower insertion(cant just prepend)OptimizationsBalancingRedistributingNode 0Node 1Node 2Node 3Node 4NULLNULLdogcatantsnakeferretNULLNULLNULLNULL19-31CSE 240Multi-File CompilationProblemWhat if your program is too big to fit in a single .c file?SolutionDistribute your code across multiple filesBuilding% gcc -o mylc3as mylc3as.c sym_table.c parser.c. . . or . . .% gcc -c mylc3as.c sym_table.c% gcc -c parser.c% lsmylc3as.c     parser.c     sym_table.cmylc3as.o     parser.o     sym_table.o% gcc -o mylc3as mylc3as.o sym_table.o parser.oLinking19-32CSE 240Multi-File Compilation (cont.)ProblemHow does one file share code/data with another?SolutionDefinitions versus declarationsDefinition: actually allocates storage or creates functionDeclaration: states properties of variable or functionmylc3as.csym_table_add(...);sym_table.cvoid sym_table_add(...){ ...}void sym_table_add(...);DefinitionDeclaration19-33CSE 240Multi-File Compilation (cont.)What about variables?Use the extern keyword to distinguish declaration fromdefinitionExampleextern int glob;glob = 3;What if declarations are wrong?Link-time error (if you are lucky)19-34CSE 240Multi-File Compilation (cont.)ProblemsWe have to type in lots of declarationsWe have lots of duplicate declarationsSolutionType them in once and include them many timesExamplemylc3as.cglob = 3;sym_table_add(...);sym_table.cint glob;void sym_table_add(...){ ...}#include sym_table.hsym_table.hextern int glob;void sym_table_add(...);DeclarationsDefinition19-35CSE 240C Preprocessor (CPP)CPP implements includePrecedes actual C compilation processAllows programmer to extend the languageCPP supports macros#define PI 3.14159#define max(a,b) (((a)>(b))?(a):(b))CPP supports conditional compilation#ifdef PIprintf(No PI...\n);#endif19-36CSE 240Command Line ArgumentsC programs may access command line arguments% emacs mylc3sim.cQ: How does a C program get these arguments?A: Via function parameters to main()int main(int argc, char **argv) {    if (argc > 1) {        printf(First arg: %s\n", argv[1]);    }}No. of args +1Array of strings